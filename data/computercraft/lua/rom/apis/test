local db = {}

-- short hand for current test to run
function T()
    T_enterpise_colonization()
--    role_settler.BuildSiloL0()
--    T_enterprise_construction1()
--    T_enterprise_construction2()
--    T_role_builder()
--    T_enterprise_test()
end

function T_enterpise_colonization()
    -- test CreateNewWorld
    coreutils.WriteToLog("# Test CreateNewWorld")
    local callbackFunction = "test.GoHomeCallBack"

    coreutils.WriteToLog("T_enterpise_colonization calling CreateNewWorld("..callbackFunction..")")
    enterprise_colonization.CreateNewWorld(callbackFunction)
end

function GoHome()
    coremove.GoTo({
        x	= 0,
        y	= 0,
        z	= 1,
        dx	= 0,
        dy	= 1,
    })
end

function GoStart()
    coremove.GoTo({x= 3, y= 2, z= 1, dx=0, dy=1})
end

function Reset()
    coremove.SetLocation({
        x	= 0,
        y	= 0,
        z	= 1,
        dx	= 0,
        dy	= 1,
    })
end

local testStartLocation  = {x= 0, y= 0, z= 1, dx=0, dy=1}

local testBuildPattern = {
    deltaX      = 4,
    deltaY      = 6,
    objectList  = {
        { x = 0, y = 3,                 block = "minecraft:torch"},
        { x = 2, y = 5, dx = 0, dy = 1, block = "minecraft:chest"},
        { x = 3, y = 0,                 block = "minecraft:torch"},
    },
    clearRemainingSpace = true,
}

local testBlueprint = {
    layerList = {
        { startpoint = { x= 0, y= 0, z=  0}, buildFromAbove  = true, pattern = enterprise_storage.topLayerL0_pattern},
        { startpoint = { x= 3, y= 3, z= -1}, buildFromAbove  = false, pattern = enterprise_storage.shaftLayer_pattern},
        { startpoint = { x= 2, y= 2, z= -2}, buildFromAbove  = false, pattern = enterprise_storage.chestLayer_pattern},
        { startpoint = { x= 2, y= 2, z= -3}, buildFromAbove  = false, pattern = role_builder.CopyPattern(enterprise_storage.chestLayer_pattern)}
    },
    escapeSequence = {
        { x= 3, y= 3, z=  1},
    }
}

function T_enterprise_construction1()
    -- test service 1
    coreutils.WriteToLog("# Test 1")
    local buildData = {startpoint = testStartLocation, buildFromAbove = true, pattern = testBuildPattern}
    local callbackFunction = "test.Func1_Callback"

    coreutils.WriteToLog("T_enterprise_construction calling BuildRectangularPattern("..textutils.serialise(buildData)..", "..callbackFunction..")")
    enterprise_construction.BuildRectangularPattern(buildData, callbackFunction)
end

function T_enterprise_construction2()
    -- test service 2
    coreutils.WriteToLog("# Test 2")
    local blueprintBuildData = {blueprintStartpoint = coremove.GetRelativeLocation(testStartLocation, 6, 0, 0), blueprint = testBlueprint}
    local callbackFunction = "test.Func1_Callback"
    local callbackArgumentTable = {}
    coreutils.WriteToLog("T_enterprise_construction calling BuildBlueprint("..textutils.serialise(blueprintBuildData)..", "..callbackFunction..")")
    enterprise_construction.BuildBlueprint(blueprintBuildData, callbackFunction, callbackArgumentTable)
end

function T_role_builder()
    local buildData = {startpoint = testStartLocation, buildFromAbove = true, pattern = testBuildPattern}

    role_builder.BuildRectangularPattern_Task(buildData)
end

function T_enterprise_test()
    -- init
    local testArg = 20

    -- test service 1
    coreutils.WriteToLog("# Test 1")
    local testResult = enterprise_test.TestPureLogicService(testArg)
    coreutils.WriteToLog("  TestPureLogicService("..testArg..") => " .. testResult .. ".")

    -- test service 2
    coreutils.WriteToLog("# Test 2")
    enterprise_test.TestServiceWithAssignment(testArg)

    -- test service 3
    coreutils.WriteToLog("# Test 3")
    local callbackFunction = "test.Func1_Callback"
    enterprise_test.TestServiceWithAssignmentAndCallback(testArg, callbackFunction)

    -- test service 4
    coreutils.WriteToLog("# Test 4")
    local callbackArgumentTable = {"calbackArg1"}
    enterprise_test.TestServiceWithAssignmentAndCallbackAndArguments(testArg, callbackFunction, callbackArgumentTable)
end

function Func1_Callback(callbackArgumentTable, taskResult)
    coreutils.WriteToLog("test.Func1_Callback("..textutils.serialise(callbackArgumentTable)..", "..textutils.serialise(taskResult)..") called")
end

function GoHomeCallBack(callbackArgumentTable, taskResult)
    coreutils.WriteToLog("test.GoHomeCallBack("..textutils.serialise(callbackArgumentTable)..", "..textutils.serialise(taskResult)..") called")

    GoHome()
end

function BirchGrow()
    -- zorg dat er een kist onder de turtle staat met een paar saplings. De turtle moet een modem (links) en een diamond axe (rechts of inventory) hebben

    local saplings
    local logs
    local sticks

    local growTime
    local fuelUsage
    local harvestTime

    -- quip the axe / hatchet
    coreinventory.Equip("minecraft:diamond_axe")

    -- remove the ground under us, usefull for crafting later
    --turtle.digDown()

    -- plant the sappling
    turtle.suckDown(1)
    coreinventory.SelectItem("minecraft:birch_sapling")
    turtle.place()

    -- endless
    while true do
        -- sepling just planted, record the time
        growTime = coreutils.UniversalTime()

        -- wait for a tree
        local has_block, data
        while not has_block or type(data) ~= "table" or data.name ~= "minecraft:birch_log" do
            -- ff wachten
            os.sleep(0.25)

            -- opnieuw kijken
            has_block, data = turtle.inspect()
        end

        -- grown!
        growTime = coreutils.UniversalTime() - growTime

        -- move into position (don't count this step as harvesting)
        coremove.Up()
        fuelUsage   = turtle.getFuelLevel()
        harvestTime = coreutils.UniversalTime()

        -- boom omhakken
        role_forester.KapBoom()

        -- klaar met omhakken, wat hebben we geleerd?
        fuelUsage   = fuelUsage                 - turtle.getFuelLevel()
        harvestTime = coreutils.UniversalTime() - harvestTime

        -- terug naar onze plek
        coremove.Backward()
        coremove.Down()

        -- inventory tellen
        saplings    = coreinventory.CountItem("minecraft:birch_sapling") - 1
        logs        = coreinventory.CountItem("minecraft:birch_log")
        sticks      = coreinventory.CountItem("minecraft:stick")

        -- sapling in the chest
        coreinventory.DropAll("minecraft:birch_sapling", "down")

        -- use as fuel what we can
        for slot=1,16 do turtle.select(slot) turtle.refuel() end

        -- clean inventory
        coreinventory.DropAllItems("down")

        -- save the data
        coredht.SaveData({
            saplings    = saplings,
            logs        = logs,
            sticks      = sticks,
            fuelUsage   = fuelUsage,
            growTime    = growTime,
            harvestTime = harvestTime,
        }, "test", "BirchGrow", coreutils.NewId())

        -- info
        print("Fuel level: "..turtle.getFuelLevel().."units")

        -- get one new sapling
        turtle.suckDown(1)
    end
end

function BirchGrowToFile()
    -- get the data
    local filename  = '/log/birchgrow.csv'
    local data = coredht.GetData("test", "BirchGrow")

    coreutils.WriteToLog("data:")
    coreutils.WriteToLog(data)

    -- new file
    coreutils.WriteToFile(filename, "saplings;logs;sticks;fuelUsage;growTime;harvestTime", "overwrite")

    -- loop entries
    for k, v in pairs(data) do
        coreutils.WriteToFile(filename, v.saplings..";"..v.logs..";"..v.sticks..";"..v.fuelUsage..";"..string.format("%.3f", v.growTime)..";"..string.format("%.3f", v.harvestTime), "append")
    end
end


function Excavate()
    role_excavator.Excavate({
        startLocation       = {y = 0, x = 0, z = 0, dx = 0, dy = 1 },
        dimensions          = {dx = 6, dy = 3, dz = 1 },
        outputLocation      = "inventory",
        backToStartLocation = true
    })
end

