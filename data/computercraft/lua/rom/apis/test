local db = {}

-- short hand for current test to run
function T()
    T_enterprise_construction()
--    T_role_builder()
--    T_enterprise_test()
end

local testStartLocation  = {x= 0, y= 0, z= 1, dx=0, dy=1}

local testBuildPattern = {
    deltaX      = 4,
    deltaY      = 6,
    objectList  = {
        { x = 0, y = 3,                 block = "minecraft:torch"},
        { x = 2, y = 5, dx = 0, dy = 1, block = "minecraft:chest"},
        { x = 3, y = 0,                 block = "minecraft:torch"},
    },
    clearRemainingSpace = true,
}

function T_enterprise_construction()
    local buildData = {startpoint = testStartLocation, buildFromAbove = true, pattern = testBuildPattern}
    local callbackFunction = "test.ACallBack1"

    -- test service 1   
    coreutils.WriteToLog("# Test 1")

    coreutils.WriteToLog("T_enterprise_construction calling BuildRectangularPattern("..textutils.serialise(buildData)..", "..callbackFunction..")")
    enterprise_construction.BuildRectangularPattern(buildData, callbackFunction)
end

function T_role_builder()
    local buildData = {startpoint = testStartLocation, buildFromAbove = true, pattern = testBuildPattern}

    role_builder.BuildRectangularPattern_Task(buildData)
end

function T_enterprise_test()
    -- init
    local testArg = 20

    -- test service 1   
    coreutils.WriteToLog("# Test 1")
    local testResult = enterprise_test.TestPureLogicService(testArg)
    coreutils.WriteToLog("  TestPureLogicService("..testArg..") => " .. testResult .. ".")

    -- test service 2   
    coreutils.WriteToLog("# Test 2")
    enterprise_test.TestServiceWithAssignment(testArg)

    -- test service 3
    coreutils.WriteToLog("# Test 3")
    local callbackFunction = "test.ACallBack1"
    enterprise_test.TestServiceWithAssignmentAndCallback(testArg, callbackFunction)
end

function ACallBack1(taskArgumentTable, taskResult)
    coreutils.WriteToLog("ACallBack("..textutils.serialise(taskArgumentTable)..", "..textutils.serialise(taskResult)..") called")
end

function BirchGrow()
    -- zorg dat er een kist onder de turtle staat met een paar saplings. De turtle moet een modem (links) en een diamond axe (rechts of inventory) hebben

    local saplings
    local logs
    local sticks

    local growTime
    local fuelUsage
    local harvestTime

    -- quip the axe / hatchet
    coreinventory.Equip("minecraft:diamond_axe")

    -- remove the ground under us, usefull for crafting later
    --turtle.digDown()

    -- plant the sappling
    turtle.suckDown(1)
    coreinventory.SelectItem("minecraft:birch_sapling")
    turtle.place()

    -- endless
    while true do
        -- sepling just planted, record the time
        growTime = coreutils.UniversalTime()

        -- wait for a tree
        local has_block, data
        while not has_block or type(data) ~= "table" or data.name ~= "minecraft:birch_log" do
            -- ff wachten
            os.sleep(0.25)

            -- opnieuw kijken
            has_block, data = turtle.inspect()
        end

        -- grown!
        growTime = coreutils.UniversalTime() - growTime

        -- move into position (don't count this step as harvesting)
        coremove.Up()
        fuelUsage   = turtle.getFuelLevel()
        harvestTime = coreutils.UniversalTime()

        -- boom omhakken
        role_forester.KapBoom()

        -- klaar met omhakken, wat hebben we geleerd?
        fuelUsage   = fuelUsage                 - turtle.getFuelLevel()
        harvestTime = coreutils.UniversalTime() - harvestTime

        -- terug naar onze plek
        coremove.Backward()
        coremove.Down()

        -- inventory tellen
        saplings    = coreinventory.CountItem("minecraft:birch_sapling") - 1
        logs        = coreinventory.CountItem("minecraft:birch_log")
        sticks      = coreinventory.CountItem("minecraft:stick")

        -- sapling in the chest
        coreinventory.DropAll("minecraft:birch_sapling", "down")

        -- use as fuel what we can
        for slot=1,16 do turtle.select(slot) turtle.refuel() end

        -- clean inventory
        coreinventory.DropAllItems("down")

        -- save the data
        coredht.SaveData({
            saplings    = saplings,
            logs        = logs,
            sticks      = sticks,
            fuelUsage   = fuelUsage,
            growTime    = growTime,
            harvestTime = harvestTime,
        }, "test", "BirchGrow", coreutils.NewId())

        -- info
        print("Fuel level: "..turtle.getFuelLevel().."units")

        -- get one new sapling
        turtle.suckDown(1)
    end
end

function BirchGrowToFile()
    -- get the data
    local filename  = '/log/birchgrow.csv'
    local data = coredht.GetData("test", "BirchGrow")

    coreutils.WriteToLog("data:")
    coreutils.WriteToLog(data)

    -- new file
    coreutils.WriteToFile(filename, "saplings;logs;sticks;fuelUsage;growTime;harvestTime", "overwrite")

    -- loop entries
    for k, v in pairs(data) do
        coreutils.WriteToFile(filename, v.saplings..";"..v.logs..";"..v.sticks..";"..v.fuelUsage..";"..string.format("%.3f", v.growTime)..";"..string.format("%.3f", v.harvestTime), "append")
    end
end


function Excavate()
    role_excavator.Excavate({
        startLocation       = {y = 0, x = 0, z = 0, dx = 0, dy = 1 },
        dimensions          = {dx = 6, dy = 3, dz = 1 },
        outputLocation      = "inventory",
        backToStartLocation = true
    })
end

