local db = {
    dhtRoot         = "enterprise_assignmentboard",
    dhtList         = "assignmentList",
    dhtStatistics   = "statistics",

    skipReasons = {},
}

--[[
    The AssignmentBoard is an enterprise that offers services for the handling of Assignments.

    Assignments allow for a sequence of things to be done (e.g. moving, rotating, placing etc) without interruption
    by a turtle in the physical minecraft world.

    The enterprise maintains a list of assignments that were posted to it. It offers services for finding, applying to,
    selecting, taking and ending (removing) these assignments.

    It does so by providing the following public services
        DoAssignment_ASrv       - to post an Assignment for execution via the enterprise
        FindBestAssignment_SSrv - finds the best available Assignment
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function DoAssignment_ASrv(serviceData, callback, callbackData)
    --[[
        This async public service posts an Assignment for execution via the enterprise.

        The Assignment is not necessarily directly executed. It is added to the list of assignments in the
        enterprise and serviced via it's services for eventual execution.

        A task function takes one parameter
            taskData                - (table) data to supply to task function to be able to perform the task
        and return
            taskResult              - (table) with return data of the task function

        Async service return value (to callback):
            task result             - (table) results of the task function

        Parameters:
            serviceData             - (table) data for this service
                metaData            - (table) with metadata on the Task (used in the the assignment selection proces (e.g. the fuel needs of the task))
                task                - (string) name of the the Task function to execute
                taskData            - (table) data to supply to Task function to be able to perform the task
            callback                - (string) name of function to call once service (assignment) is ready
            callbackData            - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_assignmentboard.DoAssignment_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local metaData = serviceData.metaData
    if type(metaData) ~= "table" then corelog.Error("enterprise_assignmentboard.DoAssignment_ASrv: Invalid metaData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    metaData.startTime      = metaData.startTime    or coreutils.UniversalTime()    --> tijd wanneer de assignment uitgevoerd moet worden, zal niet starten voor deze tijd
    metaData.location       = metaData.location     or nil      --> nil-waarde voor locatie geeft aan dat locatie geen rol speelt bij de selectie
    metaData.needTool       = metaData.needTool     or false    --> needTool geeft aan dat de turtle zelf voor een tool moet zorgen
    metaData.needTurtle     = metaData.needTurtle   or true
    metaData.needTurtleId   = metaData.needTurtleId or nil      --> nil-waarde voor needTurtleId geeft aan dat turtleId geen rol speelt bij de selectie
    metaData.fuelNeeded     = metaData.fuelNeeded   or 500      --> minimum amount of fuel needed to grant assignment
    metaData.itemsNeeded    = metaData.itemsNeeded  or {}       --> items needed in inventory to grant assignment
    metaData.priorityKey    = metaData.priorityKey  or nil      --> priorityKey given to assignment (it fuelTurtlePriorityKey is set for a turtle, it will only take assignments with that key)
    local task = serviceData.task
    if type(task) ~= "string" then corelog.Error("enterprise_assignmentboard.DoAssignment_ASrv: Invalid task") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    -- ToDo: investigate if there is a way to check if the actual function exists and has the proper argument without actually calling it
    local taskData = serviceData.taskData
    if type(taskData) ~= "table" then corelog.Error("enterprise_assignmentboard.DoAssignment_ASrv: Invalid taskData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_assignmentboard.DoAssignment_ASrv: Invalid callback") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    -- ToDo: investigate if there is a way to check if the actual function exists and has the proper arguments without actually calling it
    if type(callbackData) ~= "table" then corelog.Error("enterprise_assignmentboard.DoAssignment_ASrv: Invalid callbackData") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- create assignment
    local assignmentId  = coreutils.NewId()
    local assignment = {
        assignmentId            = assignmentId,
        status                  = "open",
        applications            = {},

        metaData                = metaData,
        taskFunction            = task,
        taskData                = taskData,
        callbackFunction        = callback,
        callbackData            = callbackData,
    }

    -- log assignment
    corelog.WriteToAssignmentLog("Add new: "..textutils.serialize(assignment), assignmentId)

    -- check for new locations
    local statistics = GetStatistics_Att()
    local statisticsChanged = false
    local location = metaData.location
    if location then
        -- min
        local minLocation = statistics.minLocation
        local newMinLocation = coremove.MinLocation(minLocation, location)
        if not coremove.IsSameLocation(minLocation, newMinLocation) then
            -- set new value
            statistics.minLocation = newMinLocation
            statisticsChanged = true
        end

        -- max
        local maxLocation = statistics.maxLocation
        local newMaxLocation = coremove.MaxLocation(maxLocation, location)
        if not coremove.IsSameLocation(maxLocation, newMaxLocation) then
            -- set new value
            statistics.maxLocation = newMaxLocation
            statisticsChanged = true
        end

        -- maxFuelNeed_Travel
        if statisticsChanged then
            statistics.maxFuelNeed_Travel = role_fuel_worker.NeededFuelToFrom(newMinLocation, newMaxLocation)
        end
    end

    -- check for higher fuelNeed
    local fuelNeed = metaData.fuelNeeded
    if fuelNeed > statistics.maxFuelNeed_Assignment then
        -- set new value
        statistics.maxFuelNeed_Assignment = fuelNeed
        statisticsChanged = true
    end

    -- save statistics
    if statisticsChanged then
        -- save statistics
        coredht.SaveData(statistics, db.dhtRoot, db.dhtStatistics)
    end

    -- store assignment
    coredht.SaveData(assignment, db.dhtRoot, db.dhtList, assignmentId)
end

function GetStatistics_Att()
    return coredht.GetData(db.dhtRoot, db.dhtStatistics)
end

function FindBestAssignment_SSrv(serviceData)
    --[[
        This sync public service finds the best available Assignment for a turtle based on an assignmentFilter and turtleResume.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                assignmentId        - (number) id of found assignment (==nil if no assignment was found)

        Parameters:
            serviceData             - (table) data for this service
                assignmentFilter    - (table) filter to apply in finding an Assignment
                turtleResume        - (table) turtle "resume" to consider in finding an Assignment
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_chests.FindBestAssignment_SSrv: Invalid serviceData") return {success = false} end
    local assignmentFilter = serviceData.assignmentFilter
    if type(assignmentFilter) ~= "table" then corelog.Error("enterprise_chests.FindBestAssignment_SSrv: Invalid assignmentFilter") return {success = false} end
    local turtleResume = serviceData.turtleResume
    if type(turtleResume) ~= "table" then corelog.Error("enterprise_chests.FindBestAssignment_SSrv: Invalid turtleResume") return {success = false} end

    -- zoeken naar een assignment om op in te schrijven
    local assignmentList = coredht.GetData(db.dhtRoot, db.dhtList)

    -- check assignmentList
    if not assignmentList or type(assignmentList) ~= "table" then corelog.Error("enterprise_assignmentboard.FindBestAssignment: invalid assignmentList") return nil end

    -- check for assignments
    if next(assignmentList) == nil then
--        corelog.WriteToAssignmentLog("There are no assignments")
        return { success = true }
    end

    -- select assignments satisfying meta conditions
    local candidateList = {}
    for assignmentId, assignmentData in pairs(assignmentList) do
        -- check assignment open
        if assignmentData.status == "open" then
            -- check metaconditions
            local conditionsMet, skipReason = MetaDataConditionsMet(assignmentData.metaData, assignmentFilter, turtleResume)
            if conditionsMet then
                table.insert(candidateList, {
                    id = assignmentId,
                    metaData = assignmentData.metaData,
                })
            else
                -- debug message
                if skipReason and not KnownSkipReason(skipReason) then
                    -- Report reason for skipping for debugging purposes
                    corelog.WriteToAssignmentLog("Skipped because "..skipReason, assignmentId)

                    -- remember such that the log isn't floaded with similar messages
                    RememberSkipReason(skipReason)
                end
            end
        end
    end

    -- select best assignment
    local bestCandidateData = nil
    for i, candidateData in ipairs(candidateList) do
        bestCandidateData = BestCandidate(bestCandidateData, candidateData)
    end

    -- end
    if bestCandidateData then
        -- we found a new candidate, forget the reasons we skipped until now
        ForgetSkipReasons()

        -- return best candidate
        local result = {
            success         = true,
            assignmentId    = bestCandidateData.id
        }
        return result
    else
        -- corelog.WriteToAssignmentLog("No assignment satisfying conditions")
        return { success = true }
    end
end

function ApplyToAssignment(assignmentId) -- ToDo: make this a proper sync service
--    corelog.WriteToAssignmentLog("Running ApplyToAssignment", assignmentId)

    -- alleen solliciteren indien de assignment open is
    if coredht.GetData(db.dhtRoot, db.dhtList, assignmentId, "status") == "open" then
        -- wie zijn we?
        local me = os.getComputerID()

        -- onzelf (os.getComputerID()) toevoegen aan de lijst met inschrijvingen
        coredht.SaveData({
            time            = coreutils.UniversalTime(),
            dice            = math.random(),
            applicant       = me,
        }, db.dhtRoot, db.dhtList, assignmentId, "applications", me)
    end
end

function AssignmentSelectionProcedure(assignmentId) -- ToDo: make this a proper sync service
--    corelog.WriteToAssignmentLog("Running assignmentSelectionProcedure", assignmentId)

    -- data van de assignment ophalen
    local assignment = coredht.GetData(db.dhtRoot, db.dhtList, assignmentId)

    -- see if this assignment is still open
    if assignment.status == "open" then
        --
        local applications = coredht.GetData(db.dhtRoot, db.dhtList, assignmentId, "applications")

        -- see who got the highest dice
        local highestDiceTurtle = nil
        local highestDiceValue = 0
        for turtleId, applicationData in pairs(applications) do
            if applicationData.dice >= highestDiceValue then
                highestDiceValue = applicationData.dice
                highestDiceTurtle = applicationData.applicant
            end
        end

        -- check if I got the highest dice
        if highestDiceTurtle == os.getComputerID() then
            return assignment
        end
    end

    -- apparently it's not for me
    return nil
end

function TakeAssignment(assignmentId) -- ToDo: make this a proper sync service
    -- data van de assignment ophalen
    local assignment = coredht.GetData(db.dhtRoot, db.dhtList, assignmentId)

    -- see if this assignment is still open
    if assignment.status == "open" then
        -- mark as staffed
        coredht.SaveData("staffed", db.dhtRoot, db.dhtList, assignmentId, "status")

        corelog.WriteToAssignmentLog("Taken", assignmentId)
    end
end

function EndAssignment(assignmentId) -- ToDo: make this a proper sync service
    -- easy
    coredht.SaveData(nil, db.dhtRoot, db.dhtList, assignmentId)
    corelog.WriteToAssignmentLog("Ended", assignmentId)
end

function Dummy_Callback(emptyTable)
    corelog.WriteToAssignmentLog("Dummy_Callback called")
    -- do nothing
end

function Reset()
    -- end assignments
    EndAssignments()

    -- reset statistics
    ResetStatistics()

    -- reset (local) db
    db.skipReasons  = {}
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function ResetStatistics()
    coredht.SaveData({
        maxFuelNeed_Assignment  = 0,
        minLocation             = {x= 0, y= 0, z= 1, dx=0, dy=1},
        maxLocation             = {x= 0, y= 0, z= 1, dx=0, dy=1},
        maxFuelNeed_Travel      = 0,
    }, db.dhtRoot, db.dhtStatistics)
end

function EndAssignments()
    local assignmentList = coredht.GetData(db.dhtRoot, db.dhtList)
    if not assignmentList or type(assignmentList) ~= "table" then corelog.Warning("enterprise_assignmentboard.EndAssignments: not a (valid) assignmentList") return nil end

    -- remove all assignments
    corelog.WriteToAssignmentLog("All Assignments are being ended!")
    for assignmentId, assignmentData in pairs(assignmentList) do
        -- check status and startTime
        EndAssignment(assignmentId)
    end
end

function DHTReadySetup()
    -- bestaat de entry al in de dht?
    if not coredht.GetData(db.dhtRoot)              then coredht.SaveData({}, db.dhtRoot ) end
    if not coredht.GetData(db.dhtRoot, db.dhtList) then coredht.SaveData({}, db.dhtRoot, db.dhtList ) end
end

function ForgetSkipReasons()
    db.skipReasons = {}
end

function RememberSkipReason(skipReason)
    table.insert(db.skipReasons, skipReason)
end

function KnownSkipReason(skipReason)
    -- check skipReason is known
    for i, prevSkipReason in ipairs(db.skipReasons) do
        if skipReason == prevSkipReason then return true end
    end

    -- end
    return false
end

function BestCandidate(candidateData1, candidateData2)
    -- check for data
    if not candidateData1 then
        return candidateData2
    end
    if not candidateData2 then
        return candidateData1
    end

    -- check needTurtleId
    local needTurtleId1 = candidateData1.metaData.needTurtleId
    local needTurtleId2 = candidateData2.metaData.needTurtleId
    if needTurtleId1 and not needTurtleId2 then
        return candidateData1
    elseif needTurtleId2 and not needTurtleId1 then
        return candidateData2
    else -- both are equal w.r.t. this condition
    end

    -- check fuelNeeded
    -- ToDo implement

    -- check age
    -- ToDo implement

    -- nothing else distinquishes the candidates => take first
    return candidateData1
end

function MetaDataConditionsMet(metaData, assignmentFilter, turtleResume)
    -- check startTime
    local now = coreutils.UniversalTime()
    if metaData.startTime > now then
        return false, "assignment in the future (="..metaData.startTime..")"
    end

    -- check priorityKeyNeeded
    local priorityKeyNeeded = assignmentFilter.priorityKeyNeeded
    if priorityKeyNeeded then
        if metaData.priorityKey ~= priorityKeyNeeded then
            return false, "assignment does not `have`(="..(metaData.priorityKey or "nil")..") mandatory priorityKeyNeeded (="..priorityKeyNeeded..")"
        end
    end

    -- check optional turtle conditions
    if metaData.needTurtle then
        -- check mandatory turtle
        if not turtleResume then
            return false, "mandatory turtle (resume) not present"
        end

        -- check needTurtleId
        local turtleId = turtleResume.turtleId
        if metaData.needTurtleId then
            if turtleId ~= metaData.needTurtleId then
                return false, "turtle does not have(="..turtleId..") mandatory turtleId (="..metaData.needTurtleId..")"
            end
        end

        -- check enough fuel for assignment
        local fuelNeeded = metaData.fuelNeeded
        if metaData.location then -- optionally include traveling to assignment location from current location
            local location = turtleResume.location
            fuelNeeded = fuelNeeded + role_fuel_worker.NeededFuelToFrom(metaData.location, location)
        end
        if fuelNeeded > 0 then
            -- check fuel available
            local fuelLevel = turtleResume.fuelLevel
            if fuelLevel < fuelNeeded then
                return false, "turtle does not have(="..fuelLevel..") enough(="..fuelNeeded..") fuel"
            end
        end

        -- check need pickaxe
        if metaData.needTool then
            -- check mandatory pickaxe
            local axePresent = turtleResume.axePresent
            if not axePresent then
                return false, "turtle does not have mandatory pickaxe"
            end
        end

        -- check items in inventory
        local inventoryItems = turtleResume.inventoryItems
        for itemName, itemCount in pairs(metaData.itemsNeeded) do
            -- get items in inventory
            local inventoryItemCount = inventoryItems[itemName] or 0

            -- enough?
            if inventoryItemCount < itemCount then
                return false, "turtle does not have(="..inventoryItemCount..") enough(="..itemCount..") "..itemName.." in inventory"
            end
        end
    end

    return true, ""
end
