
--[[
    This file implements an CCWorldPlatform URL.

    See https://github.com/REReal8/CCWorldPlatform/wiki/Uniform-Resource-Locators for more on URLs

    Note that the syntax used is such that it prepares for a more object oriented Lua approach. See more from here https://www.lua.org/pil/16.html . 
    ToDo: is it possible to do proper oo as described within CC (I failed with the file naming up until now)?
--]]

function New(host, port, path, query)
    --[[
        Constructs an URL object.

        Return values:
                                - public methods of a URL
        
        Parameters:
            host                - (string) depicting the host sub-component of the URL (e.g. "turtle", "world" or "storage")
            port                - [optional] (string) defining the port sub-component of the URL (e.g. the id of a turtle, i.e. "30")  
            path                - [optional] (table) of key-value pairs with path segments
                                    (e.g. {x=12, y=12, z= 1} indicating a location in the "world" host)
            query               - [optional] (table) of key-value pairs with (item) query segments
                                    (e.g. {"minecraft:torch"=5, "minecraft:birch_log"=3} indicating two minecraft items with it's amount)
    --]]

    --    _                 _    __                  _   _
    --   | |               | |  / _|                | | (_)
    --   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
    --   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
    --   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
    --   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

    local self = {
        _host = host or "",
        _port = port or "",
        _path = path or {},
        _query = query or {},
    }

    local getScheme = function ()
        return "ccwprp" -- always the same
    end

    local getSchemeURI = function ()
        return getScheme().."://"
    end

    local getHost = function ()
        return self._host
    end

    local getHostURI = function ()
        return getHost()
    end

    local setHost = function (h)
        -- check input
        if type(h) ~= "string" then corelog.Error("url.setHost: invalid host type: "..type(h)) return end

        self._host = h
    end

    -- aUrl.setHostURI("storage")
    local setHostURI = function (hURI)
        -- check input
        if type(hURI) ~= "string" then corelog.Error("url.setHost: invalid host URI type: "..type(hURI)) return end

        local hostPattern = "%a+"
        setHost(string.gmatch(hURI, hostPattern)) -- in effect this should be the same as setHost(hURI)
    end

    local getPort = function ()
        return self._port
    end

    local getPortURI = function ()
        local portURI = getPort()
        if portURI ~= "" then
            portURI = ":"..portURI
        end
        return portURI
    end

    local setPort = function (p)
        -- check input
        if type(p) ~= "string" then corelog.Error("url.setPort: invalid port type: "..type(p)) return end

        self._port = p
    end

    -- aUrl.setPortURI(":1")
    local setPortURI = function (pURI)
        -- check input
        if type(pURI) ~= "string" then corelog.Error("url.setPortURI: invalid port URI type: "..type(pURI)) return end

        if pURI ~= "" then
            local portPattern = ":%d+"
            local i, j = string.find(pURI, portPattern)
            if i ~= nil then
                local p = string.sub(pURI, i+1, j)
                setPort(p)
            else
                corelog.Warning("url.setPortURI: invalid port URI value: "..pURI)
            end
        else
            corelog.WriteToLog("url.setPortURI: port URI value empty: "..pURI)
        end
    end

    local getAuthorityURI = function ()
        return getHostURI()..getPortURI()
    end

    local getPath = function ()
        return self._path
    end

    local getPathURI = function ()
        local pathURI = ""
        for key, value in pairs(getPath()) do
            pathURI = pathURI.."/"..key.."="..value
        end
        return pathURI
    end

    local setPath = function (p)
        -- check input
        if type(p) ~= "table" then corelog.Error("url.setPath: invalid path type: "..type(p)) return end

        self._path = p
    end

    -- aUrl.setPathURI("/site=3/inputChest=7")
    local setPathURI = function (pURI)
        -- check input
        if type(pURI) ~= "string" then corelog.Error("url.setPathURI: invalid path URI type: "..type(pURI)) return end

        local pathSegmentPattern = "%/(%a+)%=(%w+)"
        if pURI ~= "" then
            local p = {}
            for key, value in string.gmatch(pURI, pathSegmentPattern) do
                p[key] = value
            end
            setPath(p)
        else
            corelog.WriteToLog("url.setPathURI: path URI value empty: "..pURI)
        end
    end

    local getQuery = function ()
        return self._query
    end

    local getQueryURI = function ()
        local queryURI = ""
        local delimiter = "?"
        for key, value in pairs(getQuery()) do
            queryURI = queryURI..delimiter..key.."="..value
            delimiter = "&" 
        end
        return queryURI
    end

    local setQuery = function (q)
        -- check input
        if type(q) ~= "table" then corelog.Error("url.setQuery: invalid query type: "..type(q)) return end

        self._query = q
    end

    -- aUrl.setQueryURI("?minecraft:birch_log=3&minecraft:torch=5")
    local setQueryURI = function (qURI)
        -- check input
        if type(qURI) ~= "string" then corelog.Error("url.setQueryURI: invalid query URI type: "..type(qURI)) return end

        if qURI ~= "" then
            local q = {}
            -- first
            local mainPattern = "(%a+%:?%a+%_?%a+)%=(%w+)" -- %:? and %_? to allow for optional : and _ in e.g. "minecraft:birch_log"
            local firstQuerySegmentPattern = "%?"..mainPattern
            local key1, value1 = string.match(qURI, firstQuerySegmentPattern)
            q[key1] = value1
            -- second and higher
            local otherQuerySegmentPattern = "%&"..mainPattern
            for key, value in string.gmatch(qURI, otherQuerySegmentPattern) do
                q[key] = value
            end
            setQuery(q)
        else
            corelog.WriteToLog("url.setQueryURI: path URI value empty: "..qURI)
        end
    end

    local toURI = function ()
        return getSchemeURI()..getAuthorityURI()..getPathURI()..getQueryURI()
    end

    --                _     _ _         __                  _   _
    --               | |   | (_)       / _|                | | (_)
    --    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
    --   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
    --   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
    --   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
    --   | |
    --   |_|

    return {
        getScheme = getScheme,
        getSchemeURI = getSchemeURI,

        getHost = getHost,
        getHostURI = getHostURI,
        setHost = setHost,
        setHostURI = setHostURI,

        getPort = getPort,
        getPortURI = getPortURI,
        setPort = setPort,
        setPortURI = setPortURI,

        getAuthorityURI = getAuthorityURI,

        getPath = getPath,
        getPathURI = getPathURI,
        setPath = setPath,
        setPathURI = setPathURI,

        getQuery = getQuery,
        getQueryURI = getQueryURI,
        setQuery = setQuery,
        setQueryURI = setQueryURI,

        toURI = toURI,
    }
end

function NewFromURI(uri)
    local theURL = url.New()

    corelog.Error("url.NewFromURI: Not fully implemented yet") -- ToDo: try implement using the various patters above

    return theURL
end
