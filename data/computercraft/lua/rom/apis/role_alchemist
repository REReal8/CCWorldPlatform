-- the table that stores the data
local db = {
    job         = "alchemist",
}

function Craft_MetaData(craftData)
    --[[
       This function returns the metadata for the Craft_Task supplied with argument craftData.
   ]]

    -- check input
    if type(craftData) ~= "table" then corelog.Error("role_alchemist.Craft_MetaData: craftData not a valid") return {success = false} end
    if type(craftData.recipe) ~= "table" or type(craftData.recipe.yield) ~= "number" then corelog.Error("role_alchemist.Craft_MetaData: recipe not valid") return {success = false} end
    if type(craftData.itemCount) ~= "number" then corelog.Error("role_alchemist.Craft_MetaData: itemCount not valid") return {success = false} end
    if type(craftData.workingLocation) ~= "table" then corelog.Error("role_alchemist.Craft_MetaData: workingLocation not valid") return {success = false} end
 
    -- determine needed items
    local itemList = Craft_ItemsNeeded(craftData.recipe, craftData.itemCount)
    local workingLocation = craftData.workingLocation
    local currentLocation = coremove.GetLocation()-- ToDo: get this from outside somewhere? it assumed current turtle...
    local fuelNeeded = coreinventory.NeededFuelToFrom(currentLocation, workingLocation) + 5 -- some extra to correct for building from above or below

    -- return metadata
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(workingLocation),
        needTool = false,
        needTurtle = true,
        fuelNeeded = fuelNeeded,
        itemsNeeded = itemList
    }
end

function Craft_ItemsNeeded(recipe, itemCount)
    -- check input
    if type(recipe) ~= "table" or type(recipe.yield) ~= "number" then corelog.Error("role_alchemist.Craft_ItemsNeeded: recipe not valid") return {success = false} end
    if type(itemCount) ~= "number" then corelog.Error("role_alchemist.Craft_ItemsNeeded: itemCount not valid") return {success = false} end

    -- build item list
    local itemList = {}
    local yield = 1
    for k, ingredientInfo in pairs(recipe) do
        -- loop on only ingredients (skip yield)
        if type(ingredientInfo) == "table" then
            local itemName = ingredientInfo.itemName

            -- find item in itemlist (and increment counter if found)
            local itemAlreadyInList = false
            for j, item in ipairs(itemList) do
                -- right item?
                if item.itemName == itemName then
                    item.itemCount = item.itemCount + ingredientInfo.itemCount

                    itemAlreadyInList = true
                    break
                end
            end

            -- add new item to itemlist
            if not itemAlreadyInList then
                table.insert(itemList, {itemName = itemName, itemCount = ingredientInfo.itemCount})
            end
        elseif type(ingredientInfo) == "number" then
            yield = ingredientInfo
        end
    end

    -- correct for yield and itemCount
    for i, item in ipairs(itemList) do
        item.itemCount = item.itemCount * itemCount / yield
    end

    -- return itemList
--    corelog.WriteToLog("Craft_ItemsNeeded: itemList="..textutils.serialise(itemList))
    return itemList
end

function Craft_Task(craftData)
     --[[
        This Task function crafts items.

        Return value:
                                        - (table) {success = true} if the crafting was succesfull

        Parameters:
            craftData                   - (table) data about the crafting task
                recipe                  - (table) crafting recipe
                    yield               - (number) of items produced by recipe
                itemCount               - (number) of items to produce
                workingLocation         - (table) world location to do the crafting
                ingredientsLocation     - ToDo: consider if we need to keep this in the Task or do this at a higher level
    ]]

    -- check input
    if type(craftData) ~= "table" then corelog.Error("role_alchemist.Craft_Task: craftData not a valid") return {success = false} end
    if type(craftData.recipe) ~= "table" or type(craftData.recipe.yield) ~= "number" then corelog.Error("role_alchemist.Craft_Task: recipe not valid") return {success = false} end
    if type(craftData.itemCount) ~= "number" then corelog.Error("role_alchemist.Craft_Task: itemCount not valid") return {success = false} end
    if type(craftData.workingLocation) ~= "table" then corelog.Error("role_alchemist.Craft_Task: workingLocation not valid") return {success = false} end

    -- calculate how many times we need to "do" the recipe
    local crafting  = craftData.recipe
    local times     = math.ceil(craftData.itemCount / crafting.yield)

    -- only if we get an location, not needed when working from inventory
    -- ToDo: consider if we need to keep this at this level
    local ingredientsLocation  = craftData.ingredientsLocation
    if type(ingredientsLocation) == "table" then
        -- get above the ingredients location
        ingredientsLocation = coremove.GetRelativeLocationUp(ingredientsLocation)

        -- move to resource location
        coremove.GoTo(ingredientsLocation)

        -- suck everything from the box
        coreinventory.GetAllItems("Down")
    end

    -- move to the crafting location
    coremove.GoTo(craftData.workingLocation)

    -- do the magic!
    coreinventory.Equip("minecraft:crafting_table")
    PrepareCraftingArea(craftData.recipe, times)
    turtle.craft()

    -- take the stuff from the box below
    coreinventory.GetAllItems("down")

    -- only if we get a location
    -- ToDo: consider if we need to keep this at this level
    if type(ingredientsLocation) == "table" then

        -- move back to resource location
        coremove.GoTo(ingredientsLocation)

        -- dump the stuff
        coreinventory.DropAllItems("Down")
    end

    -- end
    return {success = true}
end

function Smelt_MetaData(smeltData)
    --[[
       This function returns the metadata for the Smelt_Task supplied with argument smeltData.
   ]]

    -- check input
    if type(smeltData) ~= "table" then corelog.Error("role_alchemist.Smelt_MetaData: craftData not a valid") return {success = false} end
    if type(smeltData.recipe) ~= "table" or type(smeltData.recipe.yield) ~= "number" then corelog.Error("role_alchemist.Smelt_MetaData: recipe not valid") return {success = false} end
    if type(smeltData.itemCount) ~= "number" then corelog.Error("role_alchemist.Smelt_MetaData: itemCount not valid") return {success = false} end
    if type(smeltData.workingLocation) ~= "table" then corelog.Error("role_alchemist.Smelt_MetaData: workingLocation not valid") return {success = false} end
    if type(smeltData.fuelItemName) ~= "string" then corelog.Error("role_alchemist.Smelt_MetaData: fuelItemName not valid") return {success = false} end
    if type(smeltData.fuelItemCount) ~= "number" then corelog.Error("role_alchemist.Smelt_MetaData: fuelItemCount not valid") return {success = false} end
 
    -- determine needed items
    local itemList = Smelt_ItemsNeeded(smeltData)
    local workingLocation = smeltData.workingLocation
    local currentLocation = coremove.GetLocation()-- ToDo: get this from outside somewhere? it assumed current turtle...
    local fuelNeeded = coreinventory.NeededFuelToFrom(currentLocation, workingLocation) + 5 -- some extra to correct for building from above or below

    -- return metadata
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(workingLocation),
        needTool = false,
        needTurtle = true,
        fuelNeeded = fuelNeeded,
        itemsNeeded = itemList
    }
end

function Smelt_ItemsNeeded(smeltData)
    -- check input
    if type(smeltData.recipe) ~= "table" or type(smeltData.recipe.yield) ~= "number" then corelog.Error("role_alchemist.Smelt_ItemsNeeded: recipe not valid") return {success = false} end
    if type(smeltData.itemCount) ~= "number" then corelog.Error("role_alchemist.Smelt_ItemsNeeded: itemCount not valid") return {success = false} end
    if type(smeltData.fuelItemName) ~= "string" then corelog.Error("role_alchemist.Smelt_ItemsNeeded: fuelItemName not valid") return {success = false} end
    if type(smeltData.fuelItemCount) ~= "number" then corelog.Error("role_alchemist.Smelt_ItemsNeeded: fuelItemCount not valid") return {success = false} end

    -- build item list
    local itemList = {
        { itemName = smeltData.recipe.itemName, itemCount = smeltData.itemCount / smeltData.recipe.yield }
    }
    if smeltData.fuelItemName == smeltData.recipe.itemName then
        itemList[0].itemCount = itemList[0].itemCount + smeltData.fuelItemCount
    else
        table.insert(itemList, {itemName = smeltData.fuelItemName, itemCount = smeltData.fuelItemCount})
    end

    -- return itemList
--    corelog.WriteToLog("Smelt_ItemsNeeded: itemList="..textutils.serialise(itemList))
    return itemList
end

function Smelt_Task(smeltData)
     --[[
        This Task function smelts items.

        Return value:
            task result                 - (table)      
                success                 - (boolean) whether the smelting was succesfull
                smeltingTime            - (number) the time it will take to complete the smelting (in seconds)

        Parameters:
            smeltData                   - (table) data about the smelting task
                recipe                  - (table) smelting recipe
                    itemName            - (string) name of item to produce
                    yield               - (number) of items produced by recipe
                itemCount               - (number) of items to produce
                workingLocation         - (table) world location to do the smelting (in front of the furnance)
                fuelItemName            - (string) name of fuel item to use
                fuelItemCount           - (number) of fuel items to use
    ]]
    -- check input
    if type(smeltData) ~= "table" then corelog.Error("role_alchemist.Smelt_Task: smeltData not a valid") return {success = false} end
    if type(smeltData.recipe) ~= "table" or type(smeltData.recipe.itemName) ~= "string" or type(smeltData.recipe.yield) ~= "number"then corelog.Error("role_alchemist.Smelt_Task: recipe not valid") return {success = false} end
    if type(smeltData.itemCount) ~= "number" then corelog.Error("role_alchemist.Smelt_Task: itemCount not valid") return {success = false} end
    if type(smeltData.workingLocation) ~= "table" then corelog.Error("role_alchemist.Smelt_Task: workingLocation not valid") return {success = false} end
    if type(smeltData.fuelItemName) ~= "string" then corelog.Error("role_alchemist.Smelt_Task: fuelItemName not valid") return {success = false} end

    -- prepare
    local times = math.ceil(smeltData.itemCount / smeltData.recipe.yield)

    -- go to the furnace
--    coremove.GoTo(smeltData.entryLocation) -- ToDo: do differently
    coremove.GoTo(smeltData.workingLocation)

    -- move on top of the furnace
    coremove.Up()
    coremove.Forward()

    -- fill furnace with it's ingredient
    coreinventory.SelectItem(smeltData.recipe.itemName)
    turtle.dropDown(times)

    -- move to the front of the furnace
    coremove.GoTo(smeltData.workingLocation)

    -- fill the furnace with fuel
    coreinventory.SelectItem(smeltData.fuelItemName)
    turtle.drop(smeltData.fuelItemCount)

    -- determine expected completion time
    local smeltingTime = 10 * times -- one smelting operation is sayed to take 10 seconds

    -- end
    return {success = true, smeltingTime = smeltingTime}
end

function Pickup_Task(pickupData)
    -- go to the furnace
--    coremove.GoTo(requestDetails.entryLocation) -- ToDo: do differently
    coremove.GoTo(pickupData.workingLocation)

    -- remove remaining fuel from furnace
    turtle.suck()

    -- move below the furnace
    coremove.Down()
    coremove.Forward()

    -- suck the results from furnace 
    turtle.suckUp()

    -- end
    return {success = true}
end

function SmeltAndPickup_Task(smeltData)
    --[[
       This Task function smelts items, waits for them to be completed and picks them up.

       Return value:
                                       - (table) {success = true} if the smelting & pickup was succesfull

       Parameters:
           smeltData                   - (table) data about the smelting task
               recipe                  - (table) smelting recipe
                   itemName            - (string) name of item to produce
                   yield               - (number) of items produced by recipe
               itemCount               - (number) of items to produce
               workingLocation         - (table) world location to do the smelting (in front of the furnance)
               fuelItemName            - (string) name of fuel item to use
               fuelItemCount           - (number) of fuel items to use
    ]]

    -- smelt
    local smeltResult = Smelt_Task(smeltData)
    if type(smeltResult) ~= "table" or smeltResult.success ~= true then
        corelog.Error("role_alchemist.SmeltAndPickup_Task: smelting not succesfull")
        return {success = false}
    end

    -- wait
    local smeltingTime = smeltResult.smeltingTime
    if type(smeltingTime) ~= "number" then
        corelog.Error("role_alchemist.SmeltAndPickup_Task: smelting did not return time needed to smelt")
        return {success = false}
    end
    os.sleep(smeltingTime)

    -- pickup
    Pickup_Task(smeltData)

    -- end
    return {success = true}
end


--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--
--

function PrepareCraftingArea(recipe, times)
     --[[
        This function prepares the crafting area within the turtle.

        Return value:
            nil

        Parameters:
            recipe                      - (table) crafting recipe
                yield                   - (number) of items produced by recipe
                key, value              - (table) multiple key-value-pairs of slot, ingredient information 
                    key = [slot]        - (number) of slot in turtle
                    value               - (table) information of ingredient to place in slot
                        itemName        - (string) name of ingredient item in slot
                        itemCount       - (number) of ingredients to place in slot
            times                       - (number) of times to apply the recipe
    ]]

    -- presume we can use the storage below us
    local craftArea = {false, false, false, false, false, true,  true,  true,  false, true,  true,  true,  false, true,  true,  true,  }
    local sideArea  = {true,  true,  true,  true,  true,  false, false, false, true,  false, false, false, true,  false, false, false, }

    -- drop stuff we don't need
    for slot=1,16 do

        -- what is in this slot?
        local itemDetail = coreinventory.GetItemDetail(slot)

        -- something in this slot and we don't need it?
        if itemDetail and not ItemInRecipe(itemDetail.name, recipe) then turtle.select(slot) turtle.dropDown() end
    end

    -- loop the crafting area
    for slot=1,16 do
        -- only for the crafting area
        if craftArea[slot] then

            -- something present here?
            local itemDetail = coreinventory.GetItemDetail(slot)
            if itemDetail then

                -- find a empty slot to store the stuff now in this slot
                local emptySlot = coreinventory.GetEmptySlot(sideArea)

                -- move all stuf from current slot to this slot
                turtle.select(slot)
                turtle.transferTo(emptySlot)
            end

            -- do we need stuff in this slot?
            if type(recipe[slot]) == "table" then
                -- find stuff that is needed here
                local itemName      =         recipe[slot].itemName
                local itemCount     = times * recipe[slot].itemCount
                local itemPresent   = turtle.getItemCount(slot)         -- slot is empty at this point

                -- go, find the stuff
                local itemSlot  = 1
                while itemCount > itemPresent and itemSlot <= 16 do

                    -- skip crafting spots allready prepared
                    if itemSlot > slot or sideArea[itemSlot] then

                        -- see what is in this slot
                        itemDetail = coreinventory.GetItemDetail(itemSlot)

                        -- usefull?
                        if type(itemDetail) == "table" and itemDetail.name == itemName then

                            -- great, transfer!
                            turtle.select(itemSlot)
                            turtle.transferTo(slot, itemCount - itemPresent)

                            -- how many in the slot right now?
                            itemPresent = turtle.getItemCount(slot)
                        end
                    end

                    -- don't forget to increase the slot
                    itemSlot = itemSlot + 1
                end
            end
        end
    end

    -- drop everything we don't need
    for slot=1,16 do

        -- this applies only to the side area (if something present)
        if sideArea[slot] and coreinventory.GetItemDetail(slot) then

            -- drop it!
            turtle.select(slot)
            turtle.dropDown()
        end
    end
end

function ItemInRecipe(itemName, recipe)
    -- loop all slots
    for slot=1,16 do if recipe[ slot ] and recipe[ slot ].itemName == itemName then return true end end

    -- not present
    return false
end
