-- the table that stores the data
local db = {
    job         = "alchemist",
}

function Craft_MetaData(craftData)
    --[[
       This function returns the metadata for the Craft_Task supplies with argument craftData.
   ]]

    -- check input
    if type(craftData) ~= "table" then corelog.Error("role_alchemist.Craft_MetaData: craftData not a valid") return {success = false} end
    if type(craftData.recipe) ~= "table" or type(craftData.recipe.yield) ~= "number" then corelog.Error("role_alchemist.Craft_MetaData: recipe not valid") return {success = false} end
    if type(craftData.itemCount) ~= "number" then corelog.Error("role_alchemist.Craft_MetaData: itemCount not valid") return {success = false} end
    if type(craftData.workingLocation) ~= "table" then corelog.Error("role_alchemist.Craft_MetaData: workingLocation not valid") return {success = false} end
 
    -- determine needed items
    local itemList = Craft_ItemsNeeded(craftData.recipe, craftData.itemCount)
    local workingLocation = craftData.workingLocation
    local currentLocation = coremove.GetLocation()-- ToDo: get this from outside somewhere? it assumed current turtle...
    local fuelNeeded = coreinventory.NeededFuelToFrom(currentLocation, workingLocation) + 5 -- some extra to correct for building from above or below

    -- return metadata
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(workingLocation),
        needTool = false,
        needTurtle = true,
        fuelNeeded = fuelNeeded,
        itemsNeeded = itemList
    }
end

function Craft_ItemsNeeded(recipe, itemCount)
    -- check input
    if type(recipe) ~= "table" or type(recipe.yield) ~= "number" then corelog.Error("role_alchemist.Craft_ItemsNeeded: recipe not valid") return {success = false} end
    if type(itemCount) ~= "number" then corelog.Error("role_alchemist.Craft_ItemsNeeded: itemCount not valid") return {success = false} end

    -- build item list
    local itemList = {}
    local yield = 1
    for k, ingredientInfo in pairs(recipe) do
        -- loop on only ingredients (skip yield)
        if type(ingredientInfo) == "table" then
            local itemName = ingredientInfo.itemName

            -- find item in itemlist (and increment counter if found)
            local itemAlreadyInList = false
            for j, item in ipairs(itemList) do
                -- right item?
                if item.itemName == itemName then
                    item.itemCount = item.itemCount + ingredientInfo.itemCount

                    itemAlreadyInList = true
                    break
                end
            end

            -- add new item to itemlist
            if not itemAlreadyInList then
                table.insert(itemList, {itemName = itemName, itemCount = ingredientInfo.itemCount})
            end
        elseif type(ingredientInfo) == "number" then
            yield = ingredientInfo
        end
    end

    -- correct for yield and itemCount
    for i, item in ipairs(itemList) do
        item.itemCount = item.itemCount * itemCount / yield
    end

    -- return itemList
--    corelog.WriteToLog("Craft_ItemsNeeded: itemList="..textutils.serialise(itemList))
    return itemList
end

function Craft_Task(craftData)
     --[[
        This Task function crafts items.

        Return value:
                                        - (table) {success = true} if the crafting was succesfull

        Parameters:
            craftData                   - (table) data about the crafting task
                recipe                  - (table) crafting recipe
                    yield               - (number) of items produced by recipe
                itemCount               - (number) of items to produce
                workingLocation         - (table) world location to do the crafting
                ingredientsLocation     - ToDo: consider if we need to keep this in the Task or do this at a higher level
    ]]

    -- check input
    if type(craftData) ~= "table" then corelog.Error("role_alchemist.Craft_Task: craftData not a valid") return {success = false} end
    if type(craftData.recipe) ~= "table" or type(craftData.recipe.yield) ~= "number" then corelog.Error("role_alchemist.Craft_Task: recipe not valid") return {success = false} end
    if type(craftData.itemCount) ~= "number" then corelog.Error("role_alchemist.Craft_Task: itemCount not valid") return {success = false} end
    if type(craftData.workingLocation) ~= "table" then corelog.Error("role_alchemist.Craft_Task: workingLocation not valid") return {success = false} end

    -- calculate how many times we need to "do" the recipe
    local crafting  = craftData.recipe
    local times     = math.ceil(craftData.itemCount / crafting.yield)

    -- only if we get an location, not needed when working from inventory
    -- ToDo: consider if we need to keep this at this level
    local ingredientsLocation  = craftData.ingredientsLocation
    if type(ingredientsLocation) == "table" then
        -- get above the ingredients location
        ingredientsLocation = coremove.GetRelativeLocationUp(ingredientsLocation)

        -- move to resource location
        coremove.GoTo(ingredientsLocation)

        -- suck everything from the box
        coreinventory.GetAllItems("Down")
    end

    -- move to the crafting location
    coremove.GoTo(craftData.workingLocation)

    -- do the magic!
    coreinventory.Equip("minecraft:crafting_table")
    PrepareCraftingArea(craftData.recipe, times)
    turtle.craft()

    -- take the stuff from the box below
    coreinventory.GetAllItems("down")

    -- only if we get a location
    -- ToDo: consider if we need to keep this at this level
    if type(ingredientsLocation) == "table" then

        -- move back to resource location
        coremove.GoTo(ingredientsLocation)

        -- dump the stuff
        coreinventory.DropAllItems("Down")
    end

    return {success = true}
end

function Smelt(requestDetails)
    -- prepare
    local times     = math.ceil(requestDetails.itemCount / requestDetails.recipe.yield)

    -- go to the furnace
    coremove.GoTo(requestDetails.entryLocation)
    coremove.GoTo(coremove.GetRelativeLocation(requestDetails.workingLocation, 0, 0, 1))

    -- move on top of the furnace
    coremove.Forward()

    -- fill furnace with it's ingredient
    coreinventory.SelectItem(requestDetails.recipe.ingredient)
    turtle.dropDown(times)

    -- move to the front of the furnace
    coremove.GoTo(requestDetails.workingLocation)

    -- fill the furnace with fuel
    coreinventory.SelectItem(requestDetails.fuel)
    turtle.drop(1)
end

function Pickup(requestDetails)
    -- go to the furnace
    coremove.GoTo(requestDetails.entryLocation)
    coremove.GoTo(coremove.GetRelativeLocation(requestDetails.workingLocation, 0, 0, -1))

    -- move below the furnace
    coremove.Forward()

    -- suck the furnace empty
    turtle.suckUp()
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--
--

function PrepareCraftingArea(recipe, times)
     --[[
        This function (?prepares) the crafting area. ... ToDo: or does it actually do it?

        Return value:
            nil

        Parameters:
            recipe                      - (table) crafting recipe
                yield                   - (number) of items produced by recipe
                key, value              - (table) multiple key-value-pairs of slot, ingredient information 
                    key = [slot]        - (number) of slot in turtle
                    value               - (table) information of ingredient to place in slot
                        itemName        - (string) name of ingredient item in slot
                        itemCount       - (number) of ingredients to place in slot
            times                       - (number) of times to apply the recipe
    ]]

    -- presume we can use the storage below us
    local craftArea = {false, false, false, false, false, true,  true,  true,  false, true,  true,  true,  false, true,  true,  true,  }
    local sideArea  = {true,  true,  true,  true,  true,  false, false, false, true,  false, false, false, true,  false, false, false, }

    -- drop stuff we don't need
    for slot=1,16 do

        -- what is in this slot?
        local itemDetail = coreinventory.GetItemDetail(slot)

        -- something in this slot and we don't need it?
        if itemDetail and not ItemInRecipe(itemDetail.name, recipe) then turtle.select(slot) turtle.dropDown() end
    end

    -- loop the crafting area
    for slot=1,16 do
        -- only for the crafting area
        if craftArea[slot] then

            -- something present here?
            local itemDetail = coreinventory.GetItemDetail(slot)
            if itemDetail then

                -- find a empty slot to store the stuff now in this slot
                local emptySlot = coreinventory.GetEmptySlot(sideArea)

                -- move all stuf from current slot to this slot
                turtle.select(slot)
                turtle.transferTo(emptySlot)
            end

            -- do we need stuff in this slot?
            if type(recipe[slot]) == "table" then
                -- find stuff that is needed here
                local itemName      =         recipe[slot].itemName
                local itemCount     = times * recipe[slot].itemCount
                local itemPresent   = turtle.getItemCount(slot)         -- slot is empty at this point

                -- go, find the stuff
                local itemSlot  = 1
                while itemCount > itemPresent and itemSlot <= 16 do

                    -- skip crafting spots allready prepared
                    if itemSlot > slot or sideArea[itemSlot] then

                        -- see what is in this slot
                        itemDetail = coreinventory.GetItemDetail(itemSlot)

                        -- usefull?
                        if type(itemDetail) == "table" and itemDetail.name == itemName then

                            -- great, transfer!
                            turtle.select(itemSlot)
                            turtle.transferTo(slot, itemCount - itemPresent)

                            -- how many in the slot right now?
                            itemPresent = turtle.getItemCount(slot)
                        end
                    end

                    -- don't forget to increase the slot
                    itemSlot = itemSlot + 1
                end
            end
        end
    end

    -- drop everything we don't need
    for slot=1,16 do

        -- this applies only to the side area (if something present)
        if sideArea[slot] and coreinventory.GetItemDetail(slot) then

            -- drop it!
            turtle.select(slot)
            turtle.dropDown()
        end
    end
end

function ItemInRecipe(itemName, recipe)
    -- loop all slots
    for slot=1,16 do if recipe[ slot ] and recipe[ slot ].itemName == itemName then return true end end

    -- not present
    return false
end
