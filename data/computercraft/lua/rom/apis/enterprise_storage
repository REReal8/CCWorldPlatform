local db = {
    dhtRoot     = "enterprise_storage",
    dhtSites    = "sites",
}

--[[
    dht = {
        enterprise_storage = {
            sites = {
                {
                    type = "silo",
                    entryLocation = {location-table},
                    topLocation = {location-table},
                    topChests = {
                        { status = "free|used", location = {location-table} },
                        { status = "free|used", location = {location-table} },
                    },
                    storageChests = {
                        { status = "free|used", itemName = nil|"minecraft:charcoal",  actual = 14, virtual = 18, stackSize = 64 },
                        { status = "free|used", itemName = nil|"minecraft:birch_log", actual = 14, virtual = 18, stackSize = 64 },
                    },
                },
            },
            statistics = {},
        }
    }
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

-- print(textutils.serialize(enterprise_storage.StoreItems({{itemName="minecraft:charcoal", itemCount=12, stackSize="64"}}, {x=0, y=0, z= 1, dx=0, dy=1})))
function StoreItems(itemList, location)
--[[
    This public function is for storing items. It does not care if there is space, all items are accepted

    Return value:
        location where to drop the items

    Parameters:
        itemList - (table) list of items (name and count) to be stored
        location - (table) location where the items are now, to search of a nearby site
--]]

    -- check our input
    if type(itemList) ~= "table" then coreutils.Error('enterprise_storage.StoreItems: Invalid input') return nil end

    -- this site is best
    local site  = FindClosestSite(location)
    if site == nil then coreutils.Error('enterprise_storage.StoreItems: No valid site') return nil end

    -- let the site handle this request
    if site.type == "silo" then return enterprise_storage_silo.StoreItems(site, itemList)
    end
end

-- enterprise_storage.ItemsDelivered({}, {y = 17,x = 14,z = 1,dx = 0,dy = 1,})
function ItemsDelivered(itemList, location)
--[[
    This public function notifies the storage enterprise that items have been delivered

    Return value:
        nil

    Parameters:
        itemList - (table) list of items (name and count) to be stored (ignored btw, maybe used later)
        location - (table) location of the items
--]]

    -- check our input
    if type(itemList) ~= "table" or type(location) ~= "table" then coreutils.Error('enterprise_storage.ItemsDelivered: Invalid input') return nil end

    -- find the site this top chest location belongs to
    local site, topChest = FindSiteByTopChest(location)

    -- got anything?
    if site == nil or topChest == nil then coreutils.Error('enterprise_storage.ItemsDelivered: No site found') return nil end

    -- what kind of site is this anyways?
    if site.type == "silo" then return enterprise_storage_silo.ItemsDelivered(site.sitesIndex, topChest.chestIndex, itemList, location)
    end
end

function RetrieveItems(itemList, callback)
--[[
    This public function is retrieving items from the storage. When the requested items are not
        all present, the function will return nil and no action will follow

    Return value:
        location where to drop the items

    Parameters:
        itemList - (table) list of items (name and count) to be stored
        callback - (string) function name to call once the items are ready for pickup
--]]
end

function ItemsCollected(itemList, location)
--[[
    This public function notifies the storage enterprise that the items have been collected

    Return value:
        nil

    Parameters:
        itemList - (table) list of items (name and count) collected (must be all of it)
        location - (table) location of the items
--]]
end

function ItemPresent(itemName)
--[[
    This public function counts how many of an item is present in the system. Unknown items return 0 (not nil)

    Return value:
        integer how many of that item is present in the storage system

    Parameters:
        itemName - (string) name of the item to be counted
--]]
end

-- enterprise_storage.NewSite({location={x=12, y=12, z= 1, dx=0, dy=1}, type="silo", siloType="basic", topChests=2, layers=2})
function NewSite(siteData)
--[[
    This public function to notify the (enterprise) storage that a new site is ready for use

    Return value:
        nil

    Parameters:
        siteData - (table) data about this site, like type and layout
--]]

    -- just check if our enterprise has a key in the dht
    if coredht.GetData(db.dhtRoot) == nil then

        -- create the entry
        coredht.SaveData({}, db.dhtRoot)
        coredht.SaveData({}, db.dhtRoot, db.dhtSites)
    end

    -- check our input
    if type(siteData) ~= "table" or type(siteData.location) ~= "table" or type(siteData.type) ~= "string" then coreutils.Error('enterprise_storage.NewSite: Invalid input') return nil end

    -- what kind of storage is this?
    if siteData.type == 'silo' then return enterprise_storage_silo.NewSite(siteData)
    end
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function FindClosestSite(location)
    -- sites ophalen
    local sites = coredht.GetData(db.dhtRoot, db.dhtSites)

    -- check if we have any site
    if type(sites) ~= "table" or #sites == 0 then coreutils.Error('enterprise_storage.FindClosestSite: no sites present') return nil end

    -- we should look for the best site, for now just take the first
    return sites[1]
end

function FindSiteByTopChest(location)
    -- sites ophalen
    local sites = coredht.GetData(db.dhtRoot, db.dhtSites)

    -- loop the sites
    for i, site in ipairs(sites) do

        -- this one?
        local topChest    = nil

        -- let the type determine how this is managed
        if site.type == "silo" then topChest = enterprise_storage_silo.FindSiteByTopChest(site, location)
        end

        -- do we have anything?
        if site ~= nil then return site, topChest end
    end

    -- found nothing
    return nil, nil
end

--    _           _ _     _               _   _                                 _     _                       _       _
--   | |         (_) |   | |             | | | |                        ___    | |   | |                     (_)     | |
--   | |__  _   _ _| | __| |  _ __   __ _| |_| |_ ___ _ __ _ __  ___   ( _ )   | |__ | |_   _  ___ _ __  _ __ _ _ __ | |_ ___
--   | '_ \| | | | | |/ _` | | '_ \ / _` | __| __/ _ \ '__| '_ \/ __|  / _ \/\ | '_ \| | | | |/ _ \ '_ \| '__| | '_ \| __/ __|
--   | |_) | |_| | | | (_| | | |_) | (_| | |_| ||  __/ |  | | | \__ \ | (_>  < | |_) | | |_| |  __/ |_) | |  | | | | | |_\__ \
--   |_.__/ \__,_|_|_|\__,_| | .__/ \__,_|\__|\__\___|_|  |_| |_|___/  \___/\/ |_.__/|_|\__,_|\___| .__/|_|  |_|_| |_|\__|___/
--                           | |                                                                  | |
--                           |_|                                                                  |_|

topLayerL0_pattern = {
    deltaX      = 6,
    deltaY      = 6,
    objectList  = {
        { x = 0, y = 3,                 block = "minecraft:torch"},
        { x = 2, y = 5, dx = 0, dy = 1, block = "minecraft:chest"},
        { x = 3, y = 0,                 block = "minecraft:torch"},
        { x = 4, y = 5, dx = 0, dy = 1, block = "minecraft:chest"},
    },
    clearRemainingSpace = true,
}

shaftLayer_pattern = {
    deltaX      = 1,
    deltaY      = 1,
    objectList  = {
    },
    clearRemainingSpace = true,
}

chestLayer_pattern = {
    deltaX      = 3,
    deltaY      = 3,
    objectList  = {
        { x = 0, y = 0, dx =-1, dy = 0, block = "minecraft:chest"},
        { x = 0, y = 1, dx =-1, dy = 0, block = "minecraft:chest"},

        { x = 0, y = 2, dx = 0, dy = 1, block = "minecraft:chest"},
        { x = 1, y = 2, dx = 0, dy = 1, block = "minecraft:chest"},

        { x = 1, y = 0, dx = 0, dy =-1, block = "minecraft:chest"},
        { x = 2, y = 0, dx = 0, dy =-1, block = "minecraft:chest"},

        { x = 2, y = 1, dx = 1, dy = 0, block = "minecraft:chest"},
        { x = 2, y = 2, dx = 1, dy = 0, block = "minecraft:chest"},
    },
    clearRemainingSpace = true,
}

-- ToDo: later wrap this within enterprise_storage (or role_silo_worker) such that this data can become private
function GetSiloL0_blueprint()
    return {
        layerList = {
            { startpoint = { x= 0, y= 0, z=  0}, buildFromAbove  = true, pattern = enterprise_storage.topLayerL0_pattern},
            { startpoint = { x= 3, y= 3, z= -1}, buildFromAbove  = false, pattern = enterprise_storage.shaftLayer_pattern},
            { startpoint = { x= 2, y= 2, z= -2}, buildFromAbove  = false, pattern = enterprise_storage.chestLayer_pattern},
            { startpoint = { x= 2, y= 2, z= -3}, buildFromAbove  = false, pattern = role_builder.CopyPattern(enterprise_storage.chestLayer_pattern)}
        },
        escapeSequence = {
            { x= 3, y= 3, z=  1},
        }
    }
end

