local db = {
    dhtRoot     = "enterprise_storage",
    dhtSites    = "sites",
}

--[[
    dht = {
        enterprise_storage = {
            sites = {
                {
                    type = "silo",
                    entryLocation = {location-table},
                    topLocation = {location-table},
                    topChests = {
                        { status = "free|used", location = {location-table} },
                        { status = "free|used", location = {location-table} },
                    },
                    storageChests = {
                        { status = "free|used", itemName = nil|"minecraft:charcoal",  actual = 14, virtual = 18, stackSize = 64 },
                        { status = "free|used", itemName = nil|"minecraft:birch_log", actual = 14, virtual = 18, stackSize = 64 },
                    },
                },
            },
            statistics = {},
        }
    }
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function StoreItems(itemList)
--[[
    This public function is for storing items. It does not care if there is space, all items are accepted

    Return value:
        location where to drop the items

    Parameters:
        itemList - (table) list of items (name and count) to be stored
--]]
end

function ItemsDelivered(itemList, location)
--[[
    This public function notifies the storage enterprise that items have been delivered

    Return value:
        nil

    Parameters:
        itemList - (table) list of items (name and count) to be stored
        location - (table) location of the items
--]]
end

function RetrieveItems(itemList, callback)
--[[
    This public function is retrieving items from the storage. When the requested items are not
        all present, the function will return nil and no action will follow

    Return value:
        location where to drop the items

    Parameters:
        itemList - (table) list of items (name and count) to be stored
        callback - (string) function name to call once the items are ready for pickup
--]]
end

function ItemsCollected(itemList, location)
--[[
    This public function notifies the storage enterprise that the items have been collected

    Return value:
        nil

    Parameters:
        itemList - (table) list of items (name and count) collected (must be all of it)
        location - (table) location of the items
--]]
end

function ItemPresent(itemName)
--[[
    This public function counts how many of an item is present in the system. Unknown items return 0 (not nil)

    Return value:
        integer how many of that item is present in the storage system

    Parameters:
        itemName - (string) name of the item to be counted
--]]
end

-- enterprise_storage.NewSite({location={x=12, y=12, z= 1, dx=0, dy=1}, type="silo", siloType="basic", topChests=2, layers=2})

function NewSite(siteData)
--[[
    This public function to notify the storage that a new site is ready for use

    Return value:
        nil

    Parameters:
        siteData - (table) data about this site, like type and layout
--]]

    -- check our input
    if  type(siteData) ~= "table" or type(siteData.location) ~= "table" or type(siteData.type) ~= "string" then coreutils.Error('enterprise_storage.NewSite: Invalid input') return nil end

    -- what kind of storage is this?
    if siteData.type == 'silo' then return enterprise_storage_silo.NewSite(siteData)
    end
end

--    _           _ _     _               _   _                                 _     _                       _       _
--   | |         (_) |   | |             | | | |                        ___    | |   | |                     (_)     | |
--   | |__  _   _ _| | __| |  _ __   __ _| |_| |_ ___ _ __ _ __  ___   ( _ )   | |__ | |_   _  ___ _ __  _ __ _ _ __ | |_ ___
--   | '_ \| | | | | |/ _` | | '_ \ / _` | __| __/ _ \ '__| '_ \/ __|  / _ \/\ | '_ \| | | | |/ _ \ '_ \| '__| | '_ \| __/ __|
--   | |_) | |_| | | | (_| | | |_) | (_| | |_| ||  __/ |  | | | \__ \ | (_>  < | |_) | | |_| |  __/ |_) | |  | | | | | |_\__ \
--   |_.__/ \__,_|_|_|\__,_| | .__/ \__,_|\__|\__\___|_|  |_| |_|___/  \___/\/ |_.__/|_|\__,_|\___| .__/|_|  |_|_| |_|\__|___/
--                           | |                                                                  | |
--                           |_|                                                                  |_|

topLayerL0_pattern = {
    deltaX      = 6,
    deltaY      = 6,
    objectList  = {
        { x = 0, y = 3,                 block = "minecraft:torch"},
        { x = 2, y = 5, dx = 0, dy = 1, block = "minecraft:chest"},
        { x = 3, y = 0,                 block = "minecraft:torch"},
        { x = 4, y = 5, dx = 0, dy = 1, block = "minecraft:chest"},
    },
    clearRemainingSpace = true,
}

shaftLayer_pattern = {
    deltaX      = 1,
    deltaY      = 1,
    objectList  = {
    },
    clearRemainingSpace = true,
}

chestLayer_pattern = {
    deltaX      = 3,
    deltaY      = 3,
    objectList  = {
        { x = 0, y = 0, dx =-1, dy = 0, block = "minecraft:chest"},
        { x = 0, y = 1, dx =-1, dy = 0, block = "minecraft:chest"},

        { x = 0, y = 2, dx = 0, dy = 1, block = "minecraft:chest"},
        { x = 1, y = 2, dx = 0, dy = 1, block = "minecraft:chest"},

        { x = 1, y = 0, dx = 0, dy =-1, block = "minecraft:chest"},
        { x = 2, y = 0, dx = 0, dy =-1, block = "minecraft:chest"},

        { x = 2, y = 1, dx = 1, dy = 0, block = "minecraft:chest"},
        { x = 2, y = 2, dx = 1, dy = 0, block = "minecraft:chest"},
    },
    clearRemainingSpace = true,
}

-- ToDo: later wrap this within enterprise_storage (or role_silo_worker) such that this data can become private
function GetSiloL0_blueprint()
    return {
        layerList = {
            { startpoint = { x= 0, y= 0, z=  0}, buildFromAbove  = true, pattern = enterprise_storage.topLayerL0_pattern},
            { startpoint = { x= 3, y= 3, z= -1}, buildFromAbove  = false, pattern = enterprise_storage.shaftLayer_pattern},
            { startpoint = { x= 2, y= 2, z= -2}, buildFromAbove  = false, pattern = enterprise_storage.chestLayer_pattern},
            { startpoint = { x= 2, y= 2, z= -3}, buildFromAbove  = false, pattern = role_builder.CopyPattern(enterprise_storage.chestLayer_pattern)}
        },
        escapeSequence = {
            { x= 3, y= 3, z=  1},
        }
    }
end

