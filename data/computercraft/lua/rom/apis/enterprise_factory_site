local db = {
    dhtRoot     = "enterprise_factory",
    dhtSites    = "sites",
}

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function StartNewSite(siteStartData)
    --[[
        This function should make the site available for production.

        Return value:
                                    - (string) the id of the new production site

        Parameters:
            siteStartData           - (table) data about the site to start, 
                version             - (string) version string of the site
                baseLocation        - (table) world location of the base (lower left corner) of this site
                inputLocators       - (table) with inputLocator's of this site
                outputLocators      - (table) with outputLocator's of this site
                craftingSpots       - (table) craftingSpots of this site
                    location        - (table) location of spot
                smeltingSpots       - (table) craftingSpots of this site
                    location        - (table) location of spot
    ]]

    -- variables
    local site = {
        version         = siteStartData.version,
        siteId          = coreutils.NewId(), -- ToDo consider using an internal (to the factory) counter. This might make use in an URL easier.

        baseLocation    = siteStartData.baseLocation,
--        entryLocation   = coremove.GetRelativeLocation(siteData.location, 3, 3, 1), -- ToDo: consider adding and using (before moving to workingLocation)

        inputLocators   = siteStartData.inputLocators,
        outputLocators  = siteStartData.outputLocators,

        craftingSpots   =  siteStartData.craftingSpots,
        smeltingSpots   =  siteStartData.smeltingSpots,
    }

    -- ToDo: initialise possible other data (like e.g. open for business, availability of spots)

    -- save the new site to our sites
    coredht.SaveData(site, db.dhtRoot, db.dhtSites, site.siteId)

    -- end
    return site.siteId
end

function StopSite_ASrv(siteData, callback, callbackData)
    --[[
        This async public function stops a factory site. Stopping implies
          - the site is immediatly no longer available for new business
          - wait for all active work (production) on site to be ended
          - remove the site from the factory 

        Return value:
            nil 

        Async immediatly return value (to callback):
                                - (table)
                success         - (boolean) when the site was succesfully stopped

        Parameters:
            siteData            - (table) data about the site
                baseLocation    - (table) world location of the base (lower left corner) of the site
                siteVersion     - (string) version string of the site
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function
    ]]

    -- check input
    if type(siteData) ~= "table" or type(siteData.siteVersion) ~= "string" or type(siteData.baseLocation) ~= "table" then
        corelog.Error('enterprise_factory_site.StopSite_ASrv: Invalid siteData input')
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    if type(callback) ~= "string" then 
        corelog.Error('enterprise_factory_site.StopSite_ASrv: Invalid callback function')
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    callbackData = callbackData or {}

    -- find the site
    local site = FindSiteBySiteData(siteData)
    if type(site) ~="table" then
        corelog.Error("enterprise_factory_site.StopSite_ASrv: Failed retrieving factory site for siteData = "..textutils.serialise(siteData))
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end

    -- stop doing business for this site
    -- ToDo: implement

    -- wait for active work done
    -- ToDo: implement

    -- remove site from factory
    corelog.WriteToLog('  enterprise_factory_site.StopSite_ASrv: Removing site '..site.siteId)
    coredht.SaveData(nil, db.dhtRoot, db.dhtSites, site.siteId)

    -- do callback
    coreutils.DoCallback(callback, callbackData, {success = true})
end

function GetAvailableSiteData(recipe, productItemCount)
    --[[
        This public method finds and selects a suitable factory site for producing items from a recipe.

        Return value:
                siteProduceItemData     - (table) (partial) productionData to produce item

        Parameters:
            recipe                      - (table) item base recipe (including possibly both a crafting as smelting recipe)
            productItemCount            - (number) amount of items to produce
    ]]

    -- check input
    if type(recipe) ~= "table" then corelog.Error("enterprise_factory.GetAvailableSiteData: Invalid recipe") return nil end
    if type(productItemCount) ~= "number" then corelog.Error("enterprise_factory.GetAvailableSiteData: Invalid productItemCount") return nil end

    -- sites ophalen
    local sites = coredht.GetData(db.dhtRoot, db.dhtSites)
    if type(sites) ~= "table" then corelog.Warning("enterprise_factory.GetAvailableSiteData: no sites present") return nil end

    -- ..
    local craftRecipe = recipe.crafting
    local smeltRecipe = recipe.smelting

    -- find available sites
    local availableSitesInfo = {
    }
    for k, site in pairs(sites) do
        -- check
        if type(site) ~="table" then corelog.Error("enterprise_factory_site.GetAvailableSiteData: Invalid site") return nil end
        local siteId = site.siteId
        if type(siteId) ~="string" then corelog.Error("enterprise_factory_site.GetAvailableSiteData: Invalid siteId") return nil end

        -- get available inputLocator
        local inputLocator = url.URLClass:new(GetAvailableLocator(site.inputLocators))
        if inputLocator == nil then
            corelog.Warning("enterprise_factory_site.GetAvailableSiteData: No available inputLocator in site "..siteId)
        else
            -- get available outputLocator
            local outputLocator = url.URLClass:new(GetAvailableLocator(site.outputLocators))
            if outputLocator == nil then
                corelog.Warning("enterprise_factory_site.GetAvailableSiteData: No available outputLocator in site "..siteId)
            else
                -- check it can craft recipe
                if craftRecipe ~= nil then
                    -- ToDo: implement production of more items than fitting a single spot
                    local craftSpot = GetAvailableCraftSpot(site)
                    if craftSpot ~= nil then
                        table.insert(availableSitesInfo, {
                            localInputLocator   = inputLocator:copy(),
                            localOutputLocator  = outputLocator:copy(),
                            productionSpot      = coreutils.DeepCopy(craftSpot),
                            productionMethod    = "craft",
                            productionRecipe    = coreutils.DeepCopy(craftRecipe),
                        })
                    else
                        corelog.Warning("enterprise_factory_site.GetAvailableSiteData: No available crafting spot in site "..siteId)
                    end
                end

                -- check it can smelt recipe
                if smeltRecipe ~= nil then
                    local smeltSpot = GetAvailableSmeltSpot(site)
                    if smeltSpot ~= nil then
                        table.insert(availableSitesInfo, {
                            localInputLocator   = inputLocator:copy(),
                            localOutputLocator  = outputLocator:copy(),
                            productionSpot      = coreutils.DeepCopy(smeltSpot),
                            productionMethod    = "smelt",
                            productionRecipe    = coreutils.DeepCopy(smeltRecipe),
                        })
                    else
                        corelog.Warning("enterprise_factory_site.GetAvailableSiteData: No available smelting spot in site "..siteId)
                    end
                end
            end
        end
    end

    -- select best site
    local selectedProduceItemData = nil
    for i, siteProduceItemData in ipairs(availableSitesInfo) do
        -- for now take first
        selectedProduceItemData = siteProduceItemData
        break
        -- ToDo: consider finding best site based on some selection criterium 
    end
    if selectedProduceItemData == nil then corelog.Warning("enterprise_factory.GetAvailableSiteData: no site available") return nil end

    -- mark productionSpot as unavailable
    -- ToDo: implement (not yet needed in current settle scenario where there is only one turtle)
    -- ToDo: consider to what extend this is also needed for localInputLocator and localOutputLocator

    -- enhance with itemsNeeded
    local productionMethod = selectedProduceItemData.productionMethod
    local productionRecipe = selectedProduceItemData.productionRecipe
    if productionMethod == "craft" then
        selectedProduceItemData.itemsNeeded = coreutils.DeepCopy(role_alchemist.Craft_ItemsNeeded(productionRecipe, productItemCount))
    elseif productionMethod == "smelt" then
        -- determine production fuel
        -- ToDo: do this differently
        local fuelItemName  = "minecraft:birch_planks"
        local fuelItemCount = productItemCount

        selectedProduceItemData.itemsNeeded = coreutils.DeepCopy(role_alchemist.Smelt_ItemsNeeded(productionRecipe, productItemCount, fuelItemName, fuelItemCount))
    else corelog.Error("enterprise_factory_site.GetAvailableSiteData: Production with method "..productionMethod.." not implemented.") return nil end

    -- end
    return selectedProduceItemData
end

function ProduceItem_ASrv(serviceData, callback, callbackData)
    --[[
        This async public service produces multiple instances of a specific item in a factory site. It does so by producing 
        the requested amount of items with the supplied production method (i.e. crafting or smelting). 

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed correctly
                localOutputItemsLocator - (URL) locating the items that where produced
                                            (upon service succes the "host" component of this URL should be equal to localOutputLocator, and
                                            the "query" should be equal to the "query" component of the localInputItemLocator)

        Parameters:
            serviceData                 - (table) data for the service
                localInputItemsLocator  - (URL) locating where the production ingredients can be retrieved locally "within" the site (e.g. an input chest)
                localOutputLocator      - (URL) locating where the produced items need to be delivered locally "within" the site (e.g. an output chest)
                productionMethod        - (string) production method to use
                productionSpot          - (table) location of production spot
                productItemName         - (string) name of item to produce
                productItemCount        - (number) amount of items to produce
                productionRecipe        - (table) production recipe
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local localInputItemsLocator = url.URLClass:new(serviceData.localInputItemsLocator)
    if type(localInputItemsLocator) ~= "table" then corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Invalid localInputItemsLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local localOutputLocator = url.URLClass:new(serviceData.localOutputLocator)
    if type(localOutputLocator) ~= "table" then corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Invalid localOutputLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productionMethod = serviceData.productionMethod
    if type(productionMethod) ~= "string" then corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Invalid productionMethod") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productionSpot = serviceData.productionSpot
    if type(productionSpot) ~= "table" then corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Invalid productionSpot") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productItemName = serviceData.productItemName
    if type(productItemName) ~= "string" then corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Invalid productItemName") return {success = false} end
    local productItemCount = serviceData.productItemCount
    if type(productItemCount) ~= "number" then corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Invalid productItemCount") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productionRecipe = serviceData.productionRecipe
    if type(productionRecipe) ~= "table" then corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Invalid productionRecipe") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- determine turtleInputLocator
    local turtleInputLocator = enterprise_turtle.GetHostLocator_SSrv({ }).hostLocator

    -- determine production service
    local productionServiceName = nil
    if productionMethod == "craft" then
        productionServiceName = "enterprise_factory_site.CraftItem_ASrv"
    elseif productionMethod == "smelt" then
        productionServiceName = "enterprise_factory_site.SmeltItemAndPickup_ASrv"
        -- ToDo: consider splitting smelting from pickup in a later version. Possibly by using URL's referencing the pickup location (and time?)
    else corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Production with method "..productionMethod.." not implemented.") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- create project service data
    local projectDef = {
        steps = {
            { stepName = "enterprise_isp.TransferItemsFromTo_ASrv", async = true, stepDataDef = {
                { keyDef = "sourceItemsLocator"     , valueSource = 0, keyDefSource = "localInputItemsLocator" },
                { keyDef = "destinationHostLocator" , valueSource = 0, keyDefSource = "turtleInputLocator" },
            }},
            { stepName = productionServiceName, async = true, stepDataDef = {
                { keyDef = "turtleInputItemsLocator", valueSource = 1, keyDefSource = "destinationItemsLocator" },
                { keyDef = "productionSpot"         , valueSource = 0, keyDefSource = "productionSpot" },
                { keyDef = "productItemName"        , valueSource = 0, keyDefSource = "productItemName" },
                { keyDef = "productItemCount"       , valueSource = 0, keyDefSource = "productItemCount" },
                { keyDef = "productionRecipe"       , valueSource = 0, keyDefSource = "productionRecipe" },
            }},
            { stepName = "enterprise_isp.TransferItemsFromTo_ASrv", async = true, stepDataDef = {
                { keyDef = "sourceItemsLocator"     , valueSource = 2, keyDefSource = "turtleOutputItemsLocator" },
                { keyDef = "destinationHostLocator" , valueSource = 0, keyDefSource = "localOutputLocator" },
            }},
            { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                { keyDef = "success1"               , valueSource = 1, keyDefSource = "success" },
                { keyDef = "success2"               , valueSource = 2, keyDefSource = "success" },
                { keyDef = "success3"               , valueSource = 3, keyDefSource = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , valueSource = 4, keyDefSource = "success" },
            { keyDef = "localOutputItemsLocator"    , valueSource = 3, keyDefSource = "destinationItemsLocator" },
        }
    }
    local projectData = {
        localInputItemsLocator      = localInputItemsLocator,
        localOutputLocator          = localOutputLocator,

        turtleInputLocator          = turtleInputLocator,

        productionSpot              = productionSpot,
        productItemName             = productItemName,
        productItemCount            = productItemCount,
        productionRecipe            = productionRecipe,
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function FindSiteBySiteData(siteData)
    -- sites ophalen
    local sites = coredht.GetData(db.dhtRoot, db.dhtSites)

    -- check if we have any site
    if type(sites) ~= "table" then corelog.Warning('enterprise_factory.FindSiteBySiteData: no sites present') return nil end

    -- loop on sites
    for k, site in pairs(sites) do
        -- is this the one?
        if coremove.IsSameLocation(site.baseLocation, siteData.baseLocation) and site.version == siteData.siteVersion then
            return site
        end
    end

    return nil
end

function GetAvailableLocator(locators)
    -- check input
    if type(locators) ~="table" then corelog.Error("enterprise_factory_site.GetAvailableLocator: Invalid locators") return nil end

    -- find first available locator
    for i, locator in ipairs(locators) do
        -- ToDo: consider checking availability

        -- take first
        return locator
    end

    -- end
    return nil
end

function GetAvailableCraftSpot(site)
    -- check input
    if type(site) ~="table" then corelog.Error("enterprise_factory_site.GetAvailableCraftSpot: Invalid site") return nil end

    -- find first available spot
    for i, spot in ipairs(site.craftingSpots) do
        -- ToDo: consider checking availability

        -- take first
        return spot
    end

    -- end
    return nil
end

function CraftItem_ASrv(serviceData, callback, callbackData)
    --[[
        This async sewrvice should craft items at the productionSpot.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed correctly
                turtleOutputItemsLocator- (URL) locating the items that where produced (in a turtle)

        Parameters:
            serviceData                 - (table) data for the service
                turtleInputItemsLocator - (URL) locating the production ingredients in the turtle that should do the crafting
                productionSpot          - (table) production spot
                productItemName         - (string) name of item to produce
                productItemCount        - (number) amount of items to produce
                productionRecipe        - (table) crafting recipe
            callback                    - (string) name of function to call once the items are made
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_factory_site.CraftItem_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local turtleInputItemsLocator = url.URLClass:new(serviceData.turtleInputItemsLocator)
    if type(turtleInputItemsLocator) ~= "table" then corelog.Error("enterprise_factory_site.CraftItem_ASrv: Invalid turtleInputItemsLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productionSpot = serviceData.productionSpot
    if type(productionSpot) ~= "table" then corelog.Error("enterprise_factory_site.CraftItem_ASrv: Invalid productionSpot") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productItemName = serviceData.productItemName
    if type(productItemName) ~= "string" then corelog.Error("enterprise_factory_site.CraftItem_ASrv: Invalid productItemName") return {success = false} end
    local productItemCount = serviceData.productItemCount
    if type(productItemCount) ~= "number" then corelog.Error("enterprise_factory_site.CraftItem_ASrv: Invalid productItemCount") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productionRecipe = serviceData.productionRecipe
    if type(productionRecipe) ~= "table" then corelog.Error("enterprise_factory_site.CraftItem_ASrv: Invalid productionRecipe") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_factory_site.CraftItem_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- get spotLocation
    local spotLocation = productionSpot.location
    if type(spotLocation) ~= "table" then corelog.Error("enterprise_factory_site.CraftItem_ASrv: Invalid spotLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- gather assignment data
    local craftData = {
        productItemName = productItemName,
        productItemCount= productItemCount,

        recipe          = productionRecipe,
        workingLocation = coremove.CopyLocation(spotLocation),
    }
    local metaData = role_alchemist.Craft_MetaData(craftData)
    metaData.needTurtleId = turtleInputItemsLocator:getPort()
    -- ToDo: consider setting metaData.itemList from turtleInputItemsLocator path (as we already have it)

    -- add assignment
    corelog.WriteToLog("   >Crafting with recipe "..textutils.serialise(productionRecipe).."'s")
    coreassignment.AddAssignment(metaData, "role_alchemist.Craft_Task", craftData, callback, callbackData)

    -- end
    return nil
end

function GetAvailableSmeltSpot(site)
    -- check input
    if type(site) ~="table" then corelog.Error("enterprise_factory_site.GetAvailableSmeltSpot: Invalid site") return nil end

    -- find first available spot
    for i, spot in ipairs(site.smeltingSpots) do
        -- ToDo: consider checking availability

        -- take first
        return spot
    end

    -- end
    return nil
end

function SmeltItemAndPickup_ASrv(serviceData, callback, callbackData)
    --[[
        This async service should smelt items at the productionSpot and pickup the results.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed correctly
                turtleOutputItemsLocator- (URL) locating the items that where produced (in a turtle)

        Parameters:
            serviceData                 - (table) data for the service
                turtleInputItemsLocator - (URL) locating the production ingredients in the turtle that should do the crafting
                productionSpot          - (table) production spot
                productItemName         - (string) name of item to produce
                productItemCount        - (number) amount of items to produce
                productionRecipe        - (table) smelting recipe
            callback                    - (string) name of function to call once the items are made
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_factory_site.SmeltItemAndPickup_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local turtleInputItemsLocator = url.URLClass:new(serviceData.turtleInputItemsLocator)
    if type(turtleInputItemsLocator) ~= "table" then corelog.Error("enterprise_factory_site.SmeltItemAndPickup_ASrv: Invalid turtleInputItemsLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productionSpot = serviceData.productionSpot
    if type(productionSpot) ~= "table" then corelog.Error("enterprise_factory_site.SmeltItemAndPickup_ASrv: Invalid productionSpot") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productItemName = serviceData.productItemName
    if type(productItemName) ~= "string" then corelog.Error("enterprise_factory_site.SmeltItemAndPickup_ASrv: Invalid productItemName") return {success = false} end
    local productItemCount = serviceData.productItemCount
    if type(productItemCount) ~= "number" then corelog.Error("enterprise_factory_site.SmeltItemAndPickup_ASrv: Invalid productItemCount") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productionRecipe = serviceData.productionRecipe
    if type(productionRecipe) ~= "table" then corelog.Error("enterprise_factory_site.SmeltItemAndPickup_ASrv: Invalid productionRecipe") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_factory_site.SmeltItemAndPickup_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- get spotLocation
    local spotLocation = productionSpot.location
    if type(spotLocation) ~= "table" then corelog.Error("enterprise_factory_site.CraftItem_ASrv: Invalid spotLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- gather assignment data
    local smeltData = {
        productItemName = productItemName,
        productItemCount= productItemCount,
        recipe          = productionRecipe,

        workingLocation = coremove.CopyLocation(spotLocation),

        -- ToDo: do this more efficient/ different (determine beste type, calculate etc)
        fuelItemName    = "minecraft:birch_planks",
        fuelItemCount   = productItemCount,
    }
    local metaData = role_alchemist.SmeltAndPickup_MetaData(smeltData)
    metaData.needTurtleId = turtleInputItemsLocator:getPort()
    -- ToDo: consider setting metaData.itemList from turtleInputItemsLocator path (as we already have it)

    -- add assignment
    corelog.WriteToLog("   >Smelting with recipe "..textutils.serialise(productionRecipe).."'s")
    coreassignment.AddAssignment(metaData, "role_alchemist.SmeltAndPickup_Task", smeltData, callback, callbackData)

    -- end
    return nil
end
