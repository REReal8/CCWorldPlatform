local db = {
    dhtRoot     = "enterprise_factory",
    dhtSites    = "sites",
}

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function StartNewSite_SSrv(siteStartData)
    --[[
        This function should make the site available for production.

        Return value:
                                    - (string) the id of the new production site

        Parameters:
            siteStartData           - (table) data about the site to start, 
                version             - (string) version string of the site
                baseLocation        - (table) world location of the base (lower left corner) of this site
                craftingSpots       - (table) craftingSpots of this site
                    location        - (table) location of spot relative to baseLocation
                smeltingSpots       - (table) craftingSpots of this site
                    location        - (table) location of spot relative to baseLocation
    ]]

    -- variables
    local site = {
        version         = siteStartData.version,
        siteId          = coreutils.NewId(), -- ToDo consider using an internal (to the factory) counter. This might make use in an URL easier.

        baseLocation    = siteStartData.baseLocation,
--        entryLocation   = coremove.GetRelativeLocation(siteData.location, 3, 3, 1),

        craftingSpots   =  siteStartData.craftingSpots,
        smeltingSpots   =  siteStartData.smeltingSpots,
    }

    -- ToDo: initialise possible other data (like e.g. open for business, availability of spots)

    -- save the new site to our sites
    coredht.SaveData(site, db.dhtRoot, db.dhtSites, site.siteId)

    return site.siteId
end

function StopSite_ASrv(siteData, callback, callbackData)
    --[[
        This async public function stops a factory site. Stopping implies
          - the site is immediatly no longer available for new business
          - wait for all active work (production) on site to be ended
          - remove the site from the factory 

        Return value:
            nil 

        Async immediatly return value (to callback):
                                - (table)
                success         - (boolean) when the site was succesfully stopped

        Parameters:
            siteData            - (table) data about the site
                baseLocation    - (table) world location of the base (lower left corner) of the site
                siteVersion     - (string) version string of the site
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function
    ]]

    -- check input
    if type(siteData) ~= "table" or type(siteData.siteVersion) ~= "string" or type(siteData.baseLocation) ~= "table" then
        corelog.Error('enterprise_factory_site.StopSite_ASrv: Invalid siteData input')
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    if type(callback) ~= "string" then 
        corelog.Error('enterprise_factory_site.StopSite_ASrv: Invalid callback function')
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    callbackData = callbackData or {}

    -- find the site
    local site = FindSiteBySiteData(siteData)
    if type(site) ~="table" then
        corelog.Error("enterprise_factory_site.StopSite_ASrv: Failed retrieving factory site for siteData = "..textutils.serialise(siteData))
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end

    -- stop doing business for this site
    -- ToDo: implement

    -- wait for active work done
    -- ToDo: implement

    -- remove site from factory
    corelog.WriteToLog('  enterprise_factory_site.StopSite_ASrv: Removing site '..site.siteId)
    coredht.SaveData(nil, db.dhtRoot, db.dhtSites, site.siteId)

    -- do callback
    coreutils.DoCallback(callback, callbackData, {success = true})
end

function GetAvailableSiteData(recipe) -- ToDo: make this a service?
    --[[
        This public method finds and selects a suitable factory site for producing items from a recipe.

        Return value:
                                        - (table)
                siteProduceItemData     - (boolean) (partial) productionData to produce item

        Parameters:
--?            serviceData                - (table) data for the service
                recipe                  - (table) item base recipe (including possibly both a crafting as smelting recipe)
--?                itemName                - (string) name of item to produce
--?                itemAmount              - (number) amount of items to produce
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(recipe) ~= "table" then corelog.Error("enterprise_factory.FindAvailableSite: Invalid recipe") return nil end

    -- sites ophalen
    local sites = coredht.GetData(db.dhtRoot, db.dhtSites)
    if type(sites) ~= "table" then corelog.Warning("enterprise_factory.FindAvailableSite: no sites present") return nil end

    -- []
    local craftRecipe = recipe.crafting
    local smeltRecipe = recipe.smelting

    -- find available sites
    local availableSitesInfo = {
    }
    for k, site in pairs(sites) do
        local siteId = site.siteId
        -- check it can craft recipe
        if craftRecipe ~= nil then
            local craftSpot = enterprise_factory_site.GetAvailableCraftSpot(siteId)
            if craftSpot ~= nil then
                table.insert(availableSitesInfo, {
                   -- ToDo: consider adding the spot here!
                    siteId = siteId,
                    productionMethod = "crafting",
                    recipe = craftRecipe,
                })
            end
        end

        -- check it can smelt recipe
        if smeltRecipe ~= nil then
            local smeltSpot = enterprise_factory_site.GetAvailableSmeltSpot(siteId)
            if smeltSpot ~= nil then
                table.insert(availableSitesInfo, {
                    siteId = siteId,
                    productionMethod = "smelting",
                    recipe = smeltRecipe,
                })
            end
        end
    end

    -- select best site
    for i, siteProduceItemData in ipairs(availableSitesInfo) do
        -- for now take first

        return siteProduceItemData
        -- ToDo: consider finding best site based on some selection criterium 
    end

    corelog.Warning("enterprise_factory.FindAvailableSite: no site available")
    return nil
end

function ProduceItem_ASrv(serviceData, callback, callbackData)
    --[[
        This async public service produces multiple instances of a specific item in a factory site. It does so by producing 
        the requested amount of items with the supplied production method (i.e. crafting or smelting). 

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed correctly

        Parameters:
            serviceData                 - (table) data for the service
                siteId                  - (string) id of the factory site
                itemName                - (string) name of item to produce
                itemAmount              - (number) amount of items to produce
                productionMethod        = (string) production method to use
                recipe                  - (table) production recipe  - ToDo keep?
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local siteId = serviceData.siteId
    if type(siteId) ~= "string" then corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Invalid siteId") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local itemName = serviceData.itemName
    if type(itemName) ~= "string" then corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Invalid itemName") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local itemAmount = serviceData.itemAmount
    if type(itemAmount) ~= "number" then corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Invalid itemAmount") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productionMethod = serviceData.productionMethod
    if type(productionMethod) ~= "string" then corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Invalid productionMethod") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local recipe = serviceData.recipe
    if type(recipe) ~= "table" then corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Invalid recipe") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- produce with productionMethod 
    if productionMethod == "crafting" then
        CraftItem(siteId, serviceData, recipe, callback, callbackData)
    elseif productionMethod == "smelting" then
        SmeltItemAndPickup(siteId, serviceData, recipe, callback, callbackData)
        -- ToDo: consider splitting smelting from pickup in a later version. Possibly by using URL's referencing the pickup location (and time?)
    else
        corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Unknown recipe type to produce "..itemAmount.." "..itemName.."'s")
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function FindSiteBySiteData(siteData)
    -- sites ophalen
    local sites = coredht.GetData(db.dhtRoot, db.dhtSites)

    -- check if we have any site
    if type(sites) ~= "table" then corelog.Warning('enterprise_factory.FindSiteBySiteData: no sites present') return nil end

    -- loop on sites
    for k, site in pairs(sites) do
        -- is this the one?
        if coremove.IsSameLocation(site.baseLocation, siteData.baseLocation) and site.version == siteData.siteVersion then
            return site
        end
    end

    return nil
end

function GetAvailableCraftSpot(siteId)
     -- check input
     if type(siteId) ~="string" then corelog.Error("enterprise_factory_site.GetAvailableCraftSpot: Invalid siteId") return nil end

    -- get the site
    local site = coredht.GetData(db.dhtRoot, db.dhtSites, siteId)
    if type(site) ~="table" or type(site.siteId) ~= "string" or site.siteId ~= siteId then
        corelog.Error("enterprise_factory_site.GetAvailableCraftSpot: Failed retrieving factory site "..siteId)
        return nil
    end

     -- find first available spot
     -- ToDo consider finding best spot based on some selection criterium
     for i, spot in ipairs(site.craftingSpots) do
        -- take first
        return spot
     end

     -- 
     corelog.Warning("enterprise_factory_site.GetAvailableCraftSpot: No available crafting spot in site "..siteId)
     return nil
end

function CraftItem(siteId, productionData, recipe, callback, callbackData)
    --[[
        This async function should craft items at the site siteId.

        Return value:
            nil

        Async service return value (to callback):
                                    - (table) {success = true} if the items were succesfully produced

        Parameters:
            siteId                  - (string) id of the factory site
            productionData          - (table) data about the item to produce, 
                itemAmount          - amount of items to produce
            recipe                  - (table) crafting recipe
            callback                - (string) name of function to call once the items are made
            callbackData            - (table) data to supply to callback function
    ]]

    -- check input
    if type(siteId) ~="string" then corelog.Error("enterprise_factory_site.CraftItem: Invalid siteId") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- get the site
    local site = coredht.GetData(db.dhtRoot, db.dhtSites, siteId)
    if type(site) ~="table" or type(site.siteId) ~= "string" or site.siteId ~= siteId then 
        corelog.Error("enterprise_factory_site.CraftItem: Failed retrieving factory site "..siteId)
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end

    -- get available spot
    local spot = GetAvailableCraftSpot(site.siteId)
    if spot == nil then corelog.Error('enterprise_factory.CraftItem: No spot available in site '.. site.siteId) return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- gather assignment data
    local spotLocation = spot.location
    local craftData = {
        itemCount = productionData.itemAmount,

        recipe = recipe,
        workingLocation = coremove.GetRelativeLocation(site.baseLocation, spotLocation.x, spotLocation.y, spotLocation.z),
    --  ToDo: consider if this is still wanted
    --  ingredientsLocation = productionData.ingredientsURL,
    }
    local metaData = role_alchemist.Craft_MetaData(craftData)

    -- mark spot as unavailable
    -- ToDo: implement (not yet needed in current settle scenario where there is only one turtle)

    -- add assignment
    coreassignment.AddAssignment(metaData, "role_alchemist.Craft_Task", craftData, callback, callbackData)

    -- update the site in the dht
    -- ToDo: implement

    return nil
end

function GetAvailableSmeltSpot(siteId)
     -- check input
     if type(siteId) ~="string" then corelog.Error("enterprise_factory_site.GetAvailableSmeltSpot: Invalid site id ") return nil end

    -- get the site
    local site = coredht.GetData(db.dhtRoot, db.dhtSites, siteId)
    if type(site) ~="table" or type(site.siteId) ~= "string" or site.siteId ~= siteId then
        corelog.Error("enterprise_factory_site.GetAvailableSmeltSpot: Failed retrieving factory site "..siteId)
        return nil
    end

     -- find first available spot
     -- ToDo consider finding best spot based on some selection criterium
     for i, spot in ipairs(site.smeltingSpots) do
        -- take first
        return spot
     end

     -- 
     corelog.Warning("enterprise_factory_site.GetAvailableSmeltSpot: No available smelting spot in site "..siteId)
     return nil
end

function SmeltItemAndPickup(siteId, productionData, recipe, callback, callbackData)
    --[[
        This async function should smelt items at the site siteId and pickup the results.

        Return value:
            nil

        Async service return value (to callback):
                                    - (table) {success = true} if the items were succesfully produced

        Parameters:
            siteId                  - (string) id of the factory site
            productionData          - (table) data about the item to produce
                itemAmount          - amount of items to produce
            recipe                  - (table) smelting recipe
            callback                - (string) name of function to call once the items are made
            callbackData            - (table) data to supply to callback function
    ]]

    -- check input
    if type(siteId) ~="string" then corelog.Error("enterprise_factory_site.SmeltItemAndPickup: Invalid site id ") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- get the site
    local site = coredht.GetData(db.dhtRoot, db.dhtSites, siteId)
    if type(site) ~="table" or type(site.siteId) ~= "string" or site.siteId ~= siteId then 
        corelog.Error("enterprise_factory_site.SmeltItemAndPickup: Failed retrieving factory site "..siteId)
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end

    -- get available spot
    local spot = GetAvailableSmeltSpot(site.siteId)
    if spot == nil then corelog.Error('enterprise_factory.SmeltItemAndPickup: No spot available in site '.. site.siteId) return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- gather assignment data
    local spotLocation = spot.location
    local smeltData = {
        recipe = recipe,
        itemCount = productionData.itemAmount,

        workingLocation = coremove.GetRelativeLocation(site.baseLocation, spotLocation.x, spotLocation.y, spotLocation.z),

        -- ToDo: do this more efficient/ different (determine beste type, calculate etc)
        fuelItemName = "minecraft:birch_planks",
        fuelItemCount = productionData.itemAmount
    }
    local metaData = role_alchemist.SmeltAndPickup_MetaData(smeltData)

    -- mark spot as unavailable
    -- ToDo: implement (not yet needed in current settle scenario where there is only one turtle)

    -- add assignment
    coreassignment.AddAssignment(metaData, "role_alchemist.SmeltAndPickup_Task", smeltData, callback, callbackData)

    -- update the site in the dht
    -- ToDo: implement

    return nil
end
