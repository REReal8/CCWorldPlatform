local db = {
    dhtRoot     = "enterprise_factory",
    dhtSites    = "sites",
}

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function StartNewSite(siteStartData)
    --[[
        This function should make the site available for production.

        Return value:
                                    - (string) the id of the new production site

        Parameters:
            siteStartData           - (table) data about the site to start, 
                version             - (string) version string of the site
                baseLocation        - (table) world location of the base (lower left corner) of this site
                inputLocators       - (table) with inputLocator's of this site
                outputLocators      - (table) with outputLocator's of this site
                craftingSpots       - (table) craftingSpots of this site
                    location        - (table) location of spot
                smeltingSpots       - (table) craftingSpots of this site
                    location        - (table) location of spot
    ]]

    -- variables
    local site = {
        version         = siteStartData.version,
        siteId          = coreutils.NewId(), -- ToDo consider using an internal (to the factory) counter. This might make use in an URL easier.

        baseLocation    = siteStartData.baseLocation,
--        entryLocation   = coremove.GetRelativeLocation(siteData.location, 3, 3, 1),

        inputLocators   = siteStartData.inputLocators,
        outputLocators  = siteStartData.outputLocators,

        craftingSpots   =  siteStartData.craftingSpots,
        smeltingSpots   =  siteStartData.smeltingSpots,
    }

    -- ToDo: initialise possible other data (like e.g. open for business, availability of spots)

    -- save the new site to our sites
    coredht.SaveData(site, db.dhtRoot, db.dhtSites, site.siteId)

    -- end
    return site.siteId
end

function StopSite_ASrv(siteData, callback, callbackData)
    --[[
        This async public function stops a factory site. Stopping implies
          - the site is immediatly no longer available for new business
          - wait for all active work (production) on site to be ended
          - remove the site from the factory 

        Return value:
            nil 

        Async immediatly return value (to callback):
                                - (table)
                success         - (boolean) when the site was succesfully stopped

        Parameters:
            siteData            - (table) data about the site
                baseLocation    - (table) world location of the base (lower left corner) of the site
                siteVersion     - (string) version string of the site
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function
    ]]

    -- check input
    if type(siteData) ~= "table" or type(siteData.siteVersion) ~= "string" or type(siteData.baseLocation) ~= "table" then
        corelog.Error('enterprise_factory_site.StopSite_ASrv: Invalid siteData input')
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    if type(callback) ~= "string" then 
        corelog.Error('enterprise_factory_site.StopSite_ASrv: Invalid callback function')
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    callbackData = callbackData or {}

    -- find the site
    local site = FindSiteBySiteData(siteData)
    if type(site) ~="table" then
        corelog.Error("enterprise_factory_site.StopSite_ASrv: Failed retrieving factory site for siteData = "..textutils.serialise(siteData))
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end

    -- stop doing business for this site
    -- ToDo: implement

    -- wait for active work done
    -- ToDo: implement

    -- remove site from factory
    corelog.WriteToLog('  enterprise_factory_site.StopSite_ASrv: Removing site '..site.siteId)
    coredht.SaveData(nil, db.dhtRoot, db.dhtSites, site.siteId)

    -- do callback
    coreutils.DoCallback(callback, callbackData, {success = true})
end

function GetAvailableSiteData(recipe, itemAmount)
    --[[
        This public method finds and selects a suitable factory site for producing items from a recipe.

        Return value:
                siteProduceItemData     - (table) (partial) productionData to produce item

        Parameters:
            recipe                      - (table) item base recipe (including possibly both a crafting as smelting recipe)
            itemAmount                  - (number) amount of items to produce
    ]]

    -- check input
    if type(recipe) ~= "table" then corelog.Error("enterprise_factory.GetAvailableSiteData: Invalid recipe") return nil end
    if type(itemAmount) ~= "number" then corelog.Error("enterprise_factory.GetAvailableSiteData: Invalid itemAmount") return nil end

    -- sites ophalen
    local sites = coredht.GetData(db.dhtRoot, db.dhtSites)
    if type(sites) ~= "table" then corelog.Warning("enterprise_factory.GetAvailableSiteData: no sites present") return nil end

    -- []
    local craftRecipe = recipe.crafting
    local smeltRecipe = recipe.smelting

    -- find available sites
    local availableSitesInfo = {
    }
    for k, site in pairs(sites) do
        -- check
        if type(site) ~="table" then corelog.Error("enterprise_factory_site.GetAvailableSiteData: Invalid site") return nil end
        local siteId = site.siteId
        if type(siteId) ~="string" then corelog.Error("enterprise_factory_site.GetAvailableSiteData: Invalid siteId") return nil end

        -- get available inputLocator
        local inputLocator = GetAvailableLocator(site.inputLocators)
        if inputLocator == nil then
            corelog.Warning("enterprise_factory_site.GetAvailableSiteData: No available inputLocator in site "..siteId)
        else
            -- get available outputLocator
            local outputLocator = GetAvailableLocator(site.outputLocators)
            if outputLocator == nil then
                corelog.Warning("enterprise_factory_site.GetAvailableSiteData: No available outputLocator in site "..siteId)
            else
                -- check it can craft recipe
                if craftRecipe ~= nil then
                    local craftSpot = GetAvailableCraftSpot(site)
                    if craftSpot ~= nil then
                        table.insert(availableSitesInfo, {
                            localInputLocator   = inputLocator,
                            localOutputLocator  = outputLocator,
                            productionSpot      = craftSpot,
                            productionMethod    = "craft",
                            itemAmount          = itemAmount,
                            productionRecipe    = craftRecipe,
                        })
                    else
                        corelog.Warning("enterprise_factory_site.GetAvailableSiteData: No available crafting spot in site "..siteId)
                    end
                end

                -- check it can smelt recipe
                if smeltRecipe ~= nil then
                    local smeltSpot = GetAvailableSmeltSpot(site)
                    if smeltSpot ~= nil then
                        table.insert(availableSitesInfo, {
                            localInputLocator   = inputLocator,
                            localOutputLocator  = outputLocator,
                            productionSpot      = smeltSpot,
                            productionMethod    = "smelt",
                            itemAmount          = itemAmount,
                            productionRecipe    = smeltRecipe,
                        })
                    else
                        corelog.Warning("enterprise_factory_site.GetAvailableSiteData: No available smelting spot in site "..siteId)
                    end
                end
            end
        end
    end

    -- select best site
    local selectedProduceItemData = nil
    for i, siteProduceItemData in ipairs(availableSitesInfo) do
        -- for now take first
        selectedProduceItemData = siteProduceItemData
        break
        -- ToDo: consider finding best site based on some selection criterium 
    end
    if selectedProduceItemData == nil then corelog.Warning("enterprise_factory.GetAvailableSiteData: no site available") return nil end

    -- enhance with itemsNeeded
    local productionMethod = selectedProduceItemData.productionMethod
    local productionRecipe = selectedProduceItemData.productionRecipe
    if productionMethod == "craft" then
        selectedProduceItemData.itemsNeeded = role_alchemist.Craft_ItemsNeeded(productionRecipe, itemAmount)
    elseif productionMethod == "smelt" then
        -- determine production fuel
        -- ToDo: do this differently
        local fuelItemName  = "minecraft:birch_planks"
        local fuelItemCount = itemAmount

        selectedProduceItemData.itemsNeeded = role_alchemist.Smelt_ItemsNeeded(productionRecipe, itemAmount, fuelItemName, fuelItemCount)
    else corelog.Error("enterprise_factory_site.GetAvailableSiteData: Production with method "..productionMethod.." not implemented.") return nil end

    -- end
    return selectedProduceItemData
end

function ProduceItem_ASrv(serviceData, callback, callbackData)
    --[[
        This async public service produces multiple instances of a specific item in a factory site. It does so by producing 
        the requested amount of items with the supplied production method (i.e. crafting or smelting). 

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed correctly

        Parameters:
            serviceData                 - (table) data for the service
                localInputLocator       - (table) locating where the production ingredients can be retrieved locally "within" the site (e.g. an input chest)
                localOutputLocator      - (table) locating where the produced items need to be delivered locally "within" the site
                productionMethod        - (string) production method to use
                productionSpot          - (table) location of production spot
                itemAmount              - (number) amount of items to produce
                productionRecipe        - (table) production recipe  - ToDo keep?
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productionMethod = serviceData.productionMethod
    if type(productionMethod) ~= "string" then corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Invalid productionMethod") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- ToDo: implement retrieving ingredients from localInputLocator into turtle inventory

    -- ToDo: implement delivering products from turtle inventory to localOutputLocator

    -- produce with productionMethod 
    if productionMethod == "craft" then
        CraftItem_ASrv(serviceData, callback, callbackData)
    elseif productionMethod == "smelt" then
        SmeltItemAndPickup_ASrv(serviceData, callback, callbackData)
        -- ToDo: consider splitting smelting from pickup in a later version. Possibly by using URL's referencing the pickup location (and time?)
    else
        corelog.Error("enterprise_factory_site.ProduceItem_ASrv: Production with method "..productionMethod.." not implemented.")
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function FindSiteBySiteData(siteData)
    -- sites ophalen
    local sites = coredht.GetData(db.dhtRoot, db.dhtSites)

    -- check if we have any site
    if type(sites) ~= "table" then corelog.Warning('enterprise_factory.FindSiteBySiteData: no sites present') return nil end

    -- loop on sites
    for k, site in pairs(sites) do
        -- is this the one?
        if coremove.IsSameLocation(site.baseLocation, siteData.baseLocation) and site.version == siteData.siteVersion then
            return site
        end
    end

    return nil
end

function GetAvailableLocator(locators)
    -- check input
    if type(locators) ~="table" then corelog.Error("enterprise_factory_site.GetAvailableLocator: Invalid locators") return nil end

    -- find first available locator
    for i, locator in ipairs(locators) do
        -- ToDo: consider checking availability

        -- take first
        return locator
    end

    -- end
    return nil
end

function GetAvailableCraftSpot(site)
    -- check input
    if type(site) ~="table" then corelog.Error("enterprise_factory_site.GetAvailableCraftSpot: Invalid site") return nil end

    -- find first available spot
    for i, spot in ipairs(site.craftingSpots) do
        -- ToDo: consider checking availability

        -- take first
        return spot
    end

    -- end
    return nil
end

function CraftItem_ASrv(serviceData, callback, callbackData)
    --[[
        This async sewrvice should craft items at the productionSpot.

        Return value:
            nil

        Async service return value (to callback):
                                    - (table) {success = true} if the items were succesfully produced

        Parameters:
            serviceData             - (table) data for the service
                productionSpot      - (table) production spot
                itemAmount          - (number) amount of items to produce
                productionRecipe    - (table) crafting recipe  - ToDo keep?
            callback                - (string) name of function to call once the items are made
            callbackData            - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_factory_site.CraftItem_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local itemAmount = serviceData.itemAmount
    if type(itemAmount) ~= "number" then corelog.Error("enterprise_factory_site.CraftItem_ASrv: Invalid itemAmount") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productionSpot = serviceData.productionSpot
    if type(productionSpot) ~= "table" then corelog.Error("enterprise_factory_site.CraftItem_ASrv: Invalid productionSpot") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productionRecipe = serviceData.productionRecipe
    if type(productionRecipe) ~= "table" then corelog.Error("enterprise_factory_site.CraftItem_ASrv: Invalid productionRecipe") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_factory_site.CraftItem_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- get spotLocation
    local spotLocation = productionSpot.location
    if type(spotLocation) ~= "table" then corelog.Error("enterprise_factory_site.CraftItem_ASrv: Invalid spotLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- gather assignment data
    local craftData = {
        produceItemCount= itemAmount,

        recipe          = productionRecipe,
        workingLocation = coremove.CopyLocation(spotLocation),
    --  ToDo: consider if this is still wanted
    --  ingredientsLocation = productionData.ingredientsURL,
    }
    local metaData = role_alchemist.Craft_MetaData(craftData)

    -- mark spot as unavailable
    -- ToDo: implement (not yet needed in current settle scenario where there is only one turtle)

    -- add assignment
    coreassignment.AddAssignment(metaData, "role_alchemist.Craft_Task", craftData, callback, callbackData)

    -- update the site in the dht
    -- ToDo: implement

    return nil
end

function GetAvailableSmeltSpot(site)
    -- check input
    if type(site) ~="table" then corelog.Error("enterprise_factory_site.GetAvailableSmeltSpot: Invalid site") return nil end

    -- find first available spot
    for i, spot in ipairs(site.smeltingSpots) do
        -- ToDo: consider checking availability

        -- take first
        return spot
    end

    -- end
    return nil
end

function SmeltItemAndPickup_ASrv(serviceData, callback, callbackData)
    --[[
        This async service should smelt items at the productionSpot and pickup the results.

        Return value:
            nil

        Async service return value (to callback):
                                    - (table) {success = true} if the items were succesfully produced

        Parameters:
            serviceData             - (table) data for the service
                productionSpot      - (table) production spot
                itemAmount          - (number) amount of items to produce
                productionRecipe    - (table) smelting recipe  - ToDo keep?
            callback                - (string) name of function to call once the items are made
            callbackData            - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_factory_site.SmeltItemAndPickup_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local itemAmount = serviceData.itemAmount
    if type(itemAmount) ~= "number" then corelog.Error("enterprise_factory_site.SmeltItemAndPickup_ASrv: Invalid itemAmount") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productionSpot = serviceData.productionSpot
    if type(productionSpot) ~= "table" then corelog.Error("enterprise_factory_site.SmeltItemAndPickup_ASrv: Invalid productionSpot") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productionRecipe = serviceData.productionRecipe
    if type(productionRecipe) ~= "table" then corelog.Error("enterprise_factory_site.SmeltItemAndPickup_ASrv: Invalid productionRecipe") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_factory_site.SmeltItemAndPickup_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- get spotLocation
    local spotLocation = productionSpot.location
    if type(spotLocation) ~= "table" then corelog.Error("enterprise_factory_site.CraftItem_ASrv: Invalid spotLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- gather assignment data
    local smeltData = {
        produceItemCount= itemAmount,
        recipe          = productionRecipe,

        workingLocation = coremove.CopyLocation(spotLocation),

        -- ToDo: do this more efficient/ different (determine beste type, calculate etc)
        fuelItemName    = "minecraft:birch_planks",
        fuelItemCount   = itemAmount
    }
    local metaData = role_alchemist.SmeltAndPickup_MetaData(smeltData)

    -- mark spot as unavailable
    -- ToDo: implement (not yet needed in current settle scenario where there is only one turtle)

    -- add assignment
    coreassignment.AddAssignment(metaData, "role_alchemist.SmeltAndPickup_Task", smeltData, callback, callbackData)

    -- update the site in the dht
    -- ToDo: implement

    return nil
end
