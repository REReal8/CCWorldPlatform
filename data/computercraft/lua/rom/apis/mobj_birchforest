
--[[
    This file implements mobj_birchforest.

    Note that the syntax used is such that it (prepares for) a more object oriented Lua approach. See more from here https://www.lua.org/pil/16.html .
--]]

BirchForestClass = {
    _id                     = "",
    _level                  = 0,

    _location               = nil,
    _nTrees                 = 0,

    _localLogsLocator       = nil,
    _localSaplingsLocator   = nil,
}

local tree_patternL0 = {
    deltaX      = 6,
    deltaY      = 6,
    objectList  = {
        { x = 3, y = 3, block = "minecraft:birch_sapling"},
    },
    clearRemainingSpace = true,
}

local tree_patternL1 = {
    deltaX      = 6,
    deltaY      = 6,
    objectList  = {
        { x = 3, y = 3, block = "minecraft:birch_sapling"},
        { x = 3, y = 0, block = "minecraft:torch"},
        { x = 0, y = 3, block = "minecraft:torch"},
    },
    clearRemainingSpace = true,
}

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function BirchForestClass:new(o)
    --[[
        Constructs a mobj_birchforest.

        Parameters:
                                        - (table) table with
                _id                     - (string) id of the forest
                _level                  - (number) level of the forest
                _location               - (table) base location of the forest
                _nTrees                 - (string) # trees in the forest
                _localLogsLocator       - (URL) locating the local Supplier of logs (e.g. a chest)
                _localSaplingsLocator   - (URL) locating the local Supplier of saplings (e.g. a chest)
    --]]

    o = o or {}   -- create object if user does not provide one
    setmetatable(o, self)
    self.__index = self
    return o
end

function BirchForestClass:getId()
    return self._id
end

function BirchForestClass:getLevel()
    return self._level
end

function BirchForestClass:setLevel(level)
    -- check input
    if type(level) ~= "number" then corelog.Error("mobj_birchforest:setLevel: invalid level: "..type(level)) return end

    self._level = level
end

function BirchForestClass:getLocation()
    return self._location
end

function BirchForestClass:setLocation(location)
    -- check input
    if type(location) ~= "table" then corelog.Error("mobj_birchforest:setLocation: invalid location: "..type(location)) return end

    self._location = location
end

function BirchForestClass:getNTrees()
    return self._nTrees
end

function BirchForestClass:setNTrees(nTrees)
    -- check input
    if type(nTrees) ~= "number" then corelog.Error("mobj_birchforest:setNTrees: invalid # trees: "..type(nTrees)) return end

    self._nTrees = nTrees
end

function BirchForestClass:getLocalLogsLocator()
    return self._localLogsLocator
end

function BirchForestClass:setLocalLogsLocator(localLogsLocator)
    -- check input
    if type(localLogsLocator) ~= "table" then corelog.Error("mobj_birchforest:setLocalLogsLocator: Invalid localLogsLocator "..type(localLogsLocator)) return end

    self._localLogsLocator = localLogsLocator
end

function BirchForestClass:getLocalSaplingsLocator()
    return self._localSaplingsLocator
end

function BirchForestClass:setLocalSaplingsLocator(localSaplingsLocator)
    -- check input
    if type(localSaplingsLocator) ~= "table" then corelog.Error("mobj_birchforest:setLocalSaplingsLocator: Invalid localLogsLocator "..type(localSaplingsLocator)) return end

    self._localSaplingsLocator = localSaplingsLocator
end

function BirchForestClass:getBasePattern(level)
    if level == 0 then      return role_builder.CopyPattern(tree_patternL0)
    elseif level == 1 then  return role_builder.CopyPattern(tree_patternL1)
--    elseif level == 2 then  return role_builder.CopyPattern(base_patternL2)
    else                    corelog.Error("mobj_birchforest.getBasePattern: Don't know pattern for level "..level) return nil end
end

function BirchForestClass:getTreePattern(level)
    if level == 0 then      return role_builder.CopyPattern(tree_patternL0)
    elseif level == 1 then  return role_builder.CopyPattern(tree_patternL1)
--    elseif level == 2 then  return role_builder.CopyPattern(tree_patternL1) -- same as L1
    else                    corelog.Error("mobj_birchforest.getTreePattern: Don't know pattern for level "..level) return nil end
end

function BirchForestClass:copy()
    local forestCopy = BirchForestClass:new({
        _id                     = self._id,
        _level                  = self._level,

        _location               = coremove.CopyLocation(self._location),
        _nTrees                 = self._nTrees,

        _localLogsLocator       = self._localLogsLocator:copy(),
        _localSaplingsLocator   = self._localSaplingsLocator:copy(),
    })

    return forestCopy
end

function BirchForestClass:sameId(forest)
    return self:getId() == forest:getId()
end

function BirchForestClass:sameLevel(forest)
    return self:getLevel() == forest:getLevel()
end

function BirchForestClass:sameLocation(forest)
    local loc1 = self:getLocation()
    local loc2 = forest:getLocation()

    return coremove.IsSameLocation(loc1, loc2) and coremove.IsSameDirection(loc1, loc2)
end

function BirchForestClass:sameNTrees(forest)
    return self:getNTrees() == forest:getNTrees()
end

function BirchForestClass:getFuelNeed_Harvest_Att()
    --[[
        Forest attribute with the current fuelNeed to do one harvesting round.
    --]]

    -- determine fuelNeed
    local nTrees = self:getNTrees()
    local fuelNeed = role_forester.FuelNeededPerRound(nTrees)

    -- end
    return fuelNeed
end

function BirchForestClass:getFuelNeedExtraTree_Att()
    --[[
        Forest attribute with the fuelNeed for harvesting one extra tree.
        (i.e. it return the difference between the current getFuelNeed_Harvest_Att and the getFuelNeed_Harvest_Att if there would be 1 extra tree)
    --]]

    -- determine fuelNeed
    local nTrees = self:getNTrees()
    local fuelNeed_Current = role_forester.FuelNeededPerRound(nTrees)
    local fuelNeed_OneTreeExtra = role_forester.FuelNeededPerRound(nTrees + 1)

    -- end
    return fuelNeed_OneTreeExtra - fuelNeed_Current
end

function BirchForestClass:provideItemsTo_ASrv(...)
    -- get & check input from description
    local checkSuccess, provideItems, storageLocator, ingredientsSupplierLocator, assignmentsPriorityKey, callback, callbackData = coreutils.CheckInput([[
        This async public Supplier service provides specific items to a Storage.

        Return value:
            nil

        Async service return value (to callback):
                                            - (table)
                success                     - (boolean) whether the service executed correctly
                destinationItemsLocator     - (URL) locating the final Storage and the items that where transferred to it
                                                (upon service succes the "host" component of this URL should be equal to storageLocator, and
                                                the "query" should be equal to orderItems)

        Parameters:
            serviceData                     - (table) data for the service
                provideItems                + (table) with one or more items (formatted as an array of [itemName] = itemCount key-value pairs) to provide
                storageLocator              + (URL) locating the Storage where the items need to be provided to
                ingredientsSupplierLocator  + (URL) locating where the production ingredients can be retrieved
                assignmentsPriorityKey      + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                        + (string) name of function to call once service is ready
            callbackData                    + (table) data to supply to callback function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("mobj_birchforest:provideItemsTo_ASrv: Invalid input") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- loop on items
    for itemName, itemCount in pairs(provideItems) do
        -- check
        if type(itemName) ~= "string" then corelog.Error("mobj_birchforest:provideItemsTo_ASrv: Invalid itemName (type="..type(itemName)..")") return coreutils.DoCallback(callback, callbackData, {success = false}) end
        if type(itemCount) ~= "number" then corelog.Error("mobj_birchforest:provideItemsTo_ASrv: Invalid itemCount (type="..type(itemCount)..")") return coreutils.DoCallback(callback, callbackData, {success = false}) end

        -- check for birchlog or sapling
        local localStorageLocator = nil
        if itemName == "minecraft:birch_log" then
            localStorageLocator = self:getLocalLogsLocator()
        elseif itemName == "minecraft:birch_sapling" then
            localStorageLocator = self:getLocalSaplingsLocator()
        else
            corelog.Error("mobj_birchforest:provideItemsTo_ASrv: This is not a producer for item "..itemName) return coreutils.DoCallback(callback, callbackData, {success = false})
        end

        -- check items already available in localStorageLocator
        local localItemsLocator = localStorageLocator:copy()
        local item = { [itemName] = itemCount }
        localItemsLocator:setQuery(item)
        if enterprise_isp.Can_ProvideItems_QSrv( { itemsLocator = localItemsLocator} ).success then
            -- yes: return the items
            local transferData = {
                sourceItemsLocator          = localItemsLocator,
                destinationStorageLocator   = storageLocator,
                assignmentsPriorityKey      = assignmentsPriorityKey,
            }
--            corelog.WriteToLog(">Procuring "..itemCount.." "..itemName.."'s from local Storage in Forest")
            enterprise_isp.TransferItemsFromTo_ASrv(transferData, callback, callbackData)
        else
            -- construct new itemsLocator for this forest
            local forestLocator = enterprise_forestry.GetForestLocator(self:getId())
            local itemsLocator = forestLocator:copy()
            itemsLocator:setQuery(item)  -- ToDo: consider lower count with possible # items already present in localSupplierLocator

            -- construct taskData
            local harvestForestTaskData = {
                forestLevel         = self:getLevel(),
                firstTreeLocation   = self:getFirstTreeLocation(),
                nTrees              = self:getNTrees(),
                waitForFirstTree    = true,
--                waitForFirstTree    = (assignmentsPriorityKey ~= nil), -- energy efficient mode if assignmentsPriorityKey is set -- ToDo: consider change

                priorityKey         = assignmentsPriorityKey,
            }

            -- create project service data
            local projectDef = {
                steps = {
                    -- ToDo: consider retrieving birchSapling from it's local localSupplierLocator
                    --          (or will this be part of harvestForest?)
                    { stepName = "enterprise_assignmentboard.DoAssignment_ASrv", async = true, stepDataDef = {
                        { keyDef = "task"                       , valueSource = 0, keyDefSource = "harvestForest_Task" },
                        { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "harvestForestMetaData" },
                        { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "harvestForestTaskData" },
                    }},
                    -- ToDo: consider storing the harvested goods in the local localSupplierLocator's for birch_log and birchSapling
                    --          (or will this be part of harvestForest?)
                    -- ToDo: consider storing rest/ waste materials (e.g. sticks)
                    { stepName = "enterprise_forestry.ProvideItemsTo_ASrv", async = true, stepDataDef = { -- note: recursive call
                        { keyDef = "itemsLocator"               , valueSource = 0, keyDefSource = "itemsLocator" },
                        { keyDef = "storageLocator"             , valueSource = 0, keyDefSource = "storageLocator" },
                        { keyDef = "ingredientsSupplierLocator" , valueSource = 0, keyDefSource = "ingredientsSupplierLocator" },
                        { keyDef = "assignmentsPriorityKey"     , valueSource = 0, keyDefSource = "assignmentsPriorityKey" },
                    }},
                    { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                        { keyDef = "success1"                   , valueSource = 1, keyDefSource = "success" },
                        { keyDef = "success2"                   , valueSource = 2, keyDefSource = "success" },
                    }},
                },
                returnData  = {
                    { keyDef = "success"                        , valueSource = 3, keyDefSource = "success" },
                    { keyDef = "destinationItemsLocator"        , valueSource = 2, keyDefSource = "destinationItemsLocator" },
                }
            }
            local projectData = {
                itemsLocator                = itemsLocator,
                ingredientsSupplierLocator  = ingredientsSupplierLocator:copy(),
                storageLocator              = storageLocator:copy(),

                harvestForest_Task          = "role_forester.HarvestForest_Task",
                harvestForestTaskData       = harvestForestTaskData,
                harvestForestMetaData       = role_forester.HarvestForest_MetaData(harvestForestTaskData),

                assignmentsPriorityKey      = assignmentsPriorityKey,
            }
            local projectServiceData = {
                projectDef  = projectDef,
                projectData = projectData,
            }

            -- start project
--            corelog.WriteToLog(">Harvesting "..itemCount.." "..itemName.."'s from Forest")
            enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
        end
    end
end

function BirchForestClass:can_ProvideItems_QSrv(...)
    -- get & check input from description
    local checkSuccess, provideItems = coreutils.CheckInput([[
        This sync public query service answers the question whether the Supplier can provide specific items.

        Return value:
                                    - (table)
                success             - (boolean) whether the answer to the question is true

        Parameters:
            serviceData             - (table) data to the query
                provideItems        + (table) with one or more items (formatted as an array of [itemName] = itemCount key-value pairs) to provide
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("mobj_birchforest:can_ProvideItems_QSrv: Invalid input") return {success = false} end

    -- loop on items
    for itemName, itemCount in pairs(provideItems) do
        -- check
        if type(itemName) ~= "string" then corelog.Error("mobj_birchforest:can_ProvideItems_QSrv: itemName of wrong type = "..type(itemName)..".") return {success = false} end

        -- check for birchlog or sapling
        if itemName == "minecraft:birch_log" then
        elseif itemName == "minecraft:birch_sapling" then
        else
            return {success = false}
        end
    end

    -- end
    return {
        success = true,
    }
end

function BirchForestClass:needsTo_ProvideItemsTo_SSrv(...)
    -- get & check input from description
    local checkSuccess, provideItems, storageLocator = coreutils.CheckInput([[
        This sync public service returns the needs for the Supplier to provide specific items to a Storage.

        Return value:
                                            - (table)
                success                     - (boolean) whether the service executed correctly
                fuelNeed                    - (number) amount of fuel needed to provide items
                ingredientsNeed             - (table) ingredients needed to provide items

        Parameters:
            serviceData                     - (table) data to the query
                provideItems                + (table) with one or more items (formatted as an array of [itemName] = itemCount key-value pairs) to provide
                storageLocator              + (URL) locating the Storage where the items need to be provided to
                ingredientsSupplierLocator  - (URL, nil) locating where ingredients can be retrieved
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("mobj_birchforest:needsTo_ProvideItemsTo_SSrv: Invalid input") return {success = false} end

    -- loop on items
    local fuelNeed = 0
    local ingredientsNeed = {} -- ToDo ? should we add saplings for a harvest round here?
    local nTrees = self:getNTrees()
    for itemName, itemCount in pairs(provideItems) do
        -- check
        if type(itemName) ~= "string" then corelog.Error("mobj_birchforest:needsTo_ProvideItemsTo_SSrv: Invalid itemName (type="..type(itemName)..")") return {success = false} end
        if type(itemCount) ~= "number" then corelog.Error("mobj_birchforest:needsTo_ProvideItemsTo_SSrv: Invalid itemCount (type="..type(itemCount)..")") return {success = false} end

        -- check for birchlog or sapling
        local itemPerRound = 1
        local localSupplierLocator = nil
        if itemName == "minecraft:birch_log" then
            itemPerRound = 5 * nTrees -- using minimum birch_log per tree (based on data in birchgrow.xlsx)
            localSupplierLocator = self:getLocalLogsLocator()
        elseif itemName == "minecraft:birch_sapling" then
            itemPerRound = 1.4 * nTrees -- using average birch_sapling per tree (based on data in birchgrow.xlsx)
            -- ToDo: consider some safety margin for small forests as average ~= minimum (minimum = -1 in 9% of the cases)
            localSupplierLocator = self:getLocalSaplingsLocator()
        else
            return corelog.Error("mobj_birchforest:needsTo_ProvideItemsTo_SSrv: Provider does not provide "..itemName.."'s") {success = false}
        end

        -- fuelNeed per round
        local fuelPerRound = role_forester.FuelNeededPerRound(nTrees)
        local nRounds = math.ceil(itemCount / itemPerRound)
        local fuelNeed_Rounds = nRounds * fuelPerRound

        -- fuelNeed transfer
        local localSupplierItemsLocator = localSupplierLocator:copy()
        local items = { [itemName] = itemCount }
        localSupplierItemsLocator:setQuery(items)
        local transferData = {
            sourceItemsLocator          = localSupplierItemsLocator,
            destinationStorageLocator   = storageLocator,
        }
        local serviceResults = enterprise_isp.NeedsTo_TransferItems_SSrv(transferData)
        if not serviceResults.success then corelog.Error("mobj_birchforest:needsTo_ProvideItemsTo_SSrv: Failed obtaining transfer needs for "..itemCount.." "..itemName.."'s") return {success = false} end
        local fuelNeed_Transfer = serviceResults.fuelNeed

        -- add fuelNeed
--        corelog.WriteToLog("C  fuelNeed_Rounds="..fuelNeed_Rounds.." (nRounds="..nRounds..", fuelPerRound="..fuelPerRound.."), fuelNeed_Transfer="..fuelNeed_Transfer)
        fuelNeed = fuelNeed + fuelNeed_Rounds + fuelNeed_Transfer
    end

    -- end
    return {
        success         = true,
        fuelNeed        = fuelNeed,
        ingredientsNeed = ingredientsNeed,
    }
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function BirchForestClass:getFirstTreeLocation()
    return coremove.GetRelativeLocation(self:getLocation(), 3, 2, 0)
end
