--[[
    The Turtle enterprise provides services related to turtles.

    This enterprise is an Item Service Host (ISH), hence it provides the mandatory services and functions for an ISH (like e.g. ItemsAvailableVia, GetItemsIntoTurtle and PutItemsFromTurtle).

    Furthermore it provides the following additional services
        IsTurtleURL     - provide if URL is of a turtle
        GetTurtleURL    - provide the URL of a turtle
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

local hostName = "turtle"

function GetISHURL()
    --[[
        This sync public ISH function provides the (base) URL of this ISH.

        Return value:
            ishURL                  - (table) URL of this ISH

        Parameters:
            nil
    --]]

    local hostURL = url.URLClass:new()
    hostURL:setHost(hostName)

    return hostURL
end

function GetTurtleURL(serviceData)
    --[[
        This sync public services provides the URL of a turtle in the ISH.

        Return value:
                                    - (table)
                success             - (boolean) wether the URL was correctly obtained
                turtleURL           - (table) URL of the turtle

        Parameters:
            serviceData             - (table) data for this service
                turtleId            - (number) id of the turtle
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_isp.GetTurtletURL: Invalid serviceData input.") return {success = false} end
    local turtleId = serviceData.turtleId
    if type(turtleId) ~= "number" then corelog.Error("enterprise_isp.GetTurtletURL: Invalid turtleId input.") return {success = false} end

    -- construct URL
    local turtleURL = GetISHURL()
    turtleURL:setPort(turtleId)

    -- end
    local result = {
        success = true,
        turtleURL = turtleURL,
    }
    return result
end

function IsTurtleURL(queryData)
    --[[
        This sync public service answers the question if a URL is that of a turtle.
        
        Return value:
                                    - (table)
                success             - (boolean) wether the answer to the question is true

        Parameters:
            queryData               - (table) data about the query
                aURL                - (table) a URL that needs to be queried
    --]]

    -- check input
    if type(queryData) ~= "table" or type(queryData.aURL) ~= "table" then
        corelog.Error("enterprise_turtle.IsTurtleURL: Invalid queryData input.")
        return {success = false}
    end

    -- check if of a turtle
    local aURL = url.URLClass:new(queryData.aURL)
    local host = aURL:getHost()
    if type(host) ~= "string" then corelog.Error("enterprise_turtle.IsTurtleURL: Invalid host input in URL (="..aURL:getURI()..").") return {success = false} end
    if host == hostName then
        return {success = true} -- ToDo: consider distinquishing between service failure and question answer
    else
        return {success = false}
    end
end

function ItemsAvailableVia(queryData)
    --[[
        This sync public ISH service queries this enterprise for the availability of items. The ISH and query are specified by the "base" (i.e. "ccwprp://host:port/path")
        and "query" component (i.e. `?itemName=itemCount`) of an URL.

        Return value:
                                    - (table)
                success             - (boolean) whether all the queried items are available via this ISH.

        Parameters:
            queryData               - (table) data about the query
                itemQueryURL        - (table) a URL stating the items availability that needs to be queried
                                        (the "base" component of the URL specifies this ISH)
                                        (the "query" component of the URL specifies the items to query for)
    --]]

    -- check input
    if type(queryData) ~= "table" or type(queryData.itemQueryURL) ~= "table" then
        corelog.Error("enterprise_isp.ItemsAvailableVia: Invalid queryData input.")
        return {success = false}
    end

    -- check itemQueryURL is for this enterprise
    local itemQueryURL = url.URLClass:new(queryData.itemQueryURL)
    local itemQueryIsTurtle = IsTurtleURL({ aURL = itemQueryURL})
    if not itemQueryIsTurtle.success then corelog.Error("enterprise_turtle.ItemsAvailableVia: Invalid itemQueryURL (="..itemQueryURL:getURI()..").") return {success = false} end

    -- select turtle
    -- ToDo: based on port # (does this imply this to be an async service?)
    corelog.Warning("enterprise_turtle.ItemsAvailableVia: Selection of specific turtle not (?yet) implemented.")

    -- query turtle for items
    local query = itemQueryURL:getQuery()     -- e.g. {"minecraft:torch"=5, "minecraft:birch_log"=3}
    local inventory = coreinventory.GetInventoryDetail()
    for itemName, itemCount in pairs(query) do
        if type(itemName) ~= "string" then corelog.Error("enterprise_turtle.ItemsAvailableVia: itemName of wrong type = "..type(itemName)..".") return {success = false} end
        if type(itemCount) ~= "number" then corelog.Error("enterprise_turtle.ItemsAvailableVia: itemCount of wrong type = "..type(itemName)..".") return {success = false} end

        local inventoryCount = inventory.items[itemName]
        if inventoryCount == nil or inventoryCount < itemCount then
            corelog.WriteToLog("enterprise_turtle.ItemsAvailableVia: not enough (="..itemCount..") "..itemName.." items in inventory (="..(inventoryCount or 0)..").") return {success = false}
        end
    end

    -- end
    return {success = true}
end

function GetItemsIntoTurtle(transferData, callback, callbackData)
    --[[
        This async public ISH service ensures items are gathered in the ISH and transferred to the inventory of a turtle.

        Return value:
            nil 

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the items were succesfully transferred to a turtle
                turtleURL       - (table) a URL stating the turtle and the items it has gotton in it's inventory

        Parameters:
            transferData        - (table) data about the transfer
                sourceURL       - (table) a URL stating where the items that need transfer can be located (in/ by this ISH)
                                    (the "query" component of the URL specifies the items to be transferred)
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function                                                
    --]]

    -- check input
    if type(transferData) ~= "table" or type(transferData.sourceURL) ~= "table" then
        corelog.Error("enterprise_turtle.GetItemsIntoTurtle: Invalid transferData input.")
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    if type(callback) ~= "string" then 
        corelog.Error("enterprise_isp.GetItemsIntoTurtle: Invalid callback function.")
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    callbackData = callbackData or {}

    -- check source is for this enterprise
    local sourceURL = url.URLClass:new(transferData.sourceURL) -- needed in case service was called indirectly via a loadstring (hence use of serialize)
    local sourceIsTurtle = IsTurtleURL({ aURL = sourceURL})
    if not sourceIsTurtle.success then corelog.Error("enterprise_turtle.PutItemsFromTurtle: Invalid turtle source URL (="..sourceURL:getURI()..").") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- check turtle id's
    local currentTurtleId = os.getComputerID()
    local sourceTurtleId = sourceURL:getPort()
    if sourceTurtleId and currentTurtleId ~= sourceTurtleId then
        corelog.Error("enterprise_turtle.GetItemsIntoTurtle: Get items from one (id="..sourceTurtleId..") turtle to another (id="..currentTurtleId..") not implemented (?yet).")
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end

    -- do the (virtual) transfer

    -- create (partial) output turtleURL
    local getURLResult = GetTurtleURL({turtleId = currentTurtleId})
    if not getURLResult.success then corelog.Error("enterprise_turtle.GetItemsIntoTurtle: Failed creating turtleURL.") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local turtleURL = getURLResult.turtleURL
    if turtleURL == nil then corelog.Error("enterprise_turtle.GetItemsIntoTurtle: Invalid turtleURL created.") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- check if current turtle has the requested items in it's inventory
    -- ToDo: consider also checking if items are available (i.e. not reserved)
    local sourceQuery = sourceURL:getQuery()     -- e.g. {"minecraft:torch"=5, "minecraft:birch_log"=3}
    local inventory = coreinventory.GetInventoryDetail()
    for itemName, itemCount in pairs(sourceQuery) do
        if type(itemName) ~= "string" then corelog.Error("enterprise_turtle.GetItemsIntoTurtle: itemName of wrong type = "..type(itemName)..".") return coreutils.DoCallback(callback, callbackData, {success = false}) end
        if type(itemCount) ~= "number" then corelog.Error("enterprise_turtle.GetItemsIntoTurtle: itemCount of wrong type = "..type(itemName)..".") return coreutils.DoCallback(callback, callbackData, {success = false}) end

        local inventoryCount = inventory.items[itemName]
        if inventoryCount == nil or inventoryCount < itemCount then
            corelog.WriteToLog("enterprise_turtle.GetItemsIntoTurtle: not enough (="..itemCount..") "..itemName.." items in inventory (="..(inventoryCount or 0)..").") return coreutils.DoCallback(callback, callbackData, {success = false})
        end
    end
    turtleURL:setQuery(sourceQuery)

    -- end
    local result = {success = true, turtleURL = turtleURL}
    return coreutils.DoCallback(callback, callbackData, result)
end

function PutItemsFromTurtle(transferData, callback, callbackData)
    --[[
        This async public ISH service ensures items are transferred from the inventory of a turtle towards the ISH.

        An ISH should take special care the transfer from the turtle inventory gets priority over other assignments to the turtle.

        Return value:
            nil 

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the items were succesfully transferred to the ISH.

        Parameters:
            transferData        - (table) data about the transfer
                turtleSourceURL - (table) a URL stating the turtle and items in it's inventory that need to be transferred
                destinationURL  - (table) a URL stating where the items need to be transferred to (in/ by this ISH)
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function                                                
    --]]

    -- check input
    if type(transferData) ~= "table" or type(transferData.turtleSourceURL) ~= "table" or type(transferData.destinationURL) ~= "table" then
        corelog.Error("enterprise_isp.PutItemsFromTurtle: Invalid transferData input.")
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    if type(callback) ~= "string" then 
        corelog.Error("enterprise_isp.PutItemsFromTurtle: Invalid callback function.")
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    callbackData = callbackData or {}

    -- check source is for this enterprise
    local turtleSourceURL = url.URLClass:new(transferData.turtleSourceURL) -- needed in case service was called indirectly via a loadstring (hence use of serialize)
    local sourceIsTurtle = IsTurtleURL({ aURL = turtleSourceURL})
    if not sourceIsTurtle.success then corelog.Error("enterprise_turtle.PutItemsFromTurtle: Invalid turtle source URL (="..turtleSourceURL:getURI()..").") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- check destination is for this enterprise
    local destinationURL = url.URLClass:new(transferData.destinationURL) -- needed in case service was called indirectly via a loadstring (hence use of serialize)
    local destinationIsTurtle = IsTurtleURL({ aURL = destinationURL})
    if not destinationIsTurtle.success then corelog.Error("enterprise_turtle.PutItemsFromTurtle: Invalid destination URL (="..destinationURL:getURI()..").") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- check turtle id's
    local sourceTurtleId = turtleSourceURL:getPort()
    if sourceTurtleId == nil then corelog.Error("enterprise_turtle.PutItemsFromTurtle: Invalid turtle source input (i.e., no turtle id).") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local currentTurtleId = os.getComputerID()
    if currentTurtleId ~= sourceTurtleId then
        corelog.Error("enterprise_turtle.GetItemsIntoTurtle: Put items from one (id="..sourceTurtleId..") turtle to another (id="..currentTurtleId..") not implemented (?yet).")
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end

    -- do the (virtual) transfer

    -- check if destination/source/current turtle has the items in it's inventory
    local sourceQuery = turtleSourceURL:getQuery()     -- e.g. {"minecraft:torch"=5, "minecraft:birch_log"=3}
    local inventory = coreinventory.GetInventoryDetail()
    for itemName, itemCount in pairs(sourceQuery) do
        if type(itemName) ~= "string" then corelog.Error("enterprise_turtle.PutItemsFromTurtle: itemName of wrong type = "..type(itemName)..".") return coreutils.DoCallback(callback, callbackData, {success = false}) end
        if type(itemCount) ~= "number" then corelog.Error("enterprise_turtle.PutItemsFromTurtle: itemCount of wrong type = "..type(itemName)..".") return coreutils.DoCallback(callback, callbackData, {success = false}) end

        local inventoryCount = inventory.items[itemName]
        if inventoryCount == nil or inventoryCount < itemCount then
            corelog.WriteToLog("enterprise_turtle.PutItemsFromTurtle: not enough (="..itemCount..") "..itemName.." items in inventory (="..(inventoryCount or 0)..").") return coreutils.DoCallback(callback, callbackData, {success = false})
        end
    end

    -- end
    return coreutils.DoCallback(callback, callbackData, {success = true})
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

