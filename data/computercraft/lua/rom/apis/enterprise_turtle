local db = {
    hostName    = "turtle",
}


--[[
    The Turtle enterprise provides services related to turtles.

    This enterprise is an Item Service Host (ISH), hence it provides the mandatory services and functions for an ISH (like e.g. ItemsAvailableVia_SSrv, GetItemsIntoTurtle_ASrv and PutItemsFromTurtle_ASrv).

    Furthermore it provides the following additional services
        GetISHURL_SSrv         - provide host URL of this ISH 
        IsTurtleURL_QSrv       - provide if URL is of a turtle
        GetTurtleLocator_SSrv  - provide the URL of a turtle
        GetItemsLocator_SSrv   - provide the URL of items in a turtle
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function GetISHURL()
    --[[
        This sync public ISH function provides the (base) URL of this ISH.

        Return value:
            ishURL                  - (table) URL of this ISH

        Parameters:
            nil
    --]]

    local hostURL = url.URLClass:new()
    hostURL:setHost(db.hostName)

    return hostURL
end

function GetISHURL_SSrv(serviceData)
    --[[
        This sync public service provides the (base) URL of this ISH.

        Return value:
            ishURL                  - (table) URL of this ISH

        Parameters:
            serviceData             - (table) empty
    --]]

    -- end
    local result = {
        success = true,
        url = GetISHURL(),
    }
    return result
end

function GetTurtleLocator_SSrv(serviceData)
        --[[
        This sync public services provides the URL of a turtle in the ISH.

        Return value:
                                    - (table)
                success             - (boolean) wether the URL was correctly obtained
                url                 - (table) URL of the turtle

        Parameters:
            serviceData             - (table) data for this service
                turtleId            - (number) id of the turtle
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_turtle.GetTurtleLocator_SSrv: Invalid serviceData") return {success = false} end
    local turtleId = serviceData.turtleId
    if type(turtleId) ~= "number" then corelog.Error("enterprise_turtle.GetTurtleLocator_SSrv: Invalid turtleId") return {success = false} end

    -- construct URL
    local turtleURL = GetISHURL()
    turtleURL:setPort(turtleId)

    -- end
    local result = {
        success = true,
        url = turtleURL,
    }
    return result
end

function GetItemsLocator_SSrv(serviceData)
    --[[
        This sync public services provides the URL of the items in a turtle in the ISH.

        Return value:
                                    - (table)
                success             - (boolean) wether the URL was correctly obtained
                url                 - (table) URL of the items in the inventory of a turtle

        Parameters:
            serviceData             - (table) data for this service
                turtleId            - (number) id of the turtle
                itemsQuery          - (table) optional items to locate in turtle
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_turtle.GetItemsLocator_SSrv: Invalid serviceData") return {success = false} end
    local turtleId = serviceData.turtleId
    if type(turtleId) ~= "number" then corelog.Error("enterprise_turtle.GetItemsLocator_SSrv: Invalid turtleId") return {success = false} end
    local itemsQuery = serviceData.itemsQuery
    if type(itemsQuery) ~= "table" then corelog.Error("enterprise_turtle.GetItemsLocator_SSrv: Invalid itemsQuery") return {success = false} end

    -- construct URL
    local itemsLocator = GetTurtleLocator_SSrv(serviceData).url
    itemsLocator:setQuery(itemsQuery)

    -- end
    local result = {
        success = true,
        url = itemsLocator,
    }
    return result
end

function IsTurtleURL_QSrv(queryData)
    --[[
        This sync public service answers the question if a URL is that of a turtle.
        
        Return value:
                                    - (table)
                success             - (boolean) wether the answer to the question is true

        Parameters:
            queryData               - (table) data about the query
                aURL                - (table) a URL that needs to be queried
    --]]

    -- check input
    if type(queryData) ~= "table" or type(queryData.aURL) ~= "table" then
        corelog.Error("enterprise_turtle.IsTurtleURL_QSrv: Invalid queryData input.")
        return {success = false}
    end

    -- check if of a turtle
    local aURL = url.URLClass:new(queryData.aURL)
    local host = aURL:getHost()
    if type(host) ~= "string" then corelog.Error("enterprise_turtle.IsTurtleURL_QSrv: Invalid host input in URL (="..aURL:getURI()..").") return {success = false} end
    if host == db.hostName then
        return {success = true}
    else
        return {success = false}
    end
end

function ItemsAvailableVia_SSrv(queryData)
    --[[
        This sync public ISH service queries this enterprise for the availability of items. The ISH and query are specified by the "base" (i.e. "ccwprp://host:port/path")
        and "query" component (i.e. `?itemName=itemCount`) of an URL.

        Return value:
                                    - (table)
                success             - (boolean) whether all the queried items are available via this ISH.

        Parameters:
            queryData               - (table) data about the query
                itemsLocator        - (URL) stating the items availability that needs to be queried
                                        (the "base" component of the URL specifies this ISH)
                                        (the "query" component of the URL specifies the items to query for)
    --]]

    -- check input
    if type(queryData) ~= "table" then corelog.Error("enterprise_turtle.ItemsAvailableVia_SSrv: Invalid queryData") return {success = false} end
    local itemsLocator = url.URLClass:new(queryData.itemsLocator)
    if type(itemsLocator) ~= "table" then corelog.Error("enterprise_turtle.ItemsAvailableVia_SSrv: Invalid itemsLocator") return {success = false} end

    -- check itemsLocator is for this enterprise
    local itemsQueryIsTurtle = IsTurtleURL_QSrv({ aURL = itemsLocator})
    if not itemsQueryIsTurtle.success then corelog.Error("enterprise_turtle.ItemsAvailableVia_SSrv: Invalid itemsQueryURL (="..itemsLocator:getURI()..").") return {success = false} end

    -- select turtle
    local currentTurtleId = os.getComputerID()
    local itemsQueryTurtleId = itemsLocator:getPort()
    if itemsQueryTurtleId and currentTurtleId ~= itemsQueryTurtleId then corelog.Error("enterprise_turtle.ItemsAvailableVia_SSrv: Querying items in one (id="..itemsQueryTurtleId..") turtle from another (id="..currentTurtleId..") not implemented (?yet).") return {success = false} end

    -- query turtle for items
    local query = itemsLocator:getQuery()     -- e.g. {"minecraft:torch"=5, "minecraft:birch_log"=3}
    local inventory = coreinventory.GetInventoryDetail()
    for itemName, itemCount in pairs(query) do
        if type(itemName) ~= "string" then corelog.Error("enterprise_turtle.ItemsAvailableVia_SSrv: itemName of wrong type = "..type(itemName)..".") return {success = false} end
        if type(itemCount) ~= "number" then corelog.Error("enterprise_turtle.ItemsAvailableVia_SSrv: itemCount of wrong type = "..type(itemCount)..".") return {success = false} end

        local inventoryCount = inventory.items[itemName]
        if inventoryCount == nil or inventoryCount < itemCount then
            corelog.WriteToLog("enterprise_turtle.ItemsAvailableVia_SSrv: not enough (="..itemCount..") "..itemName.." items in inventory (="..(inventoryCount or 0)..").") return {success = false}
        end
    end

    -- end
    return {success = true}
end

function GetItemsIntoTurtle_ASrv(transferData, callback, callbackData)
    --[[
        This async public ISH service ensures items are gathered in the ISH and transferred to the inventory of a turtle.

        Return value:
            nil 

        Async service return value (to callback):
                                    - (table)
                success             - (boolean) whether the items were succesfully transferred to a turtle
                turtleItemsLocator  - (URL) stating a specific turtle and the items it has gotton in it's inventory

        Parameters:
            transferData            - (table) data about the transfer
                sourceItemsLocator  - (URL) stating where the items that need transfer can be located
                                        (the "query" component of the URL specifies the items to be transferred)
                                        (the "host" component of the URL should specify this host (i.e. a turtle) where the items are located)
            callback                - (string) name of function to call once service is ready
            callbackData            - (table) data to supply to callback function                                                
    --]]

    -- check input
    if type(transferData) ~= "table" then corelog.Error("enterprise_turtle.GetItemsIntoTurtle_ASrv: Invalid transferData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local sourceItemsLocator = url.URLClass:new(transferData.sourceItemsLocator)
    if type(sourceItemsLocator) ~= "table" then corelog.Error("enterprise_turtle.GetItemsIntoTurtle_ASrv: Invalid sourceItemsLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_turtle.GetItemsIntoTurtle_ASrv: Invalid callback") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- check source is for this enterprise
    local sourceIsTurtle = IsTurtleURL_QSrv({ aURL = sourceItemsLocator})
    if not sourceIsTurtle.success then corelog.Error("enterprise_turtle.GetItemsIntoTurtle_ASrv: Invalid turtle source URL (="..sourceItemsLocator:getURI()..").") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- check turtle id's
    local currentTurtleId = os.getComputerID()
    local sourceTurtleId = sourceItemsLocator:getPort()
    if sourceTurtleId and currentTurtleId ~= sourceTurtleId then
        corelog.Error("enterprise_turtle.GetItemsIntoTurtle_ASrv: Get items from one (id="..sourceTurtleId..") turtle to another (id="..currentTurtleId..") not implemented (?yet).")
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end

    -- do the (virtual) transfer

    -- create (partial) output turtleItemsLocator
    local getURLResult = GetTurtleLocator_SSrv({turtleId = currentTurtleId})
    if not getURLResult.success then corelog.Error("enterprise_turtle.GetItemsIntoTurtle_ASrv: Failed creating turtleItemsLocator.") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local turtleItemsLocator = getURLResult.url
    if turtleItemsLocator == nil then corelog.Error("enterprise_turtle.GetItemsIntoTurtle_ASrv: Invalid turtleItemsLocator created.") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- check if current turtle has the requested items in it's inventory
    -- ToDo: consider also checking if items are available (i.e. not reserved)
    local sourceQuery = sourceItemsLocator:getQuery()     -- e.g. {"minecraft:torch"=5, "minecraft:birch_log"=3}
    local inventory = coreinventory.GetInventoryDetail()
    for itemName, itemCount in pairs(sourceQuery) do
        if type(itemName) ~= "string" then corelog.Error("enterprise_turtle.GetItemsIntoTurtle_ASrv: itemName of wrong type = "..type(itemName)..".") return coreutils.DoCallback(callback, callbackData, {success = false}) end
        if type(itemCount) ~= "number" then corelog.Error("enterprise_turtle.GetItemsIntoTurtle_ASrv: itemCount of wrong type = "..type(itemCount)..".") return coreutils.DoCallback(callback, callbackData, {success = false}) end

        local inventoryCount = inventory.items[itemName]
        if inventoryCount == nil or inventoryCount < itemCount then
            corelog.WriteToLog("enterprise_turtle.GetItemsIntoTurtle_ASrv: not enough (="..itemCount..") "..itemName.." items in inventory (="..(inventoryCount or 0)..").") return coreutils.DoCallback(callback, callbackData, {success = false})
        end
    end
    turtleItemsLocator:setQuery(sourceQuery)

    -- end
    local result = {
        success             = true,
        turtleItemsLocator = turtleItemsLocator,
    }
    return coreutils.DoCallback(callback, callbackData, result)
end

function PutItemsFromTurtle_ASrv(transferData, callback, callbackData)
    --[[
        This async public ISH service ensures items are transferred from the inventory of a turtle towards the ISH.

        An ISH should take special care the transfer from the turtle inventory gets priority over other assignments to the turtle.

        Return value:
            nil 

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the items were succesfully transferred to the ISH.
                destinationItemsLocator - (URL) stating the final ISH and the items that where transferred to it
                                            (upon service succes the "host" component of this URL should be equal to destinationHostLocator, 
                                            the "port" should be a specific turtle, and the "query" should be equal to the "query" component of the turtleSourceURL)

        Parameters:
            transferData                - (table) data about the transfer
                turtleItemsLocator      - (URL) stating a specific turtle and the items in it's inventory that need to be put
                destinationHostLocator  - (URL) stating where the items need to be transferred to (i.e. a turtle in this host)
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function                                                
    --]]

    -- check input
    if type(transferData) ~= "table" then corelog.Error("enterprise_turtle.PutItemsFromTurtle_ASrv: Invalid transferData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local turtleItemsLocator = url.URLClass:new(transferData.turtleItemsLocator) -- needed in case service was called indirectly via a loadstring (hence use of serialize)
    if type(turtleItemsLocator) ~= "table" then corelog.Error("enterprise_turtle.PutItemsFromTurtle_ASrv: Invalid turtleItemsLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local destinationHostLocator = url.URLClass:new(transferData.destinationHostLocator) -- needed in case service was called indirectly via a loadstring (hence use of serialize)
    if type(destinationHostLocator) ~= "table" then corelog.Error("enterprise_turtle.PutItemsFromTurtle_ASrv: Invalid destinationHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_turtle.PutItemsFromTurtle_ASrv: Invalid callback function.") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- check source is a turtle
    local sourceIsTurtle = IsTurtleURL_QSrv({ aURL = turtleItemsLocator})
    if not sourceIsTurtle.success then corelog.Error("enterprise_turtle.PutItemsFromTurtle_ASrv: Invalid turtle source URL (="..turtleItemsLocator:getURI()..").") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- check destination is for this enterprise (i.e. a turtle)
    local destinationIsTurtle = IsTurtleURL_QSrv({ aURL = destinationHostLocator})
    if not destinationIsTurtle.success then corelog.Error("enterprise_turtle.PutItemsFromTurtle_ASrv: Invalid destination URL (="..destinationHostLocator:getURI()..").") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- check turtle id's
    local sourceTurtleId = turtleItemsLocator:getPort()
    if sourceTurtleId == nil then corelog.Error("enterprise_turtle.PutItemsFromTurtle_ASrv: Invalid turtle source input (i.e., no turtle id).") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local currentTurtleId = os.getComputerID()
    if currentTurtleId ~= sourceTurtleId then
        corelog.Error("enterprise_turtle.GetItemsIntoTurtle_ASrv: Put items from one (id="..sourceTurtleId..") turtle to another (id="..currentTurtleId..") not implemented (?yet).")
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end

    -- do the (virtual) transfer, i.e. check if source = current = destination turtle has the items in it's inventory
    local sourceQuery = turtleItemsLocator:getQuery()     -- e.g. {"minecraft:torch"=5, "minecraft:birch_log"=3}
    local inventory = coreinventory.GetInventoryDetail()
    for itemName, itemCount in pairs(sourceQuery) do
        if type(itemName) ~= "string" then corelog.Error("enterprise_turtle.PutItemsFromTurtle_ASrv: itemName of wrong type = "..type(itemName)..".") return coreutils.DoCallback(callback, callbackData, {success = false}) end
        if type(itemCount) ~= "number" then corelog.Error("enterprise_turtle.PutItemsFromTurtle_ASrv: itemCount of wrong type = "..type(itemCount)..".") return coreutils.DoCallback(callback, callbackData, {success = false}) end

        local inventoryCount = inventory.items[itemName]
        if inventoryCount == nil or inventoryCount < itemCount then
            corelog.Error("enterprise_turtle.PutItemsFromTurtle_ASrv: not enough (="..itemCount..") "..itemName.." items in inventory (="..(inventoryCount or 0)..").") return coreutils.DoCallback(callback, callbackData, {success = false})
        end
    end
    local destinationItemsLocator = url.URLClass:new(turtleItemsLocator)

    -- end
    local result = {
        success                     = true,
        destinationItemsLocator     = destinationItemsLocator,
    }
    return coreutils.DoCallback(callback, callbackData, result)
end

function GetTaskMetaData_SSrv(serviceData) -- ToDo: consider removing if this service is never used (currently not (anymore))
    --[[
        This sync public service retrieves meta data from a Task metadata function.

        A metadata function takes one parameter
            taskData                    - (table) data to supply to metadata function to be able to determine the metadata of the Task
        and return
            metaData                    - (table) with metadata of the task function

        Return value:
                                        - (table)
            success                     - (boolean) whether service was executed successfully.
            metaData                    - (table) with metadata on the Task

        Parameters:
            serviceData                 - (table) data for this service
                metaDataFunctionName    - (string) name of the the task function to execute
                taskData                - (table) data to supply to task function to be able to perform the task
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_turtle.GetTaskMetaData_SSrv: Invalid serviceData") return {success = false} end
    local metaDataFunctionName = serviceData.metaDataFunctionName
    if type(metaDataFunctionName) ~= "string" then corelog.Error("enterprise_turtle.GetTaskMetaData_SSrv: Invalid metaDataFunctionName") return {success = false} end
    local taskData = serviceData.taskData
    if type(taskData) ~= "table" then corelog.Error("enterprise_turtle.GetTaskMetaData_SSrv: Invalid taskData") return {success = false} end

    -- get metaData
    local metaData = coreutils.DoSyncService(metaDataFunctionName, taskData)

    -- end
    local serviceResults = {
        success = true,
        metaData = metaData,
    }
    return serviceResults
end

function DoAssignment_ASrv(serviceData, callback, callbackData)
    --[[
        This async public service executes a Task with an assignment. 

        A task function takes one parameter
            taskData                - (table) data to supply to task function to be able to perform the task
        and return
            taskResult              - (table) with return data of the task function

        Async service return value (to callback):
            task result             - (table) results of the task function

        Parameters:
            serviceData             - (table) data for this service
                taskFunctionName    - (string) name of the the task function to execute
                metaData            - (table) with metadata on the Task
                taskData            - (table) data to supply to task function to be able to perform the task
            callback                - (string) name of function to call once service (assignment) is ready
            callbackData            - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_turtle.DoAssignment_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local taskFunctionName = serviceData.taskFunctionName
    if type(taskFunctionName) ~= "string" then corelog.Error("enterprise_turtle.DoAssignment_ASrv: Invalid taskFunctionName") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local metaData = serviceData.metaData
    if type(metaData) ~= "table" then corelog.Error("enterprise_turtle.DoAssignment_ASrv: Invalid metaData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local taskData = serviceData.taskData
    if type(taskData) ~= "table" then corelog.Error("enterprise_turtle.DoAssignment_ASrv: Invalid taskData") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- add assignment
    corelog.WriteToLog(">Doing Assignment "..taskFunctionName..".")
    coreassignment.AddAssignment(metaData, taskFunctionName, taskData, callback, callbackData)
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

