--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function CopyPattern(pattern)
	return {
		deltaX              = pattern.deltaX,
		deltaY              = pattern.deltaY,
		objectList 	        = CopyObjectList(pattern.objectList),
		clearRemainingSpace = pattern.clearRemainingSpace,
	}
end

function CopyObjectList(objectList)
    local objectListCopy = {}

    for i, object in ipairs(objectList) do
        objectListCopy[i] = {
            x = object.x,
            y = object.y,
            block = object.block,
        }
        if object.dx ~= nil and object.dy ~= nil then
            objectListCopy[i].dx = object.dx
            objectListCopy[i].dy = object.dy
        end
    end

	return objectListCopy
end

function BuildBlueprint_MetaData(buildData)
    local metaData = {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(buildData.blueprintStartpoint),
        needTool = true,
        needTurtle = true,
        fuelNeeded = 0,
        itemsNeeded = {},
    }

    -- loop on layers
    local lastLocation = coremove.CopyLocation(buildData.blueprintStartpoint)
    for i, buildLayer in ipairs(buildData.blueprint.layerList) do
        -- determine buildData for this layer
        local layerBuildData = {
            startpoint              = coremove.GetRelativeLocation(buildLayer.startpoint,
                                                                buildData.blueprintStartpoint.x,
                                                                buildData.blueprintStartpoint.y,
                                                                buildData.blueprintStartpoint.z),
            buildFromAbove          = buildLayer.buildFromAbove,
            replacePresentObjects   = buildLayer.replacePresentObjects,
            pattern                 = buildLayer.pattern,
        }

        -- get metadata for layer
        local layerMetaData = BuildRectangularPattern_MetaData(layerBuildData)

        -- determine startLocation (correcting for buildFromAbove)
        local deltaZ = 1 if not layerBuildData.buildFromAbove then deltaZ = -1 end
        local startLocation = coremove.GetRelativeLocation(layerBuildData.startpoint, 0, 0, deltaZ)

        -- update blueprint metadata
        metaData.fuelNeeded = metaData.fuelNeeded + role_fuel_worker.NeededFuelToFrom(startLocation, lastLocation) + layerMetaData.fuelNeeded
        for layerItemName, layerItemCount in pairs(layerMetaData.itemsNeeded) do
            -- increment item counter
            metaData.itemsNeeded[layerItemName] = (metaData.itemsNeeded[layerItemName] or 0) + layerItemCount
        end

        lastLocation = coremove.GetRelativeLocation(buildLayer.startpoint, layerBuildData.pattern.deltaX, layerBuildData.pattern.deltaY, deltaZ)
    end

    -- update metadata with escapeSequence (if present)
    for i, escapeLocation in ipairs(buildData.blueprint.escapeSequence) do
        metaData.fuelNeeded = metaData.fuelNeeded + role_fuel_worker.NeededFuelToFrom(escapeLocation, lastLocation)

        lastLocation = escapeLocation
    end

    return metaData
end

function BuildBlueprint_Task(...)
    -- get & check input from description
    local checkSuccess, blueprintStartpoint, layerList, escapeSequence = coreutils.CheckInput([[
        This Task builds a blueprint.

        Return value:
                                        - (table) {success = true} if the blueprint was succesfully build

        Parameters:
            buildData                   - (table) data about the pattern
                blueprintStartpoint     + (table) top lower left coordinate to start building the blueprint
                blueprint               - (table) blueprint to build
                    layerList           + (table) layer to build
                    escapeSequence      + (table) escapeSequence of blueprint
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("role_builder.BuildBlueprint_Task: Invalid input") return {success = false} end

    -- loop on layers
    for i, buildLayer in ipairs(layerList) do
        -- determine buildData for this layer
        local layerBuildData = {
            startpoint              = coremove.GetRelativeLocation(buildLayer.startpoint,
                                                                   blueprintStartpoint.x,
                                                                   blueprintStartpoint.y,
                                                                   blueprintStartpoint.z),
            buildFromAbove          = buildLayer.buildFromAbove,
            replacePresentObjects   = buildLayer.replacePresentObjects,
            pattern                 = buildLayer.pattern,
        }

        -- build layer using internal task
        local result = BuildRectangularPattern_Task(layerBuildData)
        if result.success ~= true then
            corelog.Error("role_builder.BuildBlueprint_Task: Failed building layer " ..i..". Remaining layers skipped.")
            return {success = false}
        end
    end

    -- perform escape sequence
    for i, escapeLocation in ipairs(escapeSequence) do
        coremove.GoTo(coremove.GetRelativeLocation(blueprintStartpoint,
                                                   escapeLocation.x,
                                                   escapeLocation.y,
                                                   escapeLocation.z))
    end

    return {success = true}
end

function BuildRectangularPattern_MetaData(buildData)
    -- check input
    if type(buildData) ~= "table" then corelog.Error("role_builder.BuildRectangularPattern_MetaData: buildData not a table") return {} end
    if type(buildData.pattern) ~= "table" then corelog.Error("role_builder.BuildRectangularPattern_MetaData: pattern not a table") return {} end

    -- determine needed items
    local pattern = buildData.pattern
    local itemList = BuildRectangularPattern_ItemsNeeded(pattern)
    local startpoint = buildData.startpoint
    local fuelNeeded = (pattern.deltaX * pattern.deltaY - 1)

    -- determine startLocation (correcting for buildFromAbove)
    local deltaZ = 1 if not buildData.buildFromAbove then deltaZ = -1 end
    local startLocation = coremove.GetRelativeLocation(startpoint, 0, 0, deltaZ)

    -- return metadata
    return {
        startTime = coreutils.UniversalTime(),
        location = startLocation,
        needTool = true,
        needTurtle = true,
        fuelNeeded = fuelNeeded,
        itemsNeeded = itemList
    }
end

function BuildRectangularPattern_ItemsNeeded(pattern)
    -- check input
    if type(pattern.objectList) ~= "table" then corelog.Error("role_builder.BuildRectangularPattern_ItemsNeeded: objectList not a table") return {} end

    local itemList = {}
    for i, object in ipairs(pattern.objectList) do
        local patternItemName = object.block

        -- increment item counter
        itemList[patternItemName] = (itemList[patternItemName] or 0) + 1
    end

    -- end
    return itemList
end

function BuildRectangularPattern_Task(...)
    -- get & check input from description
    local checkSuccess, startpoint, buildFromAbove, replacePresentObjects, pattern = coreutils.CheckInput([[
        This Task builds a rectangular pattern in the x,y plane.

        Return value:
                                        - (table) {success = true} if the pattern was succesfully build

        Parameters:
            buildData                   - (table) data about the pattern
                startpoint              + (table) lower left coordinate to start building the pattern
                buildFromAbove          + (boolean) whether build should be done from above (true) or below (false)
                replacePresentObjects   + (boolean, false) whether objects should be replaced if it is already present in the minecraft world
                pattern                 + (table) pattern to build
                    deltaX              - (number) x size of pattern
                    deltaY              - (number) y size of pattern
                    objectList          - (table) array of objects to build
                    clearRemainingSpace - (boolean) whether spce not in the objectlist should be cleared
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("role_builder.BuildRectangularPattern_Task: Invalid input") return {success = false} end

    -- check mandatory pickage!
    local axePresent = coreinventory.Equip("minecraft:diamond_pickaxe")
    if not axePresent then corelog.Error("role_builder.BuildRectangularPattern_Task: No pickaxe present, we are on strike!") return {success = false} end

    -- check if inventory has what we need
    local itemList = BuildRectangularPattern_ItemsNeeded(pattern)
    for itemName, itemCount in pairs(itemList) do
        -- get items in inventory
        local inventoryItemCount = coreinventory.CountItem(itemName)

        -- enough?
        if inventoryItemCount < itemCount then
            corelog.Warning("role_builder.BuildRectangularPattern_Task: Not enough(="..itemCount..") "..itemName.." (="..inventoryItemCount..") in inventory to build the pattern")
        end
    end

    -- orientatie
    local deltaZ    = 1
    if buildFromAbove   then deltaZ    =  1
                        else deltaZ    = -1
    end

    -- go to starting location
    coremove.GoTo(coremove.GetRelativeLocation(startpoint, 0, 0, deltaZ), false)

    -- walk along x
    for x=0, pattern.deltaX - 1 do
        -- walk along y
        for iY=0, pattern.deltaY - 1 do
            -- determine y value such that path is back and forth in y
            local y = iY
            if x % 2 == 1 then
                y = pattern.deltaY - 1 - iY
            end

            -- ga naar de locatie
            coremove.MoveTo(coremove.GetRelativeLocation(startpoint, x, y, deltaZ), true)

            -- moeten we hier wat plaatsen?
            local placingBlock  = false
            for i, object in ipairs(pattern.objectList) do
                -- get & check object from description
                local checkObjSuccess, obj_x, obj_y, obj_dx, obj_dy, obj_block = coreutils.CheckInput([[
                    Parameters:
                        object              - (table) object to place
                            x               + (number) x coordinate within the pattern
                            y               + (number) y coordinate within the pattern
                            dx              + (number, 0) (optional) dx within pattern
                            dy              + (number, 0) (optional) dy within pattern
                            block           + (string) minecraft blocktype to build (e.g. "minecraft:torch")
                ]], object)
                if not checkObjSuccess then corelog.Error("role_builder.BuildRectangularPattern_Task: Invalid object in objectList") return {success = false} end

                -- juiste coordinaat?
                if obj_x == x and obj_y == y then
                    -- onthouden voor zo
                    placingBlock = true

                    -- moeten we in een specifieke richting draaien?
                    if obj_dx ~= 0 or obj_dy ~= 0 then
                        -- turn in the right direction
                        coremove.TurnTo({dx = obj_dx, dy = obj_dy})
                    end

                    -- check if block already present
                    local has_block, block_data
                    if not replacePresentObjects then
                        if buildFromAbove then
                            has_block, block_data = turtle.inspectDown()
                        else
                            has_block, block_data = turtle.inspectUp()
                        end
                    end

                    -- check placing object
                    if replacePresentObjects or not has_block or type(block_data) ~= "table" or block_data.name ~= obj_block then
                        -- block nu plaatsen
                        if coreinventory.SelectItem(obj_block) then
                            if buildFromAbove   then turtle.digDown()   turtle.placeDown()
                                                else turtle.digUp()     turtle.placeUp()
                            end
                        else
                            -- mandatory item not in inventory, error message and ignore
                            corelog.WriteToLog("Oops, BuildRectangularPattern_Task item not in inventory: "..obj_block)
                        end
                    end

                    -- klaar met deze loop
                    break
                end
            end

            -- nee? Dan iets weghalen?
            if not placingBlock and pattern.clearRemainingSpace then

                -- vak schoon maken
                if buildFromAbove  then turtle.digDown()
                                        else turtle.digUp()
                end
            end
        end
    end

    return {success = true}
end


--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

