local db = {
    dhtRoot     = "enterprise_chests",
    dhtChests   = "chests",
    hostName    = "chests",
}

--[[
    The chests enterprise provides services to perform operation on chests.

    This enterprise is an Item Service Host (ISH), hence it provides the mandatory services and functions for an ISH (like e.g. ItemsAvailableVia, GetItemsIntoTurtle and PutItemsFromTurtle).

    Furthermore it provides the following additional services
        RegisterChest       - to register ("add") a chest that can be serviced by this enterprise
        DelistChest         - to delist ("remove") a chest from being serviced by this enterprise
        GetChestURL         - provide the URL of a chest

    The enterprise does not provide services to build/ dismantle chests. This is to be done by other (enterprise) code. In a sense the enterprise_chests is not the
    "owner" of the chests, it just provides services to operate on them. 
    
    The following enterprise design decisions are made
        - Registered chests should never be accessed directly but only via the services of this enterprise.
        - Every chest get's a chestId upon registration. 
        - To operate on a chest this chestId should be supplied to each of the services.
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function GetChestURL(serviceData)
    --[[
        This sync public services provides the URL of a chest in the ISH.

        Return value:
                                    - (table)
                success             - (boolean) wether the URL was correctly obtained
                url                 - (table) URL of the chest in the ISH

        Parameters:
            serviceData             - (table) data for this service
                chestId             - (string) id of the chest
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_chests.GetChestURL: Invalid serviceData input.") return {success = false} end
    local chestId = serviceData.chestId
    if type(chestId) ~= "string" then corelog.Error("enterprise_chests.GetChestURL: Invalid chestId input.") return {success = false} end

    -- construct URL
    local chestURL = GetISHURL()
    chestURL:setPath({id = chestId})

    -- end
    local result = {
        success = true,
        url = chestURL,
    }
    return result
end

function IsChestURL(queryData)
    --[[
        This sync public service answers the question if a URL is that of a chest.
        
        Return value:
                                    - (table)
                success             - (boolean) wether the answer to the question is true

        Parameters:
            queryData               - (table) data about the query
                aURL                - (table) a URL that needs to be queried
    --]]

    -- check input
    if type(queryData) ~= "table" or type(queryData.aURL) ~= "table" then
        corelog.Error("enterprise_chests.IsChestURL: Invalid queryData input.")
        return {success = false}
    end

    -- check if of this ISH
    local aURL = url.URLClass:new(queryData.aURL)
    local host = aURL:getHost()
    if type(host) ~= "string" then corelog.Error("enterprise_chests.IsChestURL: Invalid host input in URL (="..aURL:getURI()..").") return {success = false} end
    if host == db.hostName then
        return {success = true} -- ToDo: consider distinquishing between service failure and question answer
    else
        return {success = false}
    end
end

function RegisterChest(chestData)
    --[[
        This sync public service registers ("adds") a chest to the enterprise.

        Note that the chest should already be present (constructed) in the world. It is however assumed the newly added chest is still empty.

        Return value:
                                    - (table)
                success             - (boolean) whether registering the chest was succesfull.
                id                  - (string) id of the created chest.

        Parameters:
            chestData               - (table) data to the chest
                location            - (table) location of the chest
                accessDirection     - (string) whether to access chest from "bottom", "top", "left", "right", "front" or "back" (relative to location)
    --]]

    -- check input
    if type(chestData) ~= "table" or type(chestData.location) ~= "table" or type(chestData.accessDirection) ~= "string" then
        corelog.Error("enterprise_chests.RegisterChest: Invalid chestData input.")
        return {success = false}
    end

    -- create new chest
    local chest = {
        id              = coreutils.NewId(),

        location        = coremove.CopyLocation(chestData.location),
        accessDirection = chestData.accessDirection,

        inventory = { -- assumed to be empty
            slots   = {},
            items   = {},
        },
    }

    -- ensure enterprise has a key in the dht
    if coredht.GetData(db.dhtRoot) == nil then -- ToDo: consider putting elsewhere
        -- create the entry
        coredht.SaveData({}, db.dhtRoot)
        coredht.SaveData({}, db.dhtRoot, db.dhtChests)
    end

    -- save the chest
    coredht.SaveData(chest, db.dhtRoot, db.dhtChests, chest.id)

    -- end
    local result = {
        success = true,
        id = chest.id
    }
    return result
end

function DelistChest(chestIdData, callback, callbackData)
    --[[
        This async public service delists ("removes") a chest from the enterprise. Delisting implies
            - the chest is immediatly no longer available for new business (e.g. adding/ removing items)
            - wait for all active work on chest to be ended
            - remove the chest from the enterprise 

        Note that the chest (and it's possibly remaining items) are not removed from the world.

        Return value:
            nil 

        Async service return value (to callback):
                                - (table)
                success         - (boolean) when the chest was succesfully delisted

        Parameters:
            chestIdData         - (table) data about the chest
                id              - (string) id of the chest.
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function
    ]]

    -- check input
    if type(chestIdData) ~= "table" or type(chestIdData.id) ~= "string" then
        corelog.Error('enterprise_chests.DelistChest: Invalid chestData input')
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    if type(callback) ~= "string" then 
        corelog.Error('enterprise_chests.DelistChest: Invalid callback function')
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    callbackData = callbackData or {}

    -- get the chest
    local chest = GetChestById(chestIdData.id)
    if type(chest) ~="table" then
        corelog.Error("enterprise_chests.DelistChest: Failed retrieving chest for chestData = "..textutils.serialise(chestIdData))
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end

    -- stop doing business for this chest
    -- ToDo: implement

    -- wait for active work done
    -- ToDo: implement

    -- remove site from enteprise
    corelog.WriteToLog('  enterprise_chests.DelistChest: Removing chest '..chest.id)
    coredht.SaveData(nil, db.dhtRoot, db.dhtChests, chest.id)

    -- do callback
    coreutils.DoCallback(callback, callbackData, {success = true})
end

function UpdateChestRecord(chestIdData, callback, callbackData)
    --[[
        This async public service brings the records of a chest up-to-date by fetching parameters and (re)setting the chest records.

        Using this method should normally not be needed as the records should be kept up-to-date by the various enterprise services. It could              
        typically be used for development purposes of if for some reason (e.g. after a turtle crash) the chest records could have been corrupted.

        Return value:
            nil 

        Async service return value (to callback):
                                - (table)
                success         - (boolean) if the chest record is succesfully updated

        Parameters:
            chestIdData         - (table) data about the chest
                id              - (string) id of the chest.
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function
    ]]

    -- check input
    if type(chestIdData) ~= "table" or type(chestIdData.id) ~= "string" then
        corelog.Error('enterprise_chests.UpdateChestRecord: Invalid chestData input')
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    if type(callback) ~= "string" then 
        corelog.Error('enterprise_chests.UpdateChestRecord: Invalid callback function')
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    callbackData = callbackData or {}

    -- create project definition
    local updateChestRecordsProject = {
        services    = {
            { serviceName = "enterprise_chests.FetchChestSlotsInventory", async = true, input = {
                { keyName = "id"        , valueSource = 0, sourceKey = "id" },
            }},
            { serviceName = "enterprise_chests.SetChestRecord", async = false, input = {
                { keyName = "id"        , valueSource = 0, sourceKey = "id" },
                { keyName = "slots"     , valueSource = 1, sourceKey = "slots" },
            }},
            { serviceName = "enterprise_projects.AllTrue", async = false, input = {
                { keyName = "success1"  , valueSource = 1, sourceKey = "success" },
                { keyName = "success2"  , valueSource = 2, sourceKey = "success" },
            }},
        },
        returnData  = {
            { keyName = "success", valueSource = 3, sourceKey = "success" },
        }
    }
    local projectData = {
        id = chestIdData.id,
    }

    -- start project
    corelog.WriteToLog(">Updating records for chest "..projectData.id..".")
    enterprise_projects.StartProject(updateChestRecordsProject, projectData, callback, callbackData)
end

function GetISHURL()
    --[[
        This sync public ISH function provides the (base) URL of this ISH.

        Return value:
            ishURL                  - (table) URL of this ISH

        Parameters:
            nil
    --]]

    local hostURL = url.URLClass:new()
    hostURL:setHost(db.hostName)

    return hostURL
end

function ItemsAvailableVia(queryData)
    --[[
        This sync public ISH service queries this enterprise for the availability of items. The ISH and query are specified by the "base" (i.e. "ccwprp://host:port/path")
        and "query" component (i.e. `?itemName=itemCount`) of an URL.

        Return value:
                                    - (table)
                success             - (boolean) whether all the queried items are available via this ISH.

        Parameters:
            queryData               - (table) data about the query
                itemQueryURL        - (table) a URL stating the items availability that needs to be queried
                                        (the "base" component of the URL specifies this ISH)
                                        (the "query" component of the URL specifies the items to query for)
    --]]

    -- check input
    if type(queryData) ~= "table" or type(queryData.itemQueryURL) ~= "table" then
        corelog.Error("enterprise_chests.ItemsAvailableVia: Invalid queryData input.")
        return {success = false}
    end

    -- check itemQueryURL is for this enterprise
    local itemQueryURL = url.URLClass:new(queryData.itemQueryURL)
    local itemQueryIsChest = IsChestURL({ aURL = itemQueryURL})
    if not itemQueryIsChest.success then corelog.Error("enterprise_chests.ItemsAvailableVia: Invalid itemQueryURL (="..itemQueryURL:getURI()..").") return {success = false} end

    -- select chest
    local chestId = itemQueryURL:getPath().id
    if type(chestId) ~= "string" then corelog.Error("enterprise_chests.ItemsAvailableVia: Invalid path input: "..textutils.serialize(itemQueryURL:getPath())..".") return {success = false} end

    -- get chest
    local chest = GetChestById(chestId)
    if type(chest) ~= "table" then corelog.Error("enterprise_chests.ItemsAvailableVia: Chest (id="..chestId..") not found.") return {success = false} end

    -- query chests inventory
    local query = itemQueryURL:getQuery()     -- e.g. {"minecraft:torch"=5, "minecraft:birch_log"=3}
    local inventory = chest.inventory
    for name, count in pairs(query) do
        if type(name) ~= "string" then corelog.Error("enterprise_chests.ItemsAvailableVia: itemName of wrong type = "..type(name)..".") return {success = false} end
        if type(count) ~= "number" then corelog.Error("enterprise_chests.ItemsAvailableVia: itemCount of wrong type = "..type(count)..".") return {success = false} end

        local inventoryCount = inventory.items[name]
        if inventoryCount == nil or inventoryCount < count then
            corelog.WriteToLog("enterprise_chests.ItemsAvailableVia: not enough (="..count..") "..name.." items in inventory (="..(inventoryCount or 0)..") of chest "..chestId..".") return {success = false}
        end
    end

    -- end
    return {success = true}
end

function GetItemsIntoTurtle(transferData, callback, callbackData)
    --[[
        This async public ISH service ensures items are gathered in the ISH and transferred to the inventory of a turtle.

        Return value:
            nil 

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the items were succesfully transferred to a turtle
                turtleURL       - (table) a URL stating the turtle and the items it has gotton in it's inventory

        Parameters:
            transferData        - (table) data about the transfer
                sourceURL       - (table) a URL stating where the items that need transfer can be located (in/ by this ISH)
                                    (the "query" component of the URL specifies the items to be transferred)
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function                                                
    --]]

    -- check input
    if type(transferData) ~= "table" or type(transferData.sourceURL) ~= "table" then
        corelog.Error("enterprise_chests.GetItemsIntoTurtle: Invalid transferData input.")
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    if type(callback) ~= "string" then 
        corelog.Error("enterprise_isp.GetItemsIntoTurtle: Invalid callback function.")
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    callbackData = callbackData or {}

    -- check source is for this enterprise
    local sourceURL = url.URLClass:new(transferData.sourceURL) -- needed in case service was called indirectly via a loadstring (hence use of serialize)
    local sourceIsChest = IsChestURL({ aURL = sourceURL})
    if not sourceIsChest.success then corelog.Error("enterprise_chests.GetItemsIntoTurtle: Invalid source URL (="..sourceURL:getURI()..").") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- get chestId
    local chestId = sourceURL:getPath().id
    if type(chestId) ~= "string" then corelog.Error("enterprise_chests.GetItemsIntoTurtle: Invalid path input: "..textutils.serialize(sourceURL:getPath())..".") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- create project definition
    local getItemsIntoTurtleProject = {
        services    = {
            { serviceName = "enterprise_chests.FetchItemsFromChestIntoTurtle", async = true, input = {
                { keyName = "chestId"   , valueSource = 0, sourceKey = "chestId" },
                { keyName = "itemQuery" , valueSource = 0, sourceKey = "itemQuery" },
            }},
            { serviceName = "enterprise_turtle.GetTurtleURL", async = false, input = {
                { keyName = "turtleId"  , valueSource = 1, sourceKey = "turtleId" },
                { keyName = "itemQuery" , valueSource = 1, sourceKey = "itemResultQuery" },
            }},
            { serviceName = "enterprise_chests.SetChestRecord", async = false, input = {
                { keyName = "id"        , valueSource = 0, sourceKey = "chestId" },
                { keyName = "slots"     , valueSource = 1, sourceKey = "slots" },
            }},
            { serviceName = "enterprise_projects.AllTrue", async = false, input = {
                { keyName = "success1"  , valueSource = 1, sourceKey = "success" },
                { keyName = "success2"  , valueSource = 2, sourceKey = "success" },
                { keyName = "success3"  , valueSource = 3, sourceKey = "success" },
            }},
        },
        returnData  = {
            { keyName = "success", valueSource = 4, sourceKey = "success" },
            { keyName = "turtleURL", valueSource = 2, sourceKey = "url" },
        }
    }
    local projectData = {
        chestId     = chestId,
        itemQuery   = sourceURL:getQuery()
    }

    -- start project
    corelog.WriteToLog(">Getting "..sourceURL:getQueryURI().." from chest "..projectData.chestId.." into a turtle.")
    enterprise_projects.StartProject(getItemsIntoTurtleProject, projectData, callback, callbackData)
end

function PutItemsFromTurtle(transferData, callback, callbackData)
    --[[
        This async public ISH service ensures items are transferred from the inventory of a turtle towards the ISH.

        An ISH should take special care the transfer from the turtle inventory gets priority over other assignments to the turtle.

        Return value:
            nil 

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the items were succesfully transferred to the ISH.

        Parameters:
            transferData        - (table) data about the transfer
                turtleSourceURL - (table) a URL stating the turtle and items in it's inventory that need to be transferred
                destinationURL  - (table) a URL stating where the items need to be transferred to (in/ by this ISH)
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function                                                
    --]]

    -- check input
    if type(transferData) ~= "table" or type(transferData.turtleSourceURL) ~= "table" or type(transferData.destinationURL) ~= "table" then
        corelog.Error("enterprise_isp.PutItemsFromTurtle: Invalid transferData input.")
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    if type(callback) ~= "string" then 
        corelog.Error("enterprise_isp.PutItemsFromTurtle: Invalid callback function.")
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    callbackData = callbackData or {}

    -- check destination is for this enterprise
    local destinationURL = url.URLClass:new(transferData.destinationURL)
    local destinationIsChest = IsChestURL({ aURL = destinationURL})
    if not destinationIsChest.success then corelog.Error("enterprise_chests.PutItemsFromTurtle: Invalid destination URL (="..destinationURL:getURI()..").") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- get chestId
    local chestId = destinationURL:getPath().id
    if type(chestId) ~= "string" then corelog.Error("enterprise_chests.PutItemsFromTurtle: Invalid path input: "..textutils.serialize(destinationURL:getPath())..".") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- create project definition
    local putItemsIntoChestProject = {
        services    = {
            { serviceName = "enterprise_chests.PutItemsFromTurtleIntoChest", async = true, input = {
                { keyName = "chestId"           , valueSource = 0, sourceKey = "chestId" },
                { keyName = "turtleSourceURL"   , valueSource = 0, sourceKey = "turtleSourceURL" },
            }},
            { serviceName = "enterprise_chests.SetChestRecord", async = false, input = {
                { keyName = "id"                , valueSource = 0, sourceKey = "chestId" },
                { keyName = "slots"             , valueSource = 1, sourceKey = "slots" },
            }},
            { serviceName = "enterprise_projects.AllTrue", async = false, input = {
                { keyName = "success1"  , valueSource = 1, sourceKey = "success" },
                { keyName = "success2"  , valueSource = 2, sourceKey = "success" },
            }},
        },
        returnData  = {
            { keyName = "success", valueSource = 3, sourceKey = "success" },
        }
    }
    local projectData = {
        chestId         = chestId,
        turtleSourceURL = transferData.turtleSourceURL
    }

    -- start project
    corelog.WriteToLog(">Putting items from turtle URL "..transferData.turtleSourceURL:getURI().." into chest "..projectData.chestId..".")
    enterprise_projects.StartProject(putItemsIntoChestProject, projectData, callback, callbackData)
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function DeleteChests()
    local chests = coredht.GetData(db.dhtRoot, db.dhtChests)
    if not chests or type(chests) ~= "table" then corelog.Warning("coreassignment.DeleteChests: chests not valid") return nil end

    -- remove all
    corelog.Warning("All chests are being deleted!")
    for chestId, chest in pairs(chests) do
        -- remove
        corelog.Warning("  deleting chest "..chestId)
        coredht.SaveData(nil, db.dhtRoot, db.dhtChests, chestId)
    end
end

function GetChestById(chestId)
    -- chests ophalen
    local chest = coredht.GetData(db.dhtRoot, db.dhtChests, chestId)
    if type(chest) ~= "table" then corelog.Warning("enterprise_chests.GetChestById: chest "..chestId.."not found") end

    return chest
end

function SetChestRecord(serviceData)
    --[[
        This sync private service sets a chest record based on (already obtained) parameters (like e.g. the slots inventory). 
        
        Return value:
                                - (table)
                success         - (boolean) whether the records were succesfully set

        Parameters:
            serviceData         - (table) data for this service
                id              - (string) id of the chest.
                slots           - (string) slots inventory of the chest.
    ]]

    -- check input
    if type(serviceData) ~= "table" or type(serviceData.id) ~= "string" or type(serviceData.slots) ~= "table" then
        corelog.Error('enterprise_chests.SetChestRecord: Invalid serviceData input')
        return {success = false}
    end

    -- get the chest
    local chestId = serviceData.id
    local chest = GetChestById(chestId)
    if type(chest) ~="table" then
        corelog.Error("enterprise_chests.SetChestRecord: Failed retrieving chest for chestIdData = "..chestId)
        return {success = false}
    end

    -- determine items inventory
    local slots = serviceData.slots
    local inventory = DetermineInventory(slots)

    -- set record
    chest.inventory = inventory

    -- save record
    coredht.SaveData(chest, db.dhtRoot, db.dhtChests, chest.id)

    -- end
    return {success = true}
end

function DetermineInventory(slots)
    -- construct inventory
    local inventory = {
        slots   = slots, -- ToDo: consider deep copy
        items   = {},
    }

    -- loop on slots
    for slot, item in pairs(slots) do
        -- right item?
        if type(item) == "table" then
            -- add to items
            inventory.items[ item.name ]  = (inventory.items[ item.name ] or 0) + item.count
        end
    end

    -- end
    return inventory
end

function FetchChestSlotsInventory(chestIdData, callback, callbackData)
    --[[
        This async private service fetches the slots inventory from a chest. 
        
        Return value:
            nil 

        Async service return value (to callback):
                                - (table)
                success         - (boolean) when the inventory was succesfully retrieved
                slots           - (table) the slots inventory of a chest

        Parameters:
            chestIdData         - (table) data about the chest
                id              - (string) id of the chest.
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function
    ]]

    -- check input
    if type(chestIdData) ~= "table" or type(chestIdData.id) ~= "string" then
        corelog.Error('enterprise_chests.FetchChestSlotsInventory: Invalid chestIdData input')
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    if type(callback) ~= "string" then 
        corelog.Error('enterprise_chests.FetchChestSlotsInventory: Invalid callback function')
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    callbackData = callbackData or {}

    -- get the chest
    local chest = GetChestById(chestIdData.id)
    if type(chest) ~="table" then
        corelog.Error("enterprise_chests.FetchChestSlotsInventory: Failed retrieving chest for chestIdData = "..textutils.serialise(chestIdData))
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end

    -- fetch with an assignment
    local taskData = {
        location = coremove.CopyLocation(chest.location),
        accessDirection = chest.accessDirection,
    }
    local metaData = role_chests_worker.FetchChestSlotsInventory_MetaData(taskData)
    coreassignment.AddAssignment(metaData, "role_chests_worker.FetchChestSlotsInventory_Task", taskData, callback, callbackData)
end

function FetchItemsFromChestIntoTurtle(serviceData, callback, callbackData)
    --[[
        This async private service fetches items from a chest into the inventory of a turtle.
        
        Return value:
            nil 

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the items were succesfully fetched
                slots           - (table) the slots inventory of the chest (after the items have been removed)
                turtleURL       - (table) a URL stating the turtle and the items it has gotton in it's inventory

        Parameters:
            serviceData         - (table) data about the chest
                chestId         - (string) id of the chest.
                itemQuery       - (table) with items to be fetched
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" or type(serviceData.chestId) ~= "string" or type(serviceData.itemQuery) ~= "table" then
        corelog.Error('enterprise_chests.FetchItemsFromChestIntoTurtle: Invalid serviceData input')
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    if type(callback) ~= "string" then 
        corelog.Error('enterprise_chests.FetchItemsFromChestIntoTurtle: Invalid callback function')
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    callbackData = callbackData or {}

    -- get the chest
    local chest = GetChestById(serviceData.chestId)
    if type(chest) ~="table" then
        corelog.Error("enterprise_chests.FetchItemsFromChestIntoTurtle: Failed retrieving chest for serviceData = "..textutils.serialise(serviceData))
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end

    -- fetch with an assignment
    local taskData = {
        location        = coremove.CopyLocation(chest.location),
        accessDirection = chest.accessDirection,
        itemQuery       = serviceData.itemQuery
    }
    local metaData = role_chests_worker.FetchItemsFromChestIntoTurtle_MetaData(taskData)
    coreassignment.AddAssignment(metaData, "role_chests_worker.FetchItemsFromChestIntoTurtle_Task", taskData, callback, callbackData)
end

function PutItemsFromTurtleIntoChest(serviceData, callback, callbackData)
    --[[
        This async private service puts items from a the inventory of a turtle into a chest.
        
        Return value:
            nil 

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the items were succesfully put
                slots           - (table) the slots inventory of the chest (after the items have been put)

        Parameters:
            serviceData         - (table) data about the chest
                turtleSourceURL - (table) a URL stating the turtle and items in it's inventory that need to be transferred
                chestId         - (string) id of the chest
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_chests.PutItemsFromTurtleIntoChest: serviceData not valid") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local turtleSourceURL = url.URLClass:new(serviceData.turtleSourceURL)
    if type(turtleSourceURL) ~= "table" then corelog.Error("enterprise_chests.PutItemsFromTurtleIntoChest: invalid turtleSourceURL") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local chestId = serviceData.chestId
    if type(chestId) ~= "string" then corelog.Error("enterprise_chests.PutItemsFromTurtleIntoChest: invalid chestId") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error('enterprise_chests.PutItemsFromTurtleIntoChest: Invalid callback function') return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- check source is a turtle
    local sourceIsTurtle = enterprise_turtle.IsTurtleURL({ aURL = turtleSourceURL})
    if not sourceIsTurtle.success then corelog.Error("enterprise_chests.PutItemsFromTurtleIntoChest: Invalid turtle source URL (="..turtleSourceURL:getURI()..").") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- get the chest
    local chest = GetChestById(serviceData.chestId)
    if type(chest) ~="table" then corelog.Error("enterprise_chests.PutItemsFromTurtleIntoChest: Failed retrieving chest for serviceData = "..textutils.serialise(serviceData)) return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- put with an assignment
    local taskData = {
        turtleId        = turtleSourceURL:getPort(),
        itemQuery       = turtleSourceURL:getQuery(),
        location        = coremove.CopyLocation(chest.location),
        accessDirection = chest.accessDirection,
    }
    local metaData = role_chests_worker.PutItemsFromTurtleIntoChest_MetaData(taskData)
    coreassignment.AddAssignment(metaData, "role_chests_worker.PutItemsFromTurtleIntoChest_Task", taskData, callback, callbackData)
end
