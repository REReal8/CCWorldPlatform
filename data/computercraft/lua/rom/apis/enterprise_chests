local db = {
    dhtRoot     = "enterprise_chests",
    dhtChests   = "chests",
    hostName    = "chests",
}

--[[
    The chests enterprise provides services to perform operation on chests.

    This enterprise is both a Supplier and a Storage, hence it provides the mandatory services and functions for the types (like e.g. ItemsAvailableVia_SSrv, GetItemsIntoTurtle_ASrv and PutItemsFromTurtle_ASrv).

    Furthermore it provides the following additional services
        GetHostLocator_SSrv     - provide host URL of the enterprise 
        RegisterChest_SSrv      - to register ("add") a chest that can be serviced by this enterprise
        DelistChest_ASrv        - to delist ("remove") a chest from being serviced by this enterprise
        GetItemsLocator_SSrv    - provide the URL of items in a chest
        IsChestURL_QSrv         - answers the question if a URL is that of a chest
        UpdateChestRecord_ASrv  - brings the records of a chest up-to-date by fetching parameters

    The enterprise does not provide services to build/ dismantle chests. This is to be done by other (enterprise) code. In a sense the enterprise_chests is not the
    "owner" of the chests, it just provides services to operate on them. 
    
    The following enterprise design decisions are made
        - Registered chests should never be accessed directly but only via the services of this enterprise.
        - Every chest get's a chestLocator upon registration. 
        - To operate on a chest this chestLocator should be supplied to each of the public services.
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function GetHostLocator_SSrv(serviceData)
    --[[
        This sync public service provides the (base) URL of this enterprise.

        Return value:
            hostLocator             - (URL) locating this enterprise

        Parameters:
            serviceData             - (table) empty
    --]]

    -- end
    local result = {
        success = true,
        hostLocator = GetISHURL(),
    }
    return result
end

function GetItemsLocator_SSrv(serviceData)
        --[[
        This sync public services provides the URL of items in a chest in the enterprise.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                itemsLocator        - (URL) locating the items in a chest

        Parameters:
            serviceData             - (table) data for this service
                chestLocator        - (URL) locating a chest
                itemsQuery          - (table) optional items to locate in chest
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_chests.GetItemsLocator_SSrv: Invalid serviceData") return {success = false} end
    local chestLocator = url.URLClass:new(serviceData.chestLocator)
    if type(chestLocator) ~= "table" then corelog.Error("enterprise_chests.GetItemsLocator_SSrv: Invalid chestLocator") return {success = false} end
    local itemsQuery = serviceData.itemsQuery
    if type(itemsQuery) ~= "table" then corelog.Error("enterprise_chests.GetItemsLocator_SSrv: Invalid itemsQuery") return {success = false} end

    -- construct URL
    local itemsLocator = chestLocator:copy()
    itemsLocator:setQuery(itemsQuery)

    -- end
    local result = {
        success = true,
        itemsLocator = itemsLocator,
    }
    return result
end

function IsChestURL_QSrv(queryData)
    --[[
        This sync public service answers the question if a URL is that of a chest.
        
        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully

        Parameters:
            queryData               - (table) data about the query
                aURL                - (table) a URL that needs to be queried
    --]]

    -- check input
    if type(queryData) ~= "table" then corelog.Error("enterprise_chests.IsChestURL_QSrv: Invalid queryData") return {success = false} end
    local aURL = url.URLClass:new(queryData.aURL)
    if type(aURL) ~= "table" then corelog.Error("enterprise_chests.IsChestURL_QSrv: Invalid aURL") return {success = false} end

    -- check if of this ISH
    local host = aURL:getHost()
    if type(host) ~= "string" then corelog.Error("enterprise_chests.IsChestURL_QSrv: Invalid host input in URL (="..aURL:getURI()..").") return {success = false} end
    if host == db.hostName then
        return {success = true}
    else
        return {success = false}
    end
end

function RegisterChest_SSrv(chestData)
    --[[
        This sync public service registers ("adds") a chest to the enterprise.

        Note that the chest should already be present (constructed) in the world. It is however assumed the newly added chest is still empty.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                chestLocator        - (URL) locating the created chest (in this enterprise)

        Parameters:
            chestData               - (table) data to the chest
                location            - (table) location of the chest
                accessDirection     - (string) whether to access chest from "bottom", "top", "left", "right", "front" or "back" (relative to location)
    --]]

    -- check input
    if type(chestData) ~= "table" then corelog.Error("enterprise_chests.RegisterChest_SSrv: Invalid chestData") return {success = false} end
    local location = chestData.location
    if type(location) ~= "table" then corelog.Error("enterprise_chests.RegisterChest_SSrv: Invalid location") return {success = false} end
    local accessDirection = chestData.accessDirection
    if type(accessDirection) ~= "string" then corelog.Error("enterprise_chests.RegisterChest_SSrv: Invalid accessDirection") return {success = false} end

    -- create new chest
    local chest = {
        id              = coreutils.NewId(),

        location        = coremove.CopyLocation(location),
        accessDirection = accessDirection,

        inventory = { -- assumed to be empty
            slots   = {},
            items   = {},
        },
    }

    -- ensure enterprise has a key in the dht
    if coredht.GetData(db.dhtRoot) == nil then -- ToDo: consider putting elsewhere
        -- create the entry
        coredht.SaveData({}, db.dhtRoot)
        coredht.SaveData({}, db.dhtRoot, db.dhtChests)
    end

    -- save the chest
    corelog.WriteToLog(">Registering chest "..chest.id..".")
    coredht.SaveData(chest, db.dhtRoot, db.dhtChests, chest.id)

    -- end
    local result = {
        success = true,
        chestLocator = GetChestLocator(chest.id)
    }
    return result
end

function DelistChest_ASrv(serviceData, callback, callbackData)
    --[[
        This async public service delists ("removes") a chest from the enterprise. Delisting implies
            - the chest is immediatly no longer available for new business (e.g. adding/ removing items)
            - wait for all active work on chest to be ended
            - remove the chest from the enterprise 

        Note that the chest (and it's possibly remaining items) are not removed from the world.

        Return value:
            nil 

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the service executed successfully

        Parameters:
            serviceData         - (table) data about the service
                chestLocator    - (URL) locating the chest
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_chests.DelistChest_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local chestLocator = url.URLClass:new(serviceData.chestLocator)
    if type(chestLocator) ~= "table" then corelog.Error("enterprise_chests.DelistChest_ASrv: Invalid chestLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_chests.DelistChest_ASrv: Invalid callback") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- get the chest
    local chest = GetChestByLocator(chestLocator)
    if type(chest) ~="table" then corelog.Error("enterprise_chests.DelistChest_ASrv: Failed retrieving chest = "..chestLocator:getURI()) return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- stop doing business for this chest
    -- ToDo: implement

    -- wait for active work done
    -- ToDo: implement

    -- remove site from enteprise
    corelog.WriteToLog(">Delisting chest "..chest.id)
    coredht.SaveData(nil, db.dhtRoot, db.dhtChests, chest.id)

    -- do callback
    coreutils.DoCallback(callback, callbackData, {success = true})
end

function UpdateChestRecord_ASrv(serviceData, callback, callbackData)
    --[[
        This async public service brings the records of a chest up-to-date by fetching parameters and (re)setting the chest records.

        Using this method should normally not be needed as the records should be kept up-to-date by the various enterprise services. It could              
        typically be used for development purposes or, if for some reason (e.g. after a turtle crash), the chest records could have been corrupted.

        Return value:
            nil 

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the service executed successfully

        Parameters:
            serviceData         - (table) data about the service
                chestLocator    - (URL) locating the chest
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_chests.UpdateChestRecord_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local chestLocator = url.URLClass:new(serviceData.chestLocator)
    if type(chestLocator) ~= "table" then corelog.Error("enterprise_chests.UpdateChestRecord_ASrv: Invalid chestLocator") return {success = false} end
    if type(callback) ~= "string" then corelog.Error("enterprise_chests.UpdateChestRecord_ASrv: Invalid callback") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- get chest id
    local id = GetChestId(chestLocator)

    -- create project definition
    local updateChestRecordsProjectDef = {
        steps   = {
            { stepName = "enterprise_chests.FetchChestSlotsInventory_ASrv", async = true, stepDataDef = {
                { keyDef = "id"         , valueSource = 0, keyDefSource = "id" },
            }},
            { stepName = "enterprise_chests.SetChestRecord_SSrv", async = false, stepDataDef = {
                { keyDef = "id"         , valueSource = 0, keyDefSource = "id" },
                { keyDef = "slots"      , valueSource = 1, keyDefSource = "slots" },
            }},
            { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                { keyDef = "success1"   , valueSource = 1, keyDefSource = "success" },
                { keyDef = "success2"   , valueSource = 2, keyDefSource = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"        , valueSource = 3, keyDefSource = "success" },
        }
    }
    local projectData = {
        id = id,
    }
    local projectServiceData = {
        projectDef  = updateChestRecordsProjectDef,
        projectData = projectData,
    }

    -- start project
    corelog.WriteToLog(">Updating records for chest "..projectData.id..".")
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function ItemsAvailableVia_SSrv(queryData)
    --[[
        This sync public service queries a Supplier for the availability of items. The Supplier and query are specified by the "base" (i.e. "ccwprp://host:port/path")
        and "query" component (i.e. `?itemName=itemCount`) of an URL.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully

        Parameters:
            queryData               - (table) data about the query
                itemsLocator        - (URL) locating the items that need to be queried for availability
                                        (the "base" component of the URL specifies the Supplier that provides the items)
                                        (the "query" component of the URL specifies the items to query for)
    --]]

    -- check input
    if type(queryData) ~= "table" then corelog.Error("enterprise_chests.ItemsAvailableVia_SSrv: Invalid queryData") return {success = false} end
    local itemsLocator = url.URLClass:new(queryData.itemsLocator)
    if type(itemsLocator) ~= "table" then corelog.Error("enterprise_chests.ItemsAvailableVia_SSrv: Invalid itemsLocator") return {success = false} end

    -- check itemsLocator is for this enterprise
    local serviceResults = IsChestURL_QSrv({ aURL = itemsLocator})
    if not serviceResults.success then corelog.Error("enterprise_chests.ItemsAvailableVia_SSrv: Invalid itemsLocator (="..itemsLocator:getURI()..").") return {success = false} end

    -- get chest
    local chest = GetChestByLocator(itemsLocator)
    if type(chest) ~= "table" then corelog.Error("enterprise_chests.ItemsAvailableVia_SSrv: Chest "..itemsLocator:getURI().." not found.") return {success = false} end

    -- query chests inventory
    local query = itemsLocator:getQuery()     -- e.g. {"minecraft:torch"=5, "minecraft:birch_log"=3}
    local inventory = chest.inventory
    for itemName, itemCount in pairs(query) do
        if type(itemName) ~= "string" then corelog.Error("enterprise_chests.ItemsAvailableVia_SSrv: itemName of wrong type = "..type(itemName)..".") return {success = false} end
        if type(itemCount) ~= "number" then corelog.Error("enterprise_chests.ItemsAvailableVia_SSrv: itemCount of wrong type = "..type(itemCount)..".") return {success = false} end

        local inventoryCount = inventory.items[itemName]
        if inventoryCount == nil or inventoryCount < itemCount then
            corelog.WriteToLog("enterprise_chests.ItemsAvailableVia_SSrv: not enough (="..itemCount..") "..itemName.." items in inventory (="..(inventoryCount or 0)..") of chest "..chest.id..".") return {success = false}
        end
    end

    -- end
    return {
        success     = true,
    }
end

function ProvideItemsTo_ASrv(serviceData, callback, callbackData)
    --[[
        This async public Supplier service provides specific items to a Storage.

        Return value:
            nil

        Async service return value (to callback):
                                            - (table)
                success                     - (boolean) whether the service executed correctly
                destinationItemsLocator     - (URL) locating the final Storage and the items that where transferred to it
                                                (upon service succes the "host" component of this URL should be equal to destinationHostLocator, and
                                                the "query" should be equal to orderItems)

        Parameters:
            serviceData                     - (table) data for the service
                itemsLocator                - (URL) locating the items to provide
                                                (the "base" component of the URL specifies the Supplier that provides the items)
                                                (the "query" component of the URL specifies the items)
                storageLocator              - (URL) locating the Storage where the items need to be provided to
                ingredientsSupplierLocator  - (URL) locating where the production ingredients can be retrieved
                assignmentsPriorityKey      - (string) priorityKey that should be set for all assignments triggered by this service
            callback                        - (string) name of function to call once service is ready
            callbackData                    - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_chests.ProvideItemsTo_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local itemsLocator = url.URLClass:new(serviceData.itemsLocator)
    if type(itemsLocator) ~= "table" then corelog.Error("enterprise_chests.ProvideItemsTo_ASrv: Invalid itemsLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local storageLocator = url.URLClass:new(serviceData.storageLocator)
    if type(storageLocator) ~= "table" then corelog.Error("enterprise_chests.ProvideItemsTo_ASrv: Invalid storageLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = serviceData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_chests.ProvideItemsTo_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_chests.ProvideItemsTo_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- check itemsLocator is for this enterprise
    local serviceResults = IsChestURL_QSrv({ aURL = itemsLocator})
    if not serviceResults.success then corelog.Error("enterprise_chests.ProvideItemsTo_ASrv: Invalid itemsLocator (="..itemsLocator:getURI()..").") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- transfer using TransferItemsFromTo_ASrv
    local transferData = {
        sourceItemsLocator          = itemsLocator,
        destinationStorageLocator   = storageLocator,
        assignmentsPriorityKey      = assignmentsPriorityKey,
    }
    corelog.WriteToLog(">Transfer "..itemsLocator:getURI().." from Chest")
    return enterprise_isp.TransferItemsFromTo_ASrv(transferData, callback, callbackData)
end

function NeedsTo_ProvideItemsTo_SSrv(serviceData)
    --[[
        This sync public service returns the needs for the Supplier to provide specific items to a Storage.
        
        Return value:
                                            - (table)
                success                     - (boolean) whether the service executed correctly
                fuelNeed                    - (number) amount of fuel needed to provide items
                ingredientsNeed             - (table) ingredients needed to provide items

        Parameters:
            serviceData                     - (table) data to the query
                itemsLocator                - (URL) locating the items to provide
                                                (the "base" component of the URL specifies the Supplier that provides the items)
                                                (the "query" component of the URL specifies the items)
                storageLocator              - (URL) locating the Storage where the items need to be provided to

                ingredientsSupplierLocator  - (URL) locating where ingredients can be retrieved
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_chests.NeedsTo_ProvideItemsTo_SSrv: Invalid serviceData") return {success = false} end
    local itemsLocator = url.URLClass:new(serviceData.itemsLocator)
    if type(itemsLocator) ~= "table" then corelog.Error("enterprise_chests.NeedsTo_ProvideItemsTo_SSrv: Invalid itemsLocator") return {success = false} end
    local storageLocator = url.URLClass:new(serviceData.storageLocator)
    if type(storageLocator) ~= "table" then corelog.Error("enterprise_chests.NeedsTo_ProvideItemsTo_SSrv: Invalid storageLocator") return {success = false} end

    -- get chest location
    local serviceResults = GetItemsLocations_SSrv({ itemsLocator = itemsLocator })
    if not serviceResults.success then corelog.Error("enterprise_chests.NeedsTo_ProvideItemsTo_SSrv: failed obtaining location of chest "..type(itemsLocator)..".") return {success = false} end
    local k, chestLocation = next(serviceResults.locations, nil)

    -- loop on items
    local fuelNeed = 0
    local supplyItems = itemsLocator:getQuery()
    for itemName, itemCount in pairs(supplyItems) do
        -- check
        if type(itemName) ~= "string" then corelog.Error("enterprise_chests.NeedsTo_ProvideItemsTo_SSrv: Invalid itemName (type="..type(itemName)..")") return {success = false} end
        if type(itemCount) ~= "number" then corelog.Error("enterprise_chests.NeedsTo_ProvideItemsTo_SSrv: Invalid itemCount (type="..type(itemCount)..")") return {success = false} end

        -- fuelNeed from chest to storageLocator
        serviceData = {
            storageLocator  = storageLocator,
        }
        serviceResults =  enterprise_isp.GetStorageLocation_SSrv(serviceData)
        if not serviceResults.success then corelog.Error("enterprise_chests.NeedsTo_ProvideItemsTo_SSrv: failed obtaining location for Storage "..type(storageLocator)..".") return {success = false} end
        -- ToDo: consider how to handle if path isn't the shortest route, should we maybe modify things to do something like GetTravelDistanceBetween
        local fromChestToStorageFuelNeed = coreinventory.NeededFuelToFrom(serviceResults.location, chestLocation)

        -- add fuelNeed
        corelog.WriteToLog("C  fromChestToStorageFuelNeed="..fromChestToStorageFuelNeed)
        fuelNeed = fuelNeed + fromChestToStorageFuelNeed
    end

    -- end
    local ingredientsNeed = {}
    return {
        success         = true,
        fuelNeed        = fuelNeed,
        ingredientsNeed = ingredientsNeed,
    }
end

function GetItemsLocations_SSrv(serviceData)
    --[[
        This sync public service provides the current world locations of different items in a Storage.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                locations           - (table) with locations of the different items

        Parameters:
            serviceData             - (table) data about this service
                itemsLocator        - (URL) locating the items for which to get the location
                                        (the "base" component of the URL specifies the Storage that provides the items)
                                        (the "query" component of the URL specifies the items)
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_chests.GetItemsLocations_SSrv: Invalid serviceData") return {success = false} end
    local itemsLocator = url.URLClass:new(serviceData.itemsLocator)
    if type(itemsLocator) ~= "table" then corelog.Error("enterprise_chests.GetItemsLocations_SSrv: Invalid itemsLocator") return {success = false} end

    -- get location
    local serviceResults = GetStorageLocation_SSrv({ storageLocator = itemsLocator})
    if not serviceResults.success then corelog.Error("enterprise_chests.GetItemsLocations_SSrv: failed obtaining location for Storage "..itemsLocator:getURI()..".") return {success = false} end
    local location = serviceResults.location

    -- end
    return {
        success     = true,
        locations   = { coremove.CopyLocation(location) },
    }
end

function GetStorageLocation_SSrv(serviceData)
    --[[
        This sync public service provides the world location of a Storage.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                location            - (table) location of the Storage

        Parameters:
            serviceData             - (table) data about this service
                storageLocator      - (URL) locating the Storage for which to get the location
                                        (the "base" component of the URL should specify this Storage enterprise)
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_chests.GetStorageLocation_SSrv: Invalid serviceData") return {success = false} end
    local storageLocator = url.URLClass:new(serviceData.storageLocator)
    if type(storageLocator) ~= "table" then corelog.Error("enterprise_chests.GetStorageLocation_SSrv: Invalid storageLocator") return {success = false} end

    -- check storageLocator is for this enterprise
    local serviceResults = IsChestURL_QSrv({ aURL = storageLocator})
    if not serviceResults.success then corelog.Error("enterprise_chests.GetStorageLocation_SSrv: Invalid storageLocator (="..storageLocator:getURI()..").") return {success = false} end

    -- get chest
    local chest = GetChestByLocator(storageLocator)
    if type(chest) ~= "table" then corelog.Error("enterprise_chests.GetStorageLocation_SSrv: Chest "..storageLocator:getURI().." not found.") return {success = false} end

    -- get location
    local location = chest.location

    -- end
    return {
        success     = true,
        location    = coremove.CopyLocation(location),
    }
end

function GetItemsIntoTurtle_ASrv(transferData, callback, callbackData)
    --[[
        This async public service ensures items are gathered in the Supplier and transferred to the inventory of a turtle.

        Return value:
            nil 

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                turtleItemsLocator      - (URL) locating a specific turtle and the items it has gotton in it's inventory

        Parameters:
            transferData                - (table) data about the transfer
                sourceItemsLocator      - (URL) locating the items that need transfer
                                            (the "query" component of the URL specifies the items to be transferred)
                                            (the "host" component of the URL should specify this host (i.e. a chest) where the items are located)
                assignmentsPriorityKey  - (string) priorityKey that should be set for all assignments triggered by this service
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function                                                
    --]]

    -- check input
    if type(transferData) ~= "table" then corelog.Error("enterprise_chests.GetItemsIntoTurtle_ASrv: Invalid transferData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local sourceItemsLocator = url.URLClass:new(transferData.sourceItemsLocator)
    if type(sourceItemsLocator) ~= "table" then corelog.Error("enterprise_chests.GetItemsIntoTurtle_ASrv: Invalid sourceItemsLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = transferData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_chests.GetItemsIntoTurtle_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_chests.GetItemsIntoTurtle_ASrv: Invalid callback") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- check source is for this enterprise
    local serviceResults = IsChestURL_QSrv({ aURL = sourceItemsLocator})
    if not serviceResults.success then corelog.Error("enterprise_chests.GetItemsIntoTurtle_ASrv: Invalid sourceURL (="..sourceItemsLocator:getURI()..").") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- get id
    local id = GetChestId(sourceItemsLocator)
    if type(id) ~= "string" then corelog.Error("enterprise_chests.GetItemsIntoTurtle_ASrv: Invalid path input: "..textutils.serialize(sourceItemsLocator:getPath())..".") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- create project definition
    local getItemsIntoTurtleProjectDef = {
        steps   = {
            { stepName = "enterprise_chests.FetchItemsFromChestIntoTurtle_ASrv", async = true, stepDataDef = {
                { keyDef = "id"                     , valueSource = 0, keyDefSource = "id" },
                { keyDef = "itemsQuery"             , valueSource = 0, keyDefSource = "itemsQuery" },
                { keyDef = "assignmentsPriorityKey" , valueSource = 0, keyDefSource = "assignmentsPriorityKey" },
            }},
            { stepName = "enterprise_turtle.GetItemsLocator_SSrv", async = false, stepDataDef = {
                { keyDef = "turtleId"               , valueSource = 1, keyDefSource = "turtleId" },
                { keyDef = "itemsQuery"             , valueSource = 1, keyDefSource = "itemResultQuery" },
            }},
            { stepName = "enterprise_chests.SetChestRecord_SSrv", async = false, stepDataDef = {
                { keyDef = "id"                     , valueSource = 0, keyDefSource = "id" },
                { keyDef = "slots"                  , valueSource = 1, keyDefSource = "slots" },
            }},
            { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                { keyDef = "success1"               , valueSource = 1, keyDefSource = "success" },
                { keyDef = "success2"               , valueSource = 2, keyDefSource = "success" },
                { keyDef = "success3"               , valueSource = 3, keyDefSource = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , valueSource = 4, keyDefSource = "success" },
            { keyDef = "turtleItemsLocator"         , valueSource = 2, keyDefSource = "itemsLocator" },
        }
    }
    local projectData = {
        id                      = id,
        itemsQuery              = sourceItemsLocator:getQuery(),

        assignmentsPriorityKey  = assignmentsPriorityKey,
    }
    local projectServiceData = {
        projectDef  = getItemsIntoTurtleProjectDef,
        projectData = projectData,
    }

    -- start project
--    corelog.WriteToLog(">Getting "..sourceItemsLocator:getQueryURI().." from chest "..id.." into a turtle.")
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function PutItemsFromTurtle_ASrv(transferData, callback, callbackData)
    --[[
        This async public service ensures items are transferred from the inventory of a turtle towards the Storage.

        A Storage should take special care the transfer from the turtle inventory gets priority over other assignments to the turtle.

        Return value:
            nil 

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                destinationItemsLocator - (URL) stating the final Storage and the items that where transferred to it
                                            (upon service succes the "host" component of this URL should be equal to destinationHostLocator, 
                                            the "path" should be a specific chest, and the "query" should be equal to the "query" component of the turtleItemsLocator)

        Parameters:
            transferData                - (table) data about the transfer
                turtleItemsLocator      - (URL) stating a specific turtle and the items in it's inventory that need to be put
                destinationHostLocator  - (URL) stating where the items need to be transferred to (i.e. a chest in this host)
                assignmentsPriorityKey  - (string) priorityKey that should be set for all assignments triggered by this service
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function                                                
    --]]

    -- check input
    if type(transferData) ~= "table" then corelog.Error("enterprise_chests.PutItemsFromTurtle_ASrv: Invalid transferData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local turtleItemsLocator = url.URLClass:new(transferData.turtleItemsLocator)
    if type(turtleItemsLocator) ~= "table" then corelog.Error("enterprise_chests.PutItemsFromTurtle_ASrv: Invalid turtleItemsLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local destinationHostLocator = url.URLClass:new(transferData.destinationHostLocator)
    if type(destinationHostLocator) ~= "table" then corelog.Error("enterprise_chests.PutItemsFromTurtle_ASrv: Invalid destinationHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = transferData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_chests.PutItemsFromTurtle_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_chests.PutItemsFromTurtle_ASrv: Invalid callback") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- check destination is for this enterprise (i.e. a chest)
    local serviceResults = IsChestURL_QSrv({ aURL = destinationHostLocator})
    if not serviceResults.success then corelog.Error("enterprise_chests.PutItemsFromTurtle_ASrv: Invalid destination host (="..destinationHostLocator:getURI()..").") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- get id
    local id = GetChestId(destinationHostLocator)
    if type(id) ~= "string" then corelog.Error("enterprise_chests.PutItemsFromTurtle_ASrv: Invalid path input: "..textutils.serialize(destinationHostLocator:getPath())..".") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- set (expected) destinationItemsLocator
    local destinationItemsLocator = url.URLClass:new(destinationHostLocator)
    destinationItemsLocator:setQuery(coreutils.DeepCopy(turtleItemsLocator:getQuery()))

    -- create project definition
    local putItemsIntoChestProjectDef = {
        steps   = {
            { stepName = "enterprise_chests.PutItemsFromTurtleIntoChest_ASrv", async = true, stepDataDef = {
                { keyDef = "id"                     , valueSource = 0, keyDefSource = "id" },
                { keyDef = "turtleItemsLocator"     , valueSource = 0, keyDefSource = "turtleItemsLocator" },
                { keyDef = "assignmentsPriorityKey" , valueSource = 0, keyDefSource = "assignmentsPriorityKey" },
            }},
            { stepName = "enterprise_chests.SetChestRecord_SSrv", async = false, stepDataDef = {
                { keyDef = "id"                     , valueSource = 0, keyDefSource = "id" },
                { keyDef = "slots"                  , valueSource = 1, keyDefSource = "slots" },
            }},
            { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                { keyDef = "success1"               , valueSource = 1, keyDefSource = "success" },
                { keyDef = "success2"               , valueSource = 2, keyDefSource = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , valueSource = 3, keyDefSource = "success" },
            { keyDef = "destinationItemsLocator"    , valueSource = 0, keyDefSource = "destinationItemsLocator" },
        }
    }
    local projectData = {
        id                      = id,
        turtleItemsLocator      = turtleItemsLocator,
        destinationItemsLocator = destinationItemsLocator,

        assignmentsPriorityKey  = assignmentsPriorityKey,
    }
    local projectServiceData = {
        projectDef  = putItemsIntoChestProjectDef,
        projectData = projectData,
    }

    -- start project
--    corelog.WriteToLog(">Putting items from turtle URL "..turtleItemsLocator:getURI().." into chest "..projectData.id..".")
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function DeleteChests()
    local chests = coredht.GetData(db.dhtRoot, db.dhtChests)
    if not chests or type(chests) ~= "table" then corelog.Warning("coreassignment.DeleteChests: chests not valid") return nil end

    -- remove all
--    corelog.Warning("All chests are being deleted!")
    for id, chest in pairs(chests) do
        -- remove
        corelog.Warning("  deleting chest "..id)
        coredht.SaveData(nil, db.dhtRoot, db.dhtChests, id)
    end
end

function GetChestByLocator(chestLocator)
    -- chest ophalen
    local chestId = GetChestId(chestLocator)
    local chest = GetChestById(chestId)

    -- end
    return chest
end

function GetChestById(id)
    -- chest ophalen
    local chest = coredht.GetData(db.dhtRoot, db.dhtChests, id)
    if type(chest) ~= "table" then corelog.Warning("enterprise_chests.GetChestById: chest "..id.."not found") return nil end

    -- end
    return chest
end

function GetChestId(chestLocator)
    --[[
        This private function provides the internal id of a chest.

        Return value:
            id                      - (string) id of the chest

        Parameters:
            chestLocator            - (URL) locating a chest
    --]]

    -- check input
    if type(chestLocator) ~= "table" then corelog.Error("enterprise_chests.GetChestId: Invalid chestLocator") return nil end

    -- get id
    local chestURL = url.URLClass:new(chestLocator)
    local id = chestURL:getPath().id

    -- end
    return id
end

function GetISHURL()
    --[[
        This private function provides the (base) URL of this ISH.

        Return value:
            hostURL                 - (URL) locating this ISH

        Parameters:
            nil
    --]]

    local hostURL = url.URLClass:new()
    hostURL:setHost(db.hostName)

    return hostURL
end

function GetChestLocator(id)
    --[[
        This private function provides the URL of a chest based on the internal id in this ISH.

        Return value:
            chestLocator            - (URL) locating a chest

        Parameters:
            id                      - (string) id of the chest
    --]]

    -- check input
    if type(id) ~= "string" then corelog.Error("enterprise_chests.GetChestLocator: Invalid id") return nil end

    -- construct URL
    local chestURL = GetISHURL()
    chestURL:setPath({id = id})

    -- end
    return chestURL
end

function SetChestRecord_SSrv(serviceData)
    --[[
        This sync private service sets a chest record based on (already obtained) parameters (like e.g. the slots inventory). 
        
        Return value:
                                - (table)
                success         - (boolean) whether the service executed successfully

        Parameters:
            serviceData         - (table) data for this service
                id              - (string) id of the chest.
                slots           - (table) slots inventory of the chest.
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_chests.SetChestRecord_SSrv: Invalid serviceData") return {success = false} end
    local id = serviceData.id
    if type(id) ~= "string" then corelog.Error("enterprise_chests.SetChestRecord_SSrv: Invalid id") return {success = false} end
    local slots = serviceData.slots
    if type(slots) ~= "table" then corelog.Error("enterprise_chests.SetChestRecord_SSrv: Invalid slots") return {success = false} end

    -- get the chest
    local chest = GetChestById(id)
    if type(chest) ~="table" then corelog.Error("enterprise_chests.SetChestRecord_SSrv: Failed retrieving chest for id = "..id) return {success = false} end

    -- determine items inventory
    local inventory = DetermineInventory(slots)

    -- set record
    chest.inventory = inventory

    -- save record
    coredht.SaveData(chest, db.dhtRoot, db.dhtChests, chest.id)

    -- end
    return {success = true}
end

function DetermineInventory(slots)
    -- construct inventory
    local inventory = {
        slots   = slots, -- ToDo: consider deep copy
        items   = role_chests_worker.DetermineItemsInventory(slots),
    }

    -- end
    return inventory
end

function FetchChestSlotsInventory_ASrv(serviceData, callback, callbackData)
    --[[
        This async private service fetches the slots inventory from a chest. 
        
        Return value:
            nil 

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the service executed successfully
                slots           - (table) the slots inventory of a chest

        Parameters:
            serviceData         - (table) data about the service
                id              - (string) id of the chest.
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_chests.FetchChestSlotsInventory_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local id = serviceData.id
    if type(id) ~= "string" then corelog.Error("enterprise_chests.FetchChestSlotsInventory_ASrv: Invalid id") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_chests.FetchChestSlotsInventory_ASrv: Invalid callback") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- get the chest
    local chest = GetChestById(id)
    if type(chest) ~="table" then corelog.Error("enterprise_chests.FetchChestSlotsInventory_ASrv: Failed retrieving chest for id = "..id) return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- fetch with an assignment
    local taskData = {
        location = coremove.CopyLocation(chest.location),
        accessDirection = chest.accessDirection,
    }
    local metaData = role_chests_worker.FetchChestSlotsInventory_MetaData(taskData)
    coreassignment.AddAssignment(metaData, "role_chests_worker.FetchChestSlotsInventory_Task", taskData, callback, callbackData)
end

function FetchItemsFromChestIntoTurtle_ASrv(serviceData, callback, callbackData)
    --[[
        This async private service fetches items from a chest into the inventory of a turtle.
        
        Return value:
            nil 

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                slots                   - (table) the slots inventory of the chest (after the items have been removed)
                turtleURL               - (table) a URL stating the turtle and the items it has gotton in it's inventory

        Parameters:
            serviceData                 - (table) data about the service
                id                      - (string) id of the chest.
                itemsQuery              - (table) with items to be fetched
                assignmentsPriorityKey  - (string) priorityKey that should be set for all assignments triggered by this service
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_chests.FetchItemsFromChestIntoTurtle_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local id = serviceData.id
    if type(id) ~= "string" then corelog.Error("enterprise_chests.FetchItemsFromChestIntoTurtle_ASrv: Invalid id") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local itemsQuery = serviceData.itemsQuery
    if type(itemsQuery) ~= "table" then corelog.Error("enterprise_chests.FetchItemsFromChestIntoTurtle_ASrv: Invalid itemsQuery") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = serviceData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_chests.FetchItemsFromChestIntoTurtle_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_chests.FetchItemsFromChestIntoTurtle_ASrv: Invalid callback") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- get the chest
    local chest = GetChestById(id)
    if type(chest) ~="table" then corelog.Error("enterprise_chests.FetchItemsFromChestIntoTurtle_ASrv: Failed retrieving chest for id = "..id) return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- fetch with an assignment
    local taskData = {
        location        = coremove.CopyLocation(chest.location),
        accessDirection = chest.accessDirection,
        itemsQuery      = itemsQuery,

        priorityKey     = assignmentsPriorityKey,
    }
    local metaData = role_chests_worker.FetchItemsFromChestIntoTurtle_MetaData(taskData)
    coreassignment.AddAssignment(metaData, "role_chests_worker.FetchItemsFromChestIntoTurtle_Task", taskData, callback, callbackData)
end

function PutItemsFromTurtleIntoChest_ASrv(serviceData, callback, callbackData)
    --[[
        This async private service puts items from a the inventory of a turtle into a chest.
        
        Return value:
            nil 

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                slots                   - (table) the slots inventory of the chest (after the items have been put)

        Parameters:
            serviceData                 - (table) data about the service
                turtleItemsLocator      - (URL) stating a specific turtle and the items in it's inventory that need to be put
                id                      - (string) id of the chest
                assignmentsPriorityKey  - (string) priorityKey that should be set for all assignments triggered by this service
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_chests.PutItemsFromTurtleIntoChest_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local turtleItemsLocator = url.URLClass:new(serviceData.turtleItemsLocator)
    if type(turtleItemsLocator) ~= "table" then corelog.Error("enterprise_chests.PutItemsFromTurtleIntoChest_ASrv: Invalid turtleItemsLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local id = serviceData.id
    if type(id) ~= "string" then corelog.Error("enterprise_chests.PutItemsFromTurtleIntoChest_ASrv: Invalid id") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = serviceData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_chests.PutItemsFromTurtleIntoChest_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_chests.PutItemsFromTurtleIntoChest_ASrv: Invalid callback") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- check source is a turtle
    local serviceResults = enterprise_turtle.IsTurtleURL_QSrv({ aURL = turtleItemsLocator})
    if not serviceResults.success then corelog.Error("enterprise_chests.PutItemsFromTurtleIntoChest_ASrv: Invalid turtle source URL (="..turtleItemsLocator:getURI()..").") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- get the chest
    local chest = GetChestById(id)
    if type(chest) ~="table" then corelog.Error("enterprise_chests.PutItemsFromTurtleIntoChest_ASrv: Failed retrieving chest for serviceData = "..textutils.serialise(serviceData)) return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- put with an assignment
    local taskData = {
        turtleId        = turtleItemsLocator:getPort(),
        itemsQuery      = coreutils.DeepCopy(turtleItemsLocator:getQuery()),
        location        = coremove.CopyLocation(chest.location),
        accessDirection = chest.accessDirection,

        priorityKey     = assignmentsPriorityKey,
    }
    local metaData = role_chests_worker.PutItemsFromTurtleIntoChest_MetaData(taskData)
    coreassignment.AddAssignment(metaData, "role_chests_worker.PutItemsFromTurtleIntoChest_Task", taskData, callback, callbackData)
end
