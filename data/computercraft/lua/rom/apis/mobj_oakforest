
--[[
    This file implements mobj_oakforest.

    Note that the syntax used is such that it (prepares for) a more object oriented Lua approach. See more from here https://www.lua.org/pil/16.html .
--]]

OakForestClass = {
    _id                     = "",
    _level                  = 0,

    _location               = nil,
    _nTrees                 = 0,

    _localLogsLocator       = nil,
    _localSaplingsLocator   = nil,
}

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function OakForestClass:new(o)
    --[[
        Constructs a mobj_oakforest.

        Parameters:
                                        - (table) table with
                _id                     - (string) id of the forest
                _level                  - (number) level of the forest
                _location               - (table) base location of the forest
                _nTrees                 - (string) # trees in the forest
                _localLogsLocator       - (URL) locating the local Supplier of logs (e.g. a chest)
                _localSaplingsLocator   - (URL) locating the local Supplier of saplings (e.g. a chest)
    --]]

    o = o or {}   -- create object if user does not provide one
    setmetatable(o, self)
    self.__index = self
    return o
end

--[[
function OakForestClass:newFromURI(uri)
    local aNewURL = OakForestClass:new()

    aNewURL:setURI(uri)

    return aNewURL
end
]]

function OakForestClass:getId()
    return self._id
end

function OakForestClass:getLevel()
    return self._level
end

function OakForestClass:setLevel(level)
    -- check input
    if type(level) ~= "number" then corelog.Error("mobj_oakforest:setLevel: invalid level: "..type(level)) return end

    self._level = level
end

function OakForestClass:getLocation()
    return self._location
end

function OakForestClass:setLocation(location)
    -- check input
    if type(location) ~= "table" then corelog.Error("mobj_oakforest:setLocation: invalid location: "..type(location)) return end

    self._location = location
end

function OakForestClass:getNTrees()
    return self._nTrees
end

function OakForestClass:setNTrees(nTrees)
    -- check input
    if type(nTrees) ~= "number" then corelog.Error("mobj_oakforest:setNTrees: invalid # trees: "..type(nTrees)) return end

    self._nTrees = nTrees
end

function OakForestClass:getLocalLogsLocator()
    return self._localLogsLocator
end

function OakForestClass:setLocalLogsLocator(localLogsLocator)
    -- check input
    if type(localLogsLocator) ~= "table" then corelog.Error("mobj_oakforest:setLocalLogsLocator: Invalid localLogsLocator "..type(localLogsLocator)) return end

    self._localLogsLocator = localLogsLocator
end

function OakForestClass:getLocalSaplingsLocator()
    return self._localSaplingsLocator
end

function OakForestClass:setLocalSaplingsLocator(localSaplingsLocator)
    -- check input
    if type(localSaplingsLocator) ~= "table" then corelog.Error("mobj_oakforest:setLocalSaplingsLocator: Invalid localLogsLocator "..type(localSaplingsLocator)) return end

    self._localSaplingsLocator = localSaplingsLocator
end

function OakForestClass:copy()
    local forestCopy = OakForestClass:new({
        _id                     = self._id,
        _level                  = self._level,

        _location               = coremove.CopyLocation(self._location),
        _nTrees                 = self._nTrees,

        _localLogsLocator       = self._localLogsLocator:copy(),
        _localSaplingsLocator   = self._localSaplingsLocator:copy(),
    })

    return forestCopy
end

function OakForestClass:sameId(forest)
    return self:getId() == forest:getId()
end

function OakForestClass:sameLevel(forest)
    return self:getLevel() == forest:getLevel()
end

function OakForestClass:sameLocation(forest)
    local loc1 = self:getLocation()
    local loc2 = forest:getLocation()

    return coremove.IsSameLocation(loc1, loc2) and coremove.IsSameDirection(loc1, loc2)
end

function OakForestClass:sameNTrees(forest)
    return self:getNTrees() == forest:getNTrees()
end

function OakForestClass:getFuelNeed_Harvest_Att()
    --[[
        Forest attribute with the current fuelNeed to do one harvesting round.
    --]]

    -- determine fuelNeed
    local nTrees = self:getNTrees()
    local fuelNeed = role_forester.FuelNeededPerRound(nTrees)

    -- end
    return fuelNeed
end

function OakForestClass:getFuelNeedExtraTree_Att()
    --[[
        Forest attribute with the fuelNeed for harvesting one extra tree.
        (i.e. it return the difference between the current getFuelNeed_Harvest_Att and the getFuelNeed_Harvest_Att if there would be 1 extra tree)
    --]]

    -- determine fuelNeed
    local nTrees = self:getNTrees()
    local fuelNeed_Current = role_forester.FuelNeededPerRound(nTrees)
    local fuelNeed_OneTreeExtra = role_forester.FuelNeededPerRound(nTrees + 1)

    -- end
    return fuelNeed_OneTreeExtra - fuelNeed_Current
end

function OakForestClass:needsTo_ProvideItemsTo_SSrv(...)
    -- get & check input from description
    local checkSuccess, provideItems, storageLocator = coreutils.CheckInput([[
        This sync public service returns the needs for the Supplier to provide specific items to a Storage.

        Return value:
                                            - (table)
                success                     - (boolean) whether the service executed correctly
                fuelNeed                    - (number) amount of fuel needed to provide items
                ingredientsNeed             - (table) ingredients needed to provide items

        Parameters:
            serviceData                     - (table) data to the query
                provideItems                + (table) with one or more items (formatted as an array of [itemName] = itemCount key-value pairs) to provide
                storageLocator              + (URL) locating the Storage where the items need to be provided to
                ingredientsSupplierLocator  - (URL, nil) locating where ingredients can be retrieved
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("mobj_oakforest:needsTo_ProvideItemsTo_SSrv: Invalid input") return {success = false} end

    -- loop on items
    local fuelNeed = 0
    local ingredientsNeed = {} -- ToDo ? should we add saplings for a harvest round here?
    local nTrees = self:getNTrees()
    for itemName, itemCount in pairs(provideItems) do
        -- check
        if type(itemName) ~= "string" then corelog.Error("mobj_oakforest:needsTo_ProvideItemsTo_SSrv: Invalid itemName (type="..type(itemName)..")") return {success = false} end
        if type(itemCount) ~= "number" then corelog.Error("mobj_oakforest:needsTo_ProvideItemsTo_SSrv: Invalid itemCount (type="..type(itemCount)..")") return {success = false} end

        -- check for birchlog or sapling
        local itemPerRound = 1
        local localSupplierLocator = nil
        if itemName == "minecraft:birch_log" then
            itemPerRound = 5 * nTrees -- using minimum birch_log per tree (based on data in birchgrow.xlsx)
            localSupplierLocator = self:getLocalLogsLocator()
        elseif itemName == "minecraft:birch_sapling" then
            itemPerRound = 1.4 * nTrees -- using average birch_sapling per tree (based on data in birchgrow.xlsx)
            -- ToDo: consider some safety margin for small forests as average ~= minimum (minimum = -1 in 9% of the cases)
            localSupplierLocator = self:getLocalSaplingsLocator()
        else
            return corelog.Error("mobj_oakforest:needsTo_ProvideItemsTo_SSrv: Provider does not provide "..itemName.."'s") {success = false}
        end

        -- fuelNeed per round
        local fuelPerRound = role_forester.FuelNeededPerRound(nTrees)
        local nRounds = math.ceil(itemCount / itemPerRound)
        local fuelNeed_Rounds = nRounds * fuelPerRound

        -- fuelNeed transfer
        local localSupplierItemsLocator = localSupplierLocator:copy()
        local items = { [itemName] = itemCount }
        localSupplierItemsLocator:setQuery(items)
        local transferData = {
            sourceItemsLocator          = localSupplierItemsLocator,
            destinationStorageLocator   = storageLocator,
        }
        local serviceResults = enterprise_isp.NeedsTo_TransferItems_SSrv(transferData)
        if not serviceResults.success then corelog.Error("mobj_oakforest:needsTo_ProvideItemsTo_SSrv: Failed obtaining transfer needs for "..itemCount.." "..itemName.."'s") return {success = false} end
        local fuelNeed_Transfer = serviceResults.fuelNeed

        -- add fuelNeed
--        corelog.WriteToLog("C  fuelNeed_Rounds="..fuelNeed_Rounds.." (nRounds="..nRounds..", fuelPerRound="..fuelPerRound.."), fuelNeed_Transfer="..fuelNeed_Transfer)
        fuelNeed = fuelNeed + fuelNeed_Rounds + fuelNeed_Transfer
    end

    -- end
    return {
        success         = true,
        fuelNeed        = fuelNeed,
        ingredientsNeed = ingredientsNeed,
    }
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/


