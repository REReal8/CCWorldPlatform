local db = {
    hostName    = "shop",
}

--[[
    The Shop is an enterprise that offers services for ordering items.

    The Shop provides the following services
        OrderItems_ASrv             - procure items and having them delivered at a Storage
        <It is envisioned (but not yet implemented) that a shop can also take/ "purchase" items (i.e. the opposite of ordering).>

    The Shop implements it's services by using services of Supplier enterprises. 

    For an enterprise to be a Supplier it needs to implement the following services:
        ProvideItemsTo_ASrv         - providing multiple instances of a specific item and having them delivered at a Storage
        Can_ProvideItems_QSrv       - whether the Supplier can provide a specific item
        NeedsTo_ProvideItemsTo_SSrv - returning the needs for the Supplier to provide specific items to a Storage

    ToDo: to be made obsolete
        ItemsAvailableVia_SSrv      - providing if a set of items are available at the Supplier. ToDo: this is currently not yet implemented
        GetItemsIntoTurtle_ASrv     - ensuring a set of items are gathered in the Supplier and transferred to the inventory of a turtle.

    The Shop is also a Supplier, hence it also implements these services.

    This allows for the Shop to be passed as ingredientsSupplierLocator to a Supplier. The effect of that is that the Supplier can request 
    the ingredients from the Shop. The Shop than (by a recursive call to the OrderItems service) tries retrieving the ingredients from a Supplier. 
    This recursive order call will result in a successfull items order if the (sub, and sub-sub, etc) ingredients are present and/ or can be provided 
    by a Supplier.
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function OrderItems_ASrv(serviceData, callback, callbackData)
    --[[
        With this async public service items can be ordered at the Shop. This services tries to procure each of the ordered items.
        The Shop ensures the items are delivered to the requested destination.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                destinationItemsLocator - (URL) stating the final Storage and the items that where transferred to it
                                            (upon service succes the "host" component of this URL should be equal to destinationHostLocator, and
                                            the "query" should be equal to orderItems)

        Parameters:
            serviceData                 - (table) data for the service
                orderItems              - (table) with one or more ordered items (formatted as an array of [itemName] = itemCount key-value pairs)
                storageLocator          - (URL) locating the Storage where the items need to be provided to
                assignmentsPriorityKey  - (string) priorityKey that should be set for all assignments triggered by this service
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_shop.OrderItems_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local orderItems = serviceData.orderItems
    if type(orderItems) ~= "table" then corelog.Error("enterprise_shop.OrderItems_ASrv: Invalid orderItems") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local storageLocator = url.URLClass:new(serviceData.storageLocator)
    if type(storageLocator) ~= "table" then corelog.Error("enterprise_shop.OrderItems_ASrv: Invalid storageLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = serviceData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_shop.OrderItems_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_shop.OrderItems_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- set ingredientsSupplierLocator to this enterprise
    local ingredientsSupplierLocator = GetISHURL()

    -- determine projectSteps and projectData
    local projectSteps = {}
    local areAllTrueStepDataDef = {}
    local addItemLocatorsStepDataDef = {}
    local projectData = {}

    -- add project step for each of the ordered items 
    local iStep = 0
    -- ToDo: do this in parallel by extending enterprise_projects to handle parallel project steps.
    for itemName, itemCount in pairs(orderItems) do
        -- step index
        iStep = iStep + 1
        local iStepStr = tostring(iStep)

        -- add crafting step
        local procureItem = "procureItem"..iStepStr
        table.insert(projectSteps,
            { stepName = "enterprise_shop.ProcureItem_ASrv", async = true, stepDataDef = {
                { keyDef = "item"                       , valueSource = 0, keyDefSource = procureItem },
                { keyDef = "storageLocator"             , valueSource = 0, keyDefSource = "storageLocator" },
                { keyDef = "ingredientsSupplierLocator" , valueSource = 0, keyDefSource = "ingredientsSupplierLocator" },
                { keyDef = "assignmentsPriorityKey"     , valueSource = 0, keyDefSource = "assignmentsPriorityKey" },
            }}
        )

        -- add step data
        local item = { [itemName] = itemCount }
        projectData[procureItem] = item

        -- add combine stepDataDef
        table.insert(addItemLocatorsStepDataDef, { keyDef = "itemsLocator"..iStepStr  , valueSource = iStep, keyDefSource = "destinationItemsLocator" })

        -- add success stepDataDef
        table.insert(areAllTrueStepDataDef, { keyDef = "success"..iStepStr  , valueSource = iStep, keyDefSource = "success" })
    end

    -- set remaining projectData
    projectData.storageLocator = storageLocator
    -- ToDo: consider first locally gathering the ordered items and sending them in one go to the storageLocator if all off them are obtained.
    projectData.ingredientsSupplierLocator = ingredientsSupplierLocator
    projectData.assignmentsPriorityKey = assignmentsPriorityKey

    -- add combining URL's
    iStep = iStep + 1
    table.insert(projectSteps,
        { stepName = "enterprise_isp.AddItemsLocators_SSrv", async = false, stepDataDef = addItemLocatorsStepDataDef}
    )
    local iAddItemsLocatorStep = iStep

    -- add check for all a success
    iStep = iStep + 1
    table.insert(projectSteps,
        { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = areAllTrueStepDataDef}
    )
    local iAreAllTrueStep = iStep

    -- create project service data
    local projectDef = {
        steps = projectSteps,
        returnData  = {
            { keyDef = "success"                , valueSource = iAreAllTrueStep, keyDefSource = "success" },
            { keyDef = "destinationItemsLocator", valueSource = iAddItemsLocatorStep, keyDefSource = "itemsLocator" },
        }
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    corelog.WriteToLog(">Providing "..itemsLocator:getURI().."")
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function GetItemsIntoTurtle_ASrv(transferData, callback, callbackData)
    --[[
        This async public service ensures items are gathered in the Supplier and transferred to the inventory of a turtle.

        Return value:
            nil 

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                turtleItemsLocator      - (URL) locating a specific turtle and the items it has gotton in it's inventory

        Parameters:
            transferData                - (table) data about the transfer
                sourceItemsLocator      - (URL) locating the items that need transfer
                                            (the "query" component of the URL specifies the items to be transferred)
                                            (the "host" component of the URL should specify this host (i.e. a chest) where the items are located)                                        
                assignmentsPriorityKey  - (string) priorityKey that should be set for all assignments triggered by this service
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function                                                
    --]]

    -- check input
    if type(transferData) ~= "table" then corelog.Error("enterprise_shop.GetItemsIntoTurtle_ASrv: Invalid transferData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local sourceItemsLocator = url.URLClass:new(transferData.sourceItemsLocator)
    if type(sourceItemsLocator) ~= "table" then corelog.Error("enterprise_shop.GetItemsIntoTurtle_ASrv: Invalid sourceItemsLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = transferData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_shop.GetItemsIntoTurtle_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_shop.GetItemsIntoTurtle_ASrv: Invalid callback") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- check source is for this enterprise
    local serviceResults = IsShopURL_QSrv({ aURL = sourceItemsLocator})
    if not serviceResults.success then corelog.Error("enterprise_shop.GetItemsIntoTurtle_ASrv: Invalid sourceURL (="..sourceItemsLocator:getURI()..").") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- get transferItems
    local transferItems = coreutils.DeepCopy(sourceItemsLocator:getQuery())

    -- implement by ordering from ourself (i.e. the Shop):
    -- create project definition
    local projectDef = {
        steps   = {
            { stepName = "enterprise_shop.OrderItems_ASrv", async = true, stepDataDef = {
                { keyDef = "orderItems"             , valueSource = 0, keyDefSource = "orderItems" },
                { keyDef = "storageLocator"         , valueSource = 0, keyDefSource = "storageLocator" },
                { keyDef = "assignmentsPriorityKey" , valueSource = 0, keyDefSource = "assignmentsPriorityKey" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , valueSource = 1, keyDefSource = "success" },
            { keyDef = "turtleItemsLocator"         , valueSource = 1, keyDefSource = "destinationItemsLocator" },
        }
    }
    local projectData = {
        orderItems              = transferItems,
        storageLocator          = enterprise_turtle.GetHostLocator_SSrv({ }).hostLocator,

        assignmentsPriorityKey  = assignmentsPriorityKey,
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
--    corelog.WriteToLog(">Ordering "..sourceItemsLocator:getQueryURI().." from shop into a turtle.")
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function GetHostLocator_SSrv(serviceData)
    --[[
        This sync public service provides the (base) URL of this ISH.

        Return value:
            hostLocator             - (URL) locating this ISH

        Parameters:
            serviceData             - (table) empty
    --]]

    -- end
    local result = {
        success = true,
        hostLocator = GetISHURL(),
    }
    return result
end

function NeedsTo_ProvideItemsTo_SSrv(serviceData)
    --[[
        This sync public service returns the needs for a Supplier to provide specific items to a Storage.
        
        Return value:
                                            - (table)
                success                     - (boolean) whether the service executed correctly
                fuelNeed                    - (number) amount of fuel needed to provide items
                ingredientsNeed             - (table) ingredients needed to provide items

        Parameters:
            serviceData                     - (table) data to the query
                itemsLocator                - (URL) locating the items to provide
                                                (the "base" component of the URL specifies the Supplier that provides the items)
                                                (the "query" component of the URL specifies the items)
                storageLocator              - (URL) locating the Storage where the items need to be delivered to

                ingredientsSupplierLocator  - (URL) optionally locating another Supplier where needed ingredient items for the Supplier could be retrieved
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_shop.NeedsTo_ProvideItemsTo_SSrv: Invalid serviceData") return {success = false} end
    local itemsLocator = url.URLClass:new(serviceData.itemsLocator)
    if type(itemsLocator) ~= "table" then corelog.Error("enterprise_shop.NeedsTo_ProvideItemsTo_SSrv: Invalid itemsLocator") return {success = false} end
    local storageLocator = url.URLClass:new(serviceData.storageLocator)
    if type(storageLocator) ~= "table" then corelog.Error("enterprise_shop.NeedsTo_ProvideItemsTo_SSrv: Invalid storageLocator") return {success = false} end

    local ingredientsSupplierLocator = url.URLClass:new(serviceData.ingredientsSupplierLocator)
    if type(ingredientsSupplierLocator) ~= "table" then corelog.Error("enterprise_shop.NeedsTo_ProvideItemsTo_SSrv: Invalid ingredientsSupplierLocator") return{success = false} end

    -- loop on items
    local fuelNeed = 0
    local ingredientsNeed = {}
    local items = itemsLocator:getQuery()
    for itemName, itemCount in pairs(items) do
        -- check item
        if type(itemName) ~= "string" then corelog.Error("enterprise_shop.NeedsTo_ProvideItemsTo_SSrv: Invalid itemName (type="..type(itemName)..")") return {success = false} end
        if type(itemCount) ~= "number" then corelog.Error("enterprise_shop.NeedsTo_ProvideItemsTo_SSrv: Invalid itemCount (type="..type(itemCount)..")") return {success = false} end
        local item = { [itemName] = itemCount }

        -- get best supplierLocator
        local supplierLocator = GetBestSupplierLocator(item)
        if supplierLocator == nil then corelog.Error("enterprise_shop.NeedsTo_ProvideItemsTo_SSrv: No supplier can provide "..itemCount.." "..itemName.."'s") return {success = false} end

        -- determine itemLocator
        local itemLocator = supplierLocator:copy()
        itemLocator:setQuery(item)
--        corelog.WriteToLog("    itemLocator = "..itemLocator:getURI())

        -- get provide needs
        local itemServiceData = {
            itemsLocator                = itemLocator,
            storageLocator              = storageLocator,
            ingredientsSupplierLocator  = ingredientsSupplierLocator,
        }
        local serviceResults = enterprise_isp.NeedsTo_ProvideItemsTo_SSrv(itemServiceData)
        if not serviceResults.success then corelog.Error("enterprise_shop.NeedsTo_ProvideItemsTo_SSrv: Failed obtaining needs for "..itemCount.." "..itemName.."'s") return {success = false} end

        -- get fuelNeed to provide
        local fuelNeedProvide = serviceResults.fuelNeed

        -- add fuelNeed
        corelog.WriteToLog("S  fuelNeedProvide="..fuelNeedProvide.." for "..itemCount.." "..itemName.."'s")
        fuelNeed = fuelNeed + fuelNeedProvide

        -- add ingredientsNeed
        local itemIngredientsNeed = serviceResults.ingredientsNeed
        if not enterprise_isp.AddItemsTo(ingredientsNeed, itemIngredientsNeed).success then corelog.Error("enterprise_shop.NeedsTo_ProvideItemsTo_SSrv: Failed adding items "..textutils.serialise(itemIngredientsNeed).." to ingredientsNeed.") return {success = false} end
    end

    -- end
    return {
        success         = true,
        fuelNeed        = fuelNeed,
        ingredientsNeed = ingredientsNeed, -- ToDo: consider allowing for non empty list to further generalise Shop into a container of Suppliers
    }
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function ProcureItem_ASrv(serviceData, callback, callbackData)
    --[[
        This async private service procures items ordered at the Shop. The services first tries to obtain the item from a Supplier. 
        If the items are not available from a Supplier it will attempt to have them produced by a Producer. The service 
        ensures the items are delivered to the requested destination.

        Return value:
            nil

        Async service return value (to callback):
                                            - (table)
                success                     - (boolean) whether the service executed successfully
                destinationItemsLocator     - (URL) stating the final Storage and the items that where transferred to it
                                                (upon service succes the "host" component of this URL should be equal to destinationHostLocator, and
                                                the "query" should be equal to orderItems)

        Parameters:
            serviceData                     - (table) data for the service
                item                        - (table) with one item (formatted as [itemName] = itemCount key-value pair) to procure
                storageLocator              - (URL) locating the Storage where the items need to be provided to
                ingredientsSupplierLocator  - (URL) locating where the production ingredients can be retrieved
                assignmentsPriorityKey      - (string) priorityKey that should be set for all assignments triggered by this service
            callback                        - (string) name of function to call once service is ready
            callbackData                    - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_shop.ProcureItem_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local item = serviceData.item
    if type(item) ~= "table" then corelog.Error("enterprise_shop.ProcureItem_ASrv: Invalid item") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local storageLocator = url.URLClass:new(serviceData.storageLocator)
    if type(storageLocator) ~= "table" then corelog.Error("enterprise_shop.ProcureItem_ASrv: Invalid storageLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local ingredientsSupplierLocator = url.URLClass:new(serviceData.ingredientsSupplierLocator)
    if type(ingredientsSupplierLocator) ~= "table" then corelog.Error("enterprise_shop.ProcureItem_ASrv: Invalid ingredientsSupplierLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = serviceData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_shop.ProcureItem_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_shop.ProcureItem_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- Attempt to procure item from a Supplier
    local supplierHostLocator = GetSupplierHostLocator()
    local supplierItemsLocator = supplierHostLocator:copy()
    supplierItemsLocator:setQuery(item)
    local serviceResults = enterprise_isp.ItemsAvailableVia_SSrv( { itemsLocator = supplierItemsLocator} )
    if serviceResults.success then
        local transferData = {
            sourceItemsLocator          = supplierItemsLocator,
            destinationStorageLocator   = storageLocator:copy(),
            assignmentsPriorityKey      = assignmentsPriorityKey,
        }
        local itemName  = next(item)
        local itemCount  = item[itemName]
        corelog.WriteToLog(">Procuring "..itemCount.." "..itemName.."'s from global Storage")
        return enterprise_isp.TransferItemsFromTo_ASrv(transferData, callback, callbackData)
    end
    -- ToDo: implement ProvideItemsTo_ASrv for above enterprise_turtle to be able to replace TransferItemsFromTo_ASrv call

    -- get best supplierLocator
    local supplierLocator = GetBestSupplierLocator(item)
    if supplierLocator == nil then corelog.Error("enterprise_shop.NeedsTo_ProvideItemsTo_SSrv: No supplier can provide "..textutils.serialise(item)) return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- determine itemLocator
    local itemLocator = supplierLocator:copy()
    itemLocator:setQuery(item)

    -- Have Supplier produce the item
    local itemServiceData = {
        itemsLocator                = itemLocator,
        ingredientsSupplierLocator  = ingredientsSupplierLocator,
        storageLocator              = storageLocator:copy(),
        assignmentsPriorityKey      = assignmentsPriorityKey,
    }
    return enterprise_isp.ProvideItemsTo_ASrv(itemServiceData, callback, callbackData)
end

function GetBestSupplierLocator(item)
    --[[
        This sync private function provides the best Supplier that can provide a specific item.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                supplierLocator     - (URL) locating the best Supplier of the items

        Parameters:
            serviceData             - (table) data about this service
                item                - (table) with one item (formatted as [itemName] = itemCount key-value pair) to provide
    --]]

    -- check input
    if type(item) ~= "table" then corelog.Error("enterprise_shop.GetBestSupplierLocator: Invalid item (type="..type(item)..")") return nil end

    -- find best Supplier
    local supplierLocator = nil

    -- check if (main) Supplier has items
    -- ToDo: further treat both Supplier and Producer's the same (as Supplier's))
    local supplierHostLocator = GetSupplierHostLocator()
    local supplierItemsLocator = supplierHostLocator:copy()
    supplierItemsLocator:setQuery(item)
    local serviceResults = enterprise_isp.ItemsAvailableVia_SSrv( { itemsLocator = supplierItemsLocator} )
    if serviceResults.success then
        supplierLocator = supplierHostLocator
    else
        -- check if a Producer can produce item
        local itemName = next(item, nil)
        local itemCount = item[itemName]
        if type(itemName) ~= "string" then corelog.Error("enterprise_shop.GetBestSupplierLocator: Invalid itemName (type="..type(itemName)..")") return nil end
        if type(itemCount) ~= "number" then corelog.Error("enterprise_shop.GetBestSupplierLocator: Invalid itemCount (type="..type(itemCount)..")") return nil end
        local productItemData = {
            itemName    = itemName,
            itemCount   = itemCount,
        }
            if enterprise_factory.Can_ProvideItems_QSrv(productItemData).success      then supplierLocator = enterprise_factory.GetISHURL()
        elseif enterprise_colonization.Can_ProvideItems_QSrv(productItemData).success then supplierLocator = enterprise_colonization.GetISHURL() -- ToDo: implement and change into enterprise_woods
        else corelog.Warning("enterprise_shop.GetBestSupplierLocator: No Supplier can provide item "..textutils.serialise(item)) end
    end

    -- end
    return supplierLocator
end

function GetSupplierHostLocator()
    -- ToDo: consider getting this from enterprise_storage (once it supports enterprise_turtle as the initial Supplier, as it's needed for settler). 
    --      For now only it's hardcoded and only the turtle is supported as a Supplier.
    local supplierHostLocator = enterprise_turtle.GetHostLocator_SSrv({ }).hostLocator

    return supplierHostLocator
end

function GetISHURL()
    --[[
        This private function provides the (base) URL of this ISH.

        Return value:
            hostURL                 - (URL) locating this ISH

        Parameters:
            nil
    --]]

    local hostURL = url.URLClass:new()
    hostURL:setHost(db.hostName)

    return hostURL
end

function IsShopURL_QSrv(queryData)
    --[[
        This sync public service answers the question if a URL is that of the Shop.
        
        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully

        Parameters:
            queryData               - (table) data about the query
                aURL                - (table) a URL that needs to be queried
    --]]

    -- check input
    if type(queryData) ~= "table" or type(queryData.aURL) ~= "table" then corelog.Error("enterprise_shop.IsShopURL_QSrv: Invalid queryData input.") return {success = false} end

    -- check if of Shop
    local aURL = url.URLClass:new(queryData.aURL)
    local host = aURL:getHost()
    if type(host) ~= "string" then corelog.Error("enterprise_shop.IsShopURL_QSrv: Invalid host input in URL (="..aURL:getURI()..").") return {success = false} end
    if host == db.hostName then
        return {success = true}
    else
        return {success = false}
    end
end
