local db = {
    hostName    = "shop",
}

--[[
    The Shop is an enterprise that offers services for ordering items.

    The Shop provides the following services
        OrderItems_ASrv             - procure items and having them delivered at a destinationHostLocator
        <It is envisioned (but not yet implemented) that a shop can also take/ "purchase" items (i.e. the opposite of ordering).>

    The Shop implements it's services by using services of Supplier enterprises. 

    For an enterprise to be a Supplier it needs to implement the following services:
        ProvideItemsTo_ASrv         - providing multiple instances of a specific item and having them delivered at a Storage
        Can_ProvideItems_QSrv       - whether the Supplier can provide a specific item
        NeedsTo_ProvideItemsTo_SSrv - returning the needs for the Supplier to provide specific items to a Storage

    ToDo: to be made obsolete
        ItemsAvailableVia_SSrv      - providing if a set of items are available at the Supplier. ToDo: this is currently not yet implemented
        GetItemsIntoTurtle_ASrv     - ensuring a set of items are gathered in the Supplier and transferred to the inventory of a turtle.

    The Shop is also a Supplier, hence it also implements these services.

    This allows for the Shop to be passed as ingredientsSupplierLocator to a Supplier. The effect of that is that the Supplier can request 
    the ingredients from the Shop. The Shop than (by a recursive call to the OrderItems service) tries retrieving the ingredients from a Supplier. 
    This recursive order call will result in a successfull items order if the (sub, and sub-sub, etc) ingredients are present and/ or can be provided 
    by a Supplier.
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function OrderItems_ASrv(serviceData, callback, callbackData)
    --[[
        With this async public service items can be ordered at the Shop. This services tries to procure each of the ordered items.
        The Shop ensures the items are delivered to the requested destination.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                destinationItemsLocator - (URL) stating the final Storage and the items that where transferred to it
                                            (upon service succes the "host" component of this URL should be equal to destinationHostLocator, and
                                            the "query" should be equal to orderItems)

        Parameters:
            serviceData                 - (table) data for the service
                orderItems              - (table) with one or more ordered items (formatted as an array of [itemName] = itemCount key-value pairs) 
                destinationHostLocator  - (URL) locating where the ordered items need to be delivered to
                assignmentsPriorityKey  - (string) priorityKey that should be set for all assignments triggered by this service
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_shop.OrderItems_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local orderItems = serviceData.orderItems
    if type(orderItems) ~= "table" then corelog.Error("enterprise_shop.OrderItems_ASrv: Invalid orderItems") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local destinationHostLocator = url.URLClass:new(serviceData.destinationHostLocator)
    if type(destinationHostLocator) ~= "table" then corelog.Error("enterprise_shop.OrderItems_ASrv: Invalid destinationHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = serviceData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_shop.OrderItems_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_shop.OrderItems_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- determine projectSteps and projectData
    local projectSteps = {}
    local areAllTrueStepDataDef = {}
    local addItemLocatorsStepDataDef = {}
    local projectData = {}

    -- add project step for each of the ordered items 
    local iStep = 0
    -- ToDo: do this in parallel by extending enterprise_projects to handle parallel project steps.
    for itemName, itemCount in pairs(orderItems) do
        -- step index
        iStep = iStep + 1
        local iStepStr = tostring(iStep)

        -- add crafting step
        local procureItemName = "procureItemName"..iStepStr
        local procureItemCount = "procureItemCount"..iStepStr
        table.insert(projectSteps,
            { stepName = "enterprise_shop.ProcureItem_ASrv", async = true, stepDataDef = {
                { keyDef = "procureItemName"        , valueSource = 0, keyDefSource = procureItemName },
                { keyDef = "procureItemCount"       , valueSource = 0, keyDefSource = procureItemCount },
                { keyDef = "destinationHostLocator" , valueSource = 0, keyDefSource = "destinationHostLocator" },
                { keyDef = "assignmentsPriorityKey" , valueSource = 0, keyDefSource = "assignmentsPriorityKey" },
            }}
        )

        -- add step data
        projectData[procureItemName] = itemName
        projectData[procureItemCount] = itemCount

        -- add combine stepDataDef
        table.insert(addItemLocatorsStepDataDef, { keyDef = "itemsLocator"..iStepStr  , valueSource = iStep, keyDefSource = "destinationItemsLocator" })

        -- add success stepDataDef
        table.insert(areAllTrueStepDataDef, { keyDef = "success"..iStepStr  , valueSource = iStep, keyDefSource = "success" })
    end

    -- set assignmentsPriorityKey
    projectData.assignmentsPriorityKey = assignmentsPriorityKey

    -- set destinationHostLocator
    projectData.destinationHostLocator = destinationHostLocator
    -- ToDo: consider first locally gathering the ordered items and sending them in one go to the destinationHostLocator if all off them are obtained.

    -- add combining URL's
    iStep = iStep + 1
    table.insert(projectSteps,
        { stepName = "enterprise_isp.AddItemsLocators_SSrv", async = false, stepDataDef = addItemLocatorsStepDataDef}
    )
    local iAddItemsLocatorStep = iStep

    -- add check for all a success
    iStep = iStep + 1
    table.insert(projectSteps,
        { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = areAllTrueStepDataDef}
    )
    local iAreAllTrueStep = iStep

    -- create project service data
    local projectDef = {
        steps = projectSteps,
        returnData  = {
            { keyDef = "success"                , valueSource = iAreAllTrueStep, keyDefSource = "success" },
            { keyDef = "destinationItemsLocator", valueSource = iAddItemsLocatorStep, keyDefSource = "itemsLocator" },
        }
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
--    corelog.WriteToLog(">Handling order of items = "..textutils.serialise(orderItems).."")
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function GetItemsIntoTurtle_ASrv(transferData, callback, callbackData)
    --[[
        This async public service ensures items are gathered in the Supplier and transferred to the inventory of a turtle.

        Return value:
            nil 

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                turtleItemsLocator      - (URL) locating a specific turtle and the items it has gotton in it's inventory

        Parameters:
            transferData                - (table) data about the transfer
                sourceItemsLocator      - (URL) locating the items that need transfer
                                            (the "query" component of the URL specifies the items to be transferred)
                                            (the "host" component of the URL should specify this host (i.e. a chest) where the items are located)                                        
                assignmentsPriorityKey  - (string) priorityKey that should be set for all assignments triggered by this service
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function                                                
    --]]

    -- check input
    if type(transferData) ~= "table" then corelog.Error("enterprise_shop.GetItemsIntoTurtle_ASrv: Invalid transferData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local sourceItemsLocator = url.URLClass:new(transferData.sourceItemsLocator)
    if type(sourceItemsLocator) ~= "table" then corelog.Error("enterprise_shop.GetItemsIntoTurtle_ASrv: Invalid sourceItemsLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = transferData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_shop.GetItemsIntoTurtle_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_shop.GetItemsIntoTurtle_ASrv: Invalid callback") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- check source is for this enterprise
    local serviceResults = IsShopURL_QSrv({ aURL = sourceItemsLocator})
    if not serviceResults.success then corelog.Error("enterprise_shop.GetItemsIntoTurtle_ASrv: Invalid sourceURL (="..sourceItemsLocator:getURI()..").") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- get transferItems
    local transferItems = coreutils.DeepCopy(sourceItemsLocator:getQuery())

    -- implement by ordering from ourself (i.e. the Shop):
    -- create project definition
    local projectDef = {
        steps   = {
            { stepName = "enterprise_shop.OrderItems_ASrv", async = true, stepDataDef = {
                { keyDef = "orderItems"             , valueSource = 0, keyDefSource = "orderItems" },
                { keyDef = "destinationHostLocator" , valueSource = 0, keyDefSource = "destinationHostLocator" },
                { keyDef = "assignmentsPriorityKey" , valueSource = 0, keyDefSource = "assignmentsPriorityKey" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , valueSource = 1, keyDefSource = "success" },
            { keyDef = "turtleItemsLocator"         , valueSource = 1, keyDefSource = "destinationItemsLocator" },
        }
    }
    local projectData = {
        orderItems              = transferItems,
        destinationHostLocator  = enterprise_turtle.GetHostLocator_SSrv({ }).hostLocator,

        assignmentsPriorityKey  = assignmentsPriorityKey,
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
--    corelog.WriteToLog(">Ordering "..sourceItemsLocator:getQueryURI().." from shop into a turtle.")
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function GetHostLocator_SSrv(serviceData)
    --[[
        This sync public service provides the (base) URL of this ISH.

        Return value:
            hostLocator             - (URL) locating this ISH

        Parameters:
            serviceData             - (table) empty
    --]]

    -- end
    local result = {
        success = true,
        hostLocator = GetISHURL(),
    }
    return result
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function ProcureItem_ASrv(serviceData, callback, callbackData)
    --[[
        This async private service procures items ordered at the Shop. The services first tries to obtain the item from a Supplier. 
        If the items are not available from a Supplier it will attempt to have them produced by a Producer. The service 
        ensures the items are delivered to the requested destination.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                destinationItemsLocator - (URL) stating the final Storage and the items that where transferred to it
                                            (upon service succes the "host" component of this URL should be equal to destinationHostLocator, and
                                            the "query" should be equal to orderItems)

        Parameters:
            serviceData                 - (table) data for the service
                procureItemName         - (string) name of item to procure
                procureItemCount        - (number) amount of items to procure
                destinationHostLocator  - (URL) locating where the procured items need to be delivered to
                assignmentsPriorityKey  - (string) priorityKey that should be set for all assignments triggered by this service
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_shop.ProcureItem_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local procureItemName = serviceData.procureItemName
    if type(procureItemName) ~= "string" then corelog.Error("enterprise_shop.ProcureItem_ASrv: Invalid procureItemName") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local procureItemCount = serviceData.procureItemCount
    if type(procureItemCount) ~= "number" then corelog.Error("enterprise_shop.ProcureItem_ASrv: Invalid procureItemCount") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local destinationHostLocator = url.URLClass:new(serviceData.destinationHostLocator)
    if type(destinationHostLocator) ~= "table" then corelog.Error("enterprise_shop.ProcureItem_ASrv: Invalid destinationHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = serviceData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_shop.ProcureItem_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_shop.ProcureItem_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- Attempt to procure item from a Supplier
    local supplierHostLocator = GetSupplierHostLocator()
    local supplierItemsLocator = supplierHostLocator:copy()
    local item = { [procureItemName] = procureItemCount } -- ToDo: ? should we get it directly passed into this service instead of individual fields?
    supplierItemsLocator:setQuery(item)
    local serviceResults = enterprise_isp.ItemsAvailableVia_SSrv( { itemsLocator = supplierItemsLocator} )
    if serviceResults.success then
        local transferData = {
            sourceItemsLocator          = supplierItemsLocator,
            destinationStorageLocator   = destinationHostLocator,
            assignmentsPriorityKey      = assignmentsPriorityKey,
        }
        corelog.WriteToLog(">Procuring from Supplier: "..textutils.serialise(item).."")
        return enterprise_isp.TransferItemsFromTo_ASrv(transferData, callback, callbackData)
    end
    -- ToDo: implement ProvideItemsTo_ASrv for above enterprise_turtle to be able to replace TransferItemsFromTo_ASrv call

    -- get best supplierLocator
    local supplierLocator = GetBestSupplierLocator(item)
    if supplierLocator == nil then corelog.Error("enterprise_shop.NeedsTo_ProvideItemsTo_SSrv: No supplier can provide "..procureItemCount.." "..procureItemName.."'s") return {success = false} end

    -- determine itemLocator
    local itemLocator = supplierLocator:copy()
    itemLocator:setQuery(item)

    -- Have Supplier produce the item
    local itemServiceData = {
        itemsLocator                = itemLocator,
        ingredientsSupplierLocator  = GetISHURL(),
        storageLocator              = destinationHostLocator:copy(),
        assignmentsPriorityKey      = assignmentsPriorityKey,
    }
    serviceResults = enterprise_isp.ProvideItemsTo_ASrv(itemServiceData)
    if not serviceResults.success then corelog.Error("enterprise_shop.ProcureItem_ASrv: Failed obtaining needs for "..procureItemCount.." "..procureItemName.."'s") return {success = false} end
end

function GetBestSupplierLocator(item)
    --[[
        This sync private function provides the best Supplier that can provide a specific item.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                supplierLocator     - (URL) locating the best Supplier of the items

        Parameters:
            serviceData             - (table) data about this service
                item                - (table) with one item (formatted as [itemName] = itemCount key-value pair) to provide
    --]]

    -- check input
    if type(item) ~= "table" then corelog.Error("enterprise_shop.GetBestSupplierLocator: Invalid item (type="..type(item)..")") return nil end

    -- find best Supplier
    local supplierLocator = nil

    -- check if (main) Supplier has items
    -- ToDo: further treat both Supplier and Producer's the same (as Supplier's))
    local supplierHostLocator = GetSupplierHostLocator()
    local supplierItemsLocator = supplierHostLocator:copy()
    supplierItemsLocator:setQuery(item)
    local serviceResults = enterprise_isp.ItemsAvailableVia_SSrv( { itemsLocator = supplierItemsLocator} )
    if serviceResults.success then
        supplierLocator = supplierHostLocator
    else
        -- check if a Producer can produce item
        local itemName = next(item, nil)
        local itemCount = item[itemName]
        if type(itemName) ~= "string" then corelog.Error("enterprise_shop.GetBestSupplierLocator: Invalid itemName (type="..type(itemName)..")") return nil end
        if type(itemCount) ~= "number" then corelog.Error("enterprise_shop.GetBestSupplierLocator: Invalid itemCount (type="..type(itemCount)..")") return nil end
        local productItemData = {
            productItemName = itemName,
            productItemCount= itemCount,
        }
            if enterprise_factory.Can_ProvideItems_QSrv(productItemData).success      then supplierLocator = enterprise_factory.GetISHURL()
        elseif enterprise_colonization.Can_ProvideItems_QSrv(productItemData).success then supplierLocator = enterprise_colonization.GetISHURL() -- ToDo: implement and change into enterprise_woods
        else corelog.Warning("enterprise_shop.GetBestSupplierLocator: No Supplier can provide item "..textutils.serialise(item)) end
    end

    -- end
    return supplierLocator
end

function GetSupplierHostLocator()
    -- ToDo: consider getting this from enterprise_storage (once it supports enterprise_turtle as the initial Supplier, as it's needed for settler). 
    --      For now only it's hardcoded and only the turtle is supported as a Supplier.
    local supplierHostLocator = enterprise_turtle.GetHostLocator_SSrv({ }).hostLocator

    return supplierHostLocator
end

function GetISHURL()
    --[[
        This private function provides the (base) URL of this ISH.

        Return value:
            hostURL                 - (URL) locating this ISH

        Parameters:
            nil
    --]]

    local hostURL = url.URLClass:new()
    hostURL:setHost(db.hostName)

    return hostURL
end

function IsShopURL_QSrv(queryData)
    --[[
        This sync public service answers the question if a URL is that of the Shop.
        
        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully

        Parameters:
            queryData               - (table) data about the query
                aURL                - (table) a URL that needs to be queried
    --]]

    -- check input
    if type(queryData) ~= "table" or type(queryData.aURL) ~= "table" then corelog.Error("enterprise_shop.IsShopURL_QSrv: Invalid queryData input.") return {success = false} end

    -- check if of Shop
    local aURL = url.URLClass:new(queryData.aURL)
    local host = aURL:getHost()
    if type(host) ~= "string" then corelog.Error("enterprise_shop.IsShopURL_QSrv: Invalid host input in URL (="..aURL:getURI()..").") return {success = false} end
    if host == db.hostName then
        return {success = true}
    else
        return {success = false}
    end
end
