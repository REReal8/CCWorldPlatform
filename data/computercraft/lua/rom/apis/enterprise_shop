local db = {
--    dhtRoot     = "enterprise_factory",
--    dhtSites    = "sites",
    hostName    = "shop",
}

--[[
    The Shop is an enterprise that offers services for ordering items.

    The Shop provides the following services
        OrderItems_ASrv             - procure items and having them delivered at a destinationHostLocator
        <It is envisioned (but not yet implemented) that a shop can also take/ "purchase" items (i.e. the opposite of ordering).>

    The Shop implements it's services by using services of Suppliers as well as of Producer enterprises. 

    For an enterprise to be a Producer it needs to implement the following services:
        ProduceItem_ASrv            - producing multiple instances of a specific item and having them delivered at a certain destination
        CanProducte_QSrv            - whether the Producer can produce a specific item

    The Shop is also a Supplier, hence it implements the services:
        ItemsAvailableVia_SSrv      - providing if a set of items are available at the Supplier. ToDo: this is currently not yet implemented
        GetItemsIntoTurtle_ASrv     - ensuring a set of items are gathered in the Supplier and transferred to the inventory of a turtle.
    This allows for the Shop to be passed as ingredientsHostLocator to a Producer. The effect of that is that the Producer can request 
    the ingredients from the Shop. The Shop than (by a recursive call to the OrderItems service) tries retrieving the ingredients from a Supplier. 
    If that fails it tries to procure the ingredients again with another call to a Producer. This recursive order call will result in a successfull 
    items order if the (sub, and sub-sub, etc) ingredients are present in a Supplier and/ or can be produced by a Producer. If no items
    are in a Supplier this implies that an items order can be successfull as long as all the ingredients can be produced by a Producer.
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function OrderItems_ASrv(serviceData, callback, callbackData)
    --[[
        With this async public service items can be ordered at the Shop. This services tries to procure each of the ordered items.
        The Shop ensures the items are delivered to the requested destination.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                destinationItemsLocator - (URL) stating the final Storage and the items that where transferred to it
                                            (upon service succes the "host" component of this URL should be equal to destinationHostLocator, and
                                            the "query" should be equal to orderItems)

        Parameters:
            serviceData                 - (table) data for the service
                orderItems              - (table) with one or more ordered items (formatted as an array of [itemName] = itemCount key-value pairs) 
                destinationHostLocator  - (URL) locating where the ordered items need to be delivered to
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_shop.OrderItems_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local orderItems = serviceData.orderItems
    if type(orderItems) ~= "table" then corelog.Error("enterprise_shop.OrderItems_ASrv: Invalid orderItems") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local destinationHostLocator = url.URLClass:new(serviceData.destinationHostLocator)
    if type(destinationHostLocator) ~= "table" then corelog.Error("enterprise_shop.OrderItems_ASrv: Invalid destinationHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_shop.OrderItems_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- determine projectSteps and projectData
    local projectSteps = {}
    local areAllTrueStepDataDef = {}
    local addItemLocatorsStepDataDef = {}
    local projectData = {}

    -- add project step for each of the ordered items 
    local iStep = 0
    -- ToDo: do this in parallel by extending enterprise_projects to handle parallel project steps.
    for itemName, itemCount in pairs(orderItems) do
        -- step index
        iStep = iStep + 1
        local iStepStr = tostring(iStep)

        -- add crafting step
        local procureItemName = "procureItemName"..iStepStr
        local procureItemCount = "procureItemCount"..iStepStr
        table.insert(projectSteps,
            { stepName = "enterprise_shop.ProcureItem_ASrv", async = true, stepDataDef = {
                { keyDef = "procureItemName"        , valueSource = 0, keyDefSource = procureItemName },
                { keyDef = "procureItemCount"       , valueSource = 0, keyDefSource = procureItemCount },
                { keyDef = "destinationHostLocator" , valueSource = 0, keyDefSource = "destinationHostLocator" },
            }}
        )

        -- add step data
        projectData[procureItemName] = itemName
        projectData[procureItemCount] = itemCount

        -- add combine stepDataDef
        table.insert(addItemLocatorsStepDataDef, { keyDef = "itemsLocator"..iStepStr  , valueSource = iStep, keyDefSource = "destinationItemsLocator" })

        -- add success stepDataDef
        table.insert(areAllTrueStepDataDef, { keyDef = "success"..iStepStr  , valueSource = iStep, keyDefSource = "success" })
    end

    -- set destinationHostLocator
    projectData.destinationHostLocator = destinationHostLocator
    -- ToDo: consider first locally gathering the ordered items and sending them in one go to the destinationHostLocator if all off them are obtained.

    -- add combining URL's
    iStep = iStep + 1
    table.insert(projectSteps,
        { stepName = "enterprise_isp.AddItemsLocators_SSrv", async = false, stepDataDef = addItemLocatorsStepDataDef}
    )
    local iAddItemsLocatorStep = iStep

    -- add check for all a success
    iStep = iStep + 1
    table.insert(projectSteps,
        { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = areAllTrueStepDataDef}
    )
    local iAreAllTrueStep = iStep

    -- create project service data
    local projectDef = {
        steps = projectSteps,
        returnData  = {
            { keyDef = "success"                , valueSource = iAreAllTrueStep, keyDefSource = "success" },
            { keyDef = "destinationItemsLocator", valueSource = iAddItemsLocatorStep, keyDefSource = "itemsLocator" },
        }
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
--    corelog.WriteToLog(">Handling order of items = "..textutils.serialise(orderItems).."")
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function GetItemsIntoTurtle_ASrv(transferData, callback, callbackData)
    --[[
        This async public service ensures items are gathered in the Supplier and transferred to the inventory of a turtle.

        Return value:
            nil 

        Async service return value (to callback):
                                    - (table)
                success             - (boolean) whether the service executed successfully
                turtleItemsLocator  - (URL) locating a specific turtle and the items it has gotton in it's inventory

        Parameters:
            transferData            - (table) data about the transfer
                sourceItemsLocator  - (URL) locating the items that need transfer
                                        (the "query" component of the URL specifies the items to be transferred)
                                        (the "host" component of the URL should specify this host (i.e. a chest) where the items are located)                                        
            callback                - (string) name of function to call once service is ready
            callbackData            - (table) data to supply to callback function                                                
    --]]

    -- check input
    if type(transferData) ~= "table" then corelog.Error("enterprise_shop.GetItemsIntoTurtle_ASrv: Invalid transferData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local sourceItemsLocator = url.URLClass:new(transferData.sourceItemsLocator)
    if type(sourceItemsLocator) ~= "table" then corelog.Error("enterprise_shop.GetItemsIntoTurtle_ASrv: Invalid sourceItemsLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_shop.GetItemsIntoTurtle_ASrv: Invalid callback") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- check source is for this enterprise
    local sourceIsShop = IsShopURL_QSrv({ aURL = sourceItemsLocator})
    if not sourceIsShop.success then corelog.Error("enterprise_shop.GetItemsIntoTurtle_ASrv: Invalid sourceURL (="..sourceItemsLocator:getURI()..").") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- get transferItems
    local transferItems = coreutils.DeepCopy(sourceItemsLocator:getQuery())

    -- implement by ordering from ourself (i.e. the Shop):
    -- create project definition
    local projectDef = {
        steps   = {
            { stepName = "enterprise_shop.OrderItems_ASrv", async = true, stepDataDef = {
                { keyDef = "orderItems"             , valueSource = 0, keyDefSource = "orderItems" },
                { keyDef = "destinationHostLocator" , valueSource = 0, keyDefSource = "destinationHostLocator" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , valueSource = 1, keyDefSource = "success" },
            { keyDef = "turtleItemsLocator"         , valueSource = 1, keyDefSource = "destinationItemsLocator" },
        }
    }
    local projectData = {
        orderItems              = transferItems,
        destinationHostLocator  = enterprise_turtle.GetHostLocator_SSrv({ }).hostLocator,
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
--    corelog.WriteToLog(">Ordering "..sourceItemsLocator:getQueryURI().." from shop into a turtle.")
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function GetHostLocator_SSrv(serviceData)
    --[[
        This sync public service provides the (base) URL of this ISH.

        Return value:
            hostLocator             - (URL) locating this ISH

        Parameters:
            serviceData             - (table) empty
    --]]

    -- end
    local result = {
        success = true,
        hostLocator = GetISHURL(),
    }
    return result
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function ProcureItem_ASrv(serviceData, callback, callbackData)
    --[[
        This async private service procures items ordered at the Shop. The services first tries to obtain the item from a Supplier. 
        If the items are not available from a Supplier it will attempt to have them produced by a Producer. The service 
        ensures the items are delivered to the requested destination.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                destinationItemsLocator - (URL) stating the final Storage and the items that where transferred to it
                                            (upon service succes the "host" component of this URL should be equal to destinationHostLocator, and
                                            the "query" should be equal to orderItems)

        Parameters:
            serviceData                 - (table) data for the service
                procureItemName         - (string) name of item to procure
                procureItemCount        - (number) amount of items to procure
                destinationHostLocator  - (URL) locating where the procured items need to be delivered to
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_shop.ProcureItem_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local procureItemName = serviceData.procureItemName
    if type(procureItemName) ~= "string" then corelog.Error("enterprise_shop.ProcureItem_ASrv: Invalid procureItemName") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local procureItemCount = serviceData.procureItemCount
    if type(procureItemCount) ~= "number" then corelog.Error("enterprise_shop.ProcureItem_ASrv: Invalid procureItemCount") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local destinationHostLocator = url.URLClass:new(serviceData.destinationHostLocator)
    if type(destinationHostLocator) ~= "table" then corelog.Error("enterprise_shop.ProcureItem_ASrv: Invalid destinationHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_shop.ProcureItem_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- Attempt to procure item from a Supplier
    -- ToDo: consider getting this from enterprise_storage (once it supports enterprise_turtle as the initial Supplier, as it's needed for settler). 
    --      For now only it's hardcoded and only the turtle is supported as a Supplier.
    local supplierHostLocator = enterprise_turtle.GetHostLocator_SSrv({ }).hostLocator
    local supplierItemsLocator = supplierHostLocator:copy()
    local procureItemsQuery = { [procureItemName] = procureItemCount } -- ToDo: ? should we get it directly passed into this service instead of individual fields?
    supplierItemsLocator:setQuery(procureItemsQuery)
    if enterprise_isp.ItemsAvailableVia_SSrv( { itemsLocator = supplierItemsLocator} ).success then
        local transferData = {
            sourceItemsLocator      = supplierItemsLocator,
            destinationHostLocator  = destinationHostLocator,
        }
        corelog.WriteToLog(">Procuring from Supplier: "..textutils.serialise(procureItemsQuery).."")
        return enterprise_isp.TransferItemsFromTo_ASrv(transferData, callback, callbackData)
    end

    -- Find a Producer that can produce item
    local producer = nil
    if enterprise_factory.CanProduce_QSrv({ productItemName = procureItemName }).success then
        producer = enterprise_factory
    else -- ToDo: add other Producer's (the Forest could/ should be one!)
        corelog.Error("enterprise_shop.ProcureItem_ASrv: No producer can produce "..procureItemName.."'s") return coreutils.DoCallback(callback, callbackData, {success = false})
    end

    -- Have Producer produce the item
    local produceData = {
        productItemName         = procureItemName,
        productItemCount        = procureItemCount,
        ingredientsHostLocator  = GetISHURL(),
        destinationHostLocator  = destinationHostLocator:copy(),
    }
    producer.ProduceItem_ASrv(produceData, callback, callbackData)
end

function GetISHURL()
    --[[
        This private function provides the (base) URL of this ISH.

        Return value:
            hostURL                 - (URL) locating this ISH

        Parameters:
            nil
    --]]

    local hostURL = url.URLClass:new()
    hostURL:setHost(db.hostName)

    return hostURL
end

function IsShopURL_QSrv(queryData)
    --[[
        This sync public service answers the question if a URL is that of the Shop.
        
        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully

        Parameters:
            queryData               - (table) data about the query
                aURL                - (table) a URL that needs to be queried
    --]]

    -- check input
    if type(queryData) ~= "table" or type(queryData.aURL) ~= "table" then corelog.Error("enterprise_shop.IsShopURL_QSrv: Invalid queryData input.") return {success = false} end

    -- check if of Shop
    local aURL = url.URLClass:new(queryData.aURL)
    local host = aURL:getHost()
    if type(host) ~= "string" then corelog.Error("enterprise_shop.IsShopURL_QSrv: Invalid host input in URL (="..aURL:getURI()..").") return {success = false} end
    if host == db.hostName then
        return {success = true}
    else
        return {success = false}
    end
end
