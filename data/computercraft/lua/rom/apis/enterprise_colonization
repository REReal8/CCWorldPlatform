local db = {
    dhtRoot     = "enterprise_colonization",
    dhtForest   = "forest", -- ToDo: consider allowing multiple (once part of enterprise_woods)
}

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function CreateNewWorld_ASrv(serviceData, callback, callbackData)
    --[[
        This public async service creates a new CCWorldPlatform world.
            It bootstraps the world logic by building an initiating several enterprise (sites). 

            The turtle should already have (either equiped or in it's inventory)
                one modem
                one axe
                one crafting station
                one birchSapling
            It is not necessary for the turtle to have any energy. The turtle will start by placing the sapling in front of itself.

            The function also defines the coordinate system by assuming the turtle starts at the location {x= 3, y= 2, z= 1, dx=0, dy=1}. This
            allows for the initial forest that is build to fit in the 6x6 grid that is used in patterns with the lower left coordinate of the base 
            of that forest being location {x= 0, y= 0, z= 1, dx=0, dy=1}

        Return value:
            nil

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the service executed successfully

        Parameters:
            serviceData         - (table) data about the service
                <currently none>
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function
    --]]

    -- check input
    if type(callback) ~= "string" then corelog.Error("enterprise_colonization.CreateNewWorld_ASrv: callback not a string") return false end

    -- ensure enterprise has a key in the dht
    if coredht.GetData(db.dhtRoot) == nil then
        -- create the entry
        coredht.SaveData({}, db.dhtRoot)

        -- reset forest
        ResetForest()
    end

    -- get forest
    local forest = coredht.GetData(db.dhtRoot, db.dhtForest)

    -- construct arguments
    local startLocation             = {x= 3, y= 2, z= 1, dx=0, dy=1}
    local primaryTaskData =  {
        startLocation               = coremove.CopyLocation(startLocation),
    }
    local factoryLocation           = {x=12, y= 0, z= 1, dx=0, dy=1}
    local treesNeeded = 6
    local settleData = {
        materialsHostLocator        = enterprise_shop.GetHostLocator_SSrv({ }).hostLocator,

        primaryTaskData             = primaryTaskData,
        startLocation               = coremove.CopyLocation(startLocation),

        plantFirstSaplingMetaData   = role_settler.PlantFirstSapling_MetaData(primaryTaskData),
        plantFirstSapling_Task      = "role_settler.PlantFirstSapling_Task",

        factoryVersion0             = "v0",
        upgradeFalse                = false,

        waitFirstTreeMetaData       = role_settler.WaitFirstTree_MetaData(primaryTaskData),
        waitFirstTree_Task          = "role_settler.WaitFirstTree_Task",

        ingredientsHostLocator      = enterprise_shop.GetHostLocator_SSrv({ }).hostLocator, -- ToDo: somehow pass this to enterprise_energy

        chopFirstTreeMetaData       = role_settler.ChopFirstTree_MetaData(primaryTaskData),
        chopFirstTree_Task          = "role_settler.ChopFirstTree_Task",

        forestFirstTree             = 1,

        collectCobbleStoneMetaData  = role_settler.CollectCobbleStone_MetaData(primaryTaskData),
        collectCobbleStone_Task     = "role_settler.CollectCobbleStone_Task",

        factoryLocation             = coremove.CopyLocation(factoryLocation),
        factoryVersion1             = "v1",

        treesNeeded                 = treesNeeded,

        forestLocation              = coremove.CopyLocation(forest.location),
        forestV2BasePattern         = role_builder.CopyPattern(enterprise_forest.tree_pattern), -- ToDo: use a new pattern including chests
        forestBuildFromAbove        = true,
        forestReplacePresentObjects = false,

        factoryVersion2             = "v2",
        upgradeToV2                 = true,

        siloLocation                = {x=12, y=12, z= 1, dx=0, dy=1},
        type                        = "silo",
        siloType                    = "basic",
        topChests                   = 2,
        layers                      = 2,
    }

    -- create project definition
    local createNewWorldProjectDef = {
        steps   = {
            { stepName = "enterprise_factory.BuildAndStartNewSite_ASrv", async = true, stepDataDef = {
                { keyDef = "baseLocation"               , valueSource = 0, keyDefSource = "startLocation" },
                { keyDef = "siteVersion"                , valueSource = 0, keyDefSource = "factoryVersion0" },
                { keyDef = "upgrade"                    , valueSource = 0, keyDefSource = "upgradeFalse" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            -- ToDo: implement forest related steps in/ via enterprise_wood/ forest
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"           , valueSource = 0, keyDefSource = "plantFirstSapling_Task" },
                { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "plantFirstSaplingMetaData" },
                { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "primaryTaskData" },
            }},
            { stepName = "enterprise_colonization.UpdateForestInfo_SSrv", async = false, stepDataDef = {
                { keyDef = "forestNTrees"               , valueSource = 0, keyDefSource = "forestFirstTree" },
            }},
            -- ToDo: consider calling HarvestForest_Task
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"           , valueSource = 0, keyDefSource = "waitFirstTree_Task" },
                { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "waitFirstTreeMetaData" },
                { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "primaryTaskData" },
            }},
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"           , valueSource = 0, keyDefSource = "chopFirstTree_Task" },
                { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "chopFirstTreeMetaData" },
                { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "primaryTaskData" },
            }},
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"           , valueSource = 0, keyDefSource = "collectCobbleStone_Task" },
                { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "collectCobbleStoneMetaData" },
                { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "primaryTaskData" },
            }},
            { stepName = "enterprise_factory.BuildAndStartNewSite_ASrv", async = true, stepDataDef = {
                { keyDef = "baseLocation"               , valueSource = 0, keyDefSource = "factoryLocation" },
                { keyDef = "siteVersion"                , valueSource = 0, keyDefSource = "factoryVersion1" },
                { keyDef = "upgrade"                    , valueSource = 0, keyDefSource = "upgradeFalse" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            { stepName = "enterprise_factory.StopAndDismantleSite_ASrv", async = true, stepDataDef = {
                { keyDef = "baseLocation"               , valueSource = 0, keyDefSource = "startLocation" },
                { keyDef = "siteVersion"                , valueSource = 0, keyDefSource = "factoryVersion0" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            { stepName = "enterprise_colonization.ExtendForest_ASrv", async = true, stepDataDef = {
                { keyDef = "forestLocation"             , valueSource = 0, keyDefSource = "forestLocation" },
                { keyDef = "treesNeeded"                , valueSource = 0, keyDefSource = "treesNeeded" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            -- Finish Forest ("redo base/ first tree according to pattern")
            -- ToDo: consider changing this to a forest service that upgrades the forest to next level (v1 or v2 (incl chests))
            { stepName = "enterprise_construction.BuildRectangularPattern_ASrv", async = true, stepDataDef = {
                { keyDef = "startpoint"                 , valueSource = 0, keyDefSource = "forestLocation" },
                { keyDef = "buildFromAbove"             , valueSource = 0, keyDefSource = "forestBuildFromAbove" },
                { keyDef = "replacePresentObjects"      , valueSource = 0, keyDefSource = "forestReplacePresentObjects" },
                { keyDef = "pattern"                    , valueSource = 0, keyDefSource = "forestV2BasePattern" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            { stepName = "enterprise_factory.BuildAndStartNewSite_ASrv", async = true, stepDataDef = {
                { keyDef = "baseLocation"               , valueSource = 0, keyDefSource = "factoryLocation" },
                { keyDef = "siteVersion"                , valueSource = 0, keyDefSource = "factoryVersion2" },
                { keyDef = "upgrade"                    , valueSource = 0, keyDefSource = "upgradeToV2" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            { stepName = "enterprise_storage.BuildAndStartNewSite_ASrv", async = true, stepDataDef = {
                { keyDef = "location"                   , valueSource = 0, keyDefSource = "siloLocation" },
                { keyDef = "type"                       , valueSource = 0, keyDefSource = "type" },
                { keyDef = "siloType"                   , valueSource = 0, keyDefSource = "siloType" },
                { keyDef = "topChests"                  , valueSource = 0, keyDefSource = "topChests" },
                { keyDef = "layers"                     , valueSource = 0, keyDefSource = "layers" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                { keyDef = "success1"                   , valueSource = 1, keyDefSource = "success" },
                { keyDef = "success2"                   , valueSource = 2, keyDefSource = "success" },
                { keyDef = "success3"                   , valueSource = 3, keyDefSource = "success" },
                { keyDef = "success4"                   , valueSource = 4, keyDefSource = "success" },
                { keyDef = "success5"                   , valueSource = 5, keyDefSource = "success" },
                { keyDef = "success6"                   , valueSource = 6, keyDefSource = "success" },
                { keyDef = "success7"                   , valueSource = 7, keyDefSource = "success" },
                { keyDef = "success8"                   , valueSource = 8, keyDefSource = "success" },
                { keyDef = "success9"                   , valueSource = 9, keyDefSource = "success" },
                { keyDef = "success10"                  , valueSource = 10, keyDefSource = "success" },
                { keyDef = "success11"                  , valueSource = 11, keyDefSource = "success" },
                { keyDef = "success12"                  , valueSource = 12, keyDefSource = "success" },
                { keyDef = "success13"                  , valueSource = 13, keyDefSource = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                        , valueSource = 14, keyDefSource = "success" },
        }
    }
    local projectServiceData = {
        projectDef  = createNewWorldProjectDef,
        projectData = settleData,
    }

    -- start project
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function ResetForest()
    coredht.SaveData({
        location    = {x= 0, y= 0, z= 1, dx=0, dy=1},
        nTrees      = 0,
    }, db.dhtRoot, db.dhtForest)
end

function ExtendForest_ASrv(serviceData, callback, callbackData)
    --[[
        This private async service extends the forest from 1 tree to a number of trees.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully

        Parameters:
            serviceData                 - (table) data about the service
                forestLocation          - (table) base location of factory
                treesNeeded             - (number) number of trees to extend forest to
                materialsHostLocator    - (URL) locating the host of the building materials
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local forestLocation = serviceData.forestLocation
    if type(forestLocation) ~= "table" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid forestLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local treesNeeded = serviceData.treesNeeded
    if type(treesNeeded) ~= "number" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid treesNeeded") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local materialsHostLocator = url.URLClass:new(serviceData.materialsHostLocator)
    if type(materialsHostLocator) ~= "table" then corelog.Error("enterprise_colonization.BuildForestTree_ASrv: Invalid materialsHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- determine projectSteps and projectData
    local projectSteps = { }
    local areAllTrueStepDataDef = {}
    local projectData = {
        forestLocation          = forestLocation,
        materialsHostLocator    = materialsHostLocator,
    }

    -- get forest
    local forest = coredht.GetData(db.dhtRoot, db.dhtForest)

    -- add project step for all trees to add 
    local iStep = 0
    local forestNTrees = forest.nTrees    -- note: first already created in PlantFirstSapling_Task
    for iTree = forestNTrees + 1, treesNeeded do
        -- ToDo: simplify looping (currentNTreesStr and newNTreesStr are related/ almost the same)

        -- add collect and build tree step
        iStep = iStep + 1
        local iStepStr = tostring(iStep)
        local currentNTreesStr = "currentNTreeStep"..iStepStr
        table.insert(projectSteps,
            { stepName = "enterprise_colonization.CollectAndBuildForestTree_ASrv", async = true, stepDataDef = {
                { keyDef = "forestLocation"         , valueSource = 0, keyDefSource = "forestLocation" },
                { keyDef = "currentNTrees"          , valueSource = 0, keyDefSource = currentNTreesStr },
                { keyDef = "materialsHostLocator"   , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }}
        )

        -- add step data
        projectData[currentNTreesStr] = iTree - 1

        -- add success stepDataDef
        table.insert(areAllTrueStepDataDef, { keyDef = "success"..iStepStr, valueSource = iStep, keyDefSource = "success" })

        -- update forest info
        iStep = iStep + 1
        iStepStr = tostring(iStep)
        local newNTreesStr = "newNTreeStep"..iStepStr
        table.insert(projectSteps,
            { stepName = "enterprise_colonization.UpdateForestInfo_SSrv", async = false, stepDataDef = {
                { keyDef = "forestNTrees"           , valueSource = 0, keyDefSource = newNTreesStr },
            }}
        )

        -- add step data
        projectData[newNTreesStr] = iTree

        -- add success stepDataDef
        table.insert(areAllTrueStepDataDef, { keyDef = "success"..iStepStr, valueSource = iStep, keyDefSource = "success" })
    end
    -- add check for all a success
    iStep = iStep + 1
    table.insert(projectSteps,
        { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = areAllTrueStepDataDef}
    )
    local iAreAllTrueStep = iStep

    -- create project service data
    local projectDef = {
        steps = projectSteps,
        returnData  = {
            { keyDef = "success"    , valueSource = iAreAllTrueStep, keyDefSource = "success" },
        }
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    corelog.WriteToLog(">Extending forest to " .. treesNeeded .. " trees")
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function CollectAndBuildForestTree_ASrv(serviceData, callback, callbackData)
    --[[
        This private async service first collects the resources and than extends the forest with 1 tree.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully

        Parameters:
            serviceData                 - (table) data about the service
                forestLocation          - (table) base location of factory
                currentNTrees           - (number) current number of trees in the forest
                materialsHostLocator    - (URL) locating the host of the building materials
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_colonization.CollectAndBuildForestTree_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local forestLocation = serviceData.forestLocation
    if type(forestLocation) ~= "table" then corelog.Error("enterprise_colonization.CollectAndBuildForestTree_ASrv: Invalid forestLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local currentNTrees = serviceData.currentNTrees
    if type(currentNTrees) ~= "number" then corelog.Error("enterprise_colonization.CollectAndBuildForestTree_ASrv: Invalid currentNTrees") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local materialsHostLocator = url.URLClass:new(serviceData.materialsHostLocator)
    if type(materialsHostLocator) ~= "table" then corelog.Error("enterprise_colonization.CollectAndBuildForestTree_ASrv: Invalid materialsHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_colonization.CollectAndBuildForestTree_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- create projectServiceData
    local treeBaseLocation = coremove.GetRelativeLocation(forestLocation, 0, 6 * currentNTrees, 0)
    local projectData = {
        treeBaseLocation        = treeBaseLocation,
        materialsHostLocator    = materialsHostLocator,
    }
    local projectDef = {
        steps = {
            { stepName = "enterprise_colonization.BuildForestTree_ASrv", async = true, stepDataDef = {
                { keyDef = "treeBaseLocation"       , valueSource = 0, keyDefSource = "treeBaseLocation" },
                { keyDef = "materialsHostLocator"   , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , valueSource = 1, keyDefSource = "success" },
        }
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    corelog.WriteToLog("  >Extending forest with one tree to "..(currentNTrees + 1).." trees")
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function UpdateForestInfo_SSrv(serviceData)
    --[[
        This private sync service updates the forest information.

        Return value:
                                        - (table)
                success                 - (boolean) whether the service executed successfully

        Parameters:
            serviceData                 - (table) data about the service
                forestNTrees            - (number) number of trees in the forest
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_colonization.UpdateForestInfo_SSrv: Invalid serviceData") return {success = false} end
    local forestNTrees = serviceData.forestNTrees
    if type(forestNTrees) ~= "number" then corelog.Error("enterprise_colonization.UpdateForestInfo_SSrv: Invalid forestNTrees") return {success = false} end

    -- get forest
    local forest = coredht.GetData(db.dhtRoot, db.dhtForest)

    -- set forest information
    forest.nTrees = forestNTrees

    -- save forest data
    coredht.SaveData(forest, db.dhtRoot, db.dhtForest)

    -- end
    return {success = true}
end

function BuildForestTree_ASrv(serviceData, callback, callbackData)
    --[[
        This private async service extends the forest with 1 tree

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully

        Parameters:
            serviceData                 - (table) data about this service
                treeBaseLocation        - (table) location of the base (lower left corner) of a forest tree (pattern)
                materialsHostLocator    - (URL) locating the host of the building materials
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_colonization.BuildForestTree_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local treeBaseLocation = serviceData.treeBaseLocation
    if type(treeBaseLocation) ~= "table" then corelog.Error("enterprise_colonization.BuildForestTree_ASrv: Invalid treeBaseLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local materialsHostLocator = url.URLClass:new(serviceData.materialsHostLocator)
    if type(materialsHostLocator) ~= "table" then corelog.Error("enterprise_colonization.BuildForestTree_ASrv: Invalid materialsHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_colonization.BuildForestTree_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- let construction enterprise build the tree
    local buildData = {
        startpoint = coremove.CopyLocation(treeBaseLocation),
        buildFromAbove = true,
        replacePresentObjects = false,
        pattern = enterprise_forest.tree_pattern,
        materialsHostLocator = materialsHostLocator,
    }
    corelog.WriteToLog(">Building tree (forest pattern) at "..textutils.serialise(buildData.startpoint))
    enterprise_construction.BuildRectangularPattern_ASrv(buildData, callback, callbackData)
end

function CanProduce_QSrv(serviceData)
    --[[
        This sync public query service answers the question if this Producer can produce specific items.
        
        Return value:
                                    - (table)
                success             - (boolean) whether the answer to the question is true

        Parameters:
            serviceData             - (table) data to the query
                productItemName     - (string) name of item to produce
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_colonization.CanProduce_QSrv: Invalid serviceData") return {success = false} end
    local productItemName = serviceData.productItemName
    if type(productItemName) ~= "string" then corelog.Error("enterprise_colonization.CanProduce_QSrv: Invalid productItemName") return {success = false} end

    -- check for birchlog or sapling
    if productItemName == "minecraft:birch_log" then
    elseif productItemName == "minecraft:birch_sapling" then
    else
        return {success = false}
    end
    -- end
    return {
        success         = true,
    }
end

function ProduceItem_ASrv(serviceData, callback, callbackData) -- ToDo: move to enterprise_forest_birch
    --[[
        This async public Producer service produces multiple instances of a specific item in the enterprise. It does so 
        by ...

        Finally it delivers the created items to the requested destination.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed correctly
                destinationItemsLocator - (URL) locating the final Storage and the items that where transferred to it
                                            (upon service succes the "host" component of this URL should be equal to destinationHostLocator, and
                                            the "query" should be equal to orderItems)

        Parameters:
            serviceData                 - (table) data for the service
                productItemName         - (string) name of item to produce
                productItemCount        - (number) amount of items to produce
                ingredientsHostLocator  - (URL) locating where the production ingredients can be retrieved
                destinationHostLocator  - (URL) locating where the produced items need to be delivered to
                assignmentsPriorityKey  - (string) priorityKey that should be set for all assignments triggered by this service
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_colonization.ProduceItem_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productItemName = serviceData.productItemName
    if type(productItemName) ~= "string" then corelog.Error("enterprise_colonization.ProduceItem_ASrv: Invalid productItemName") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productItemCount = serviceData.productItemCount
    if type(productItemCount) ~= "number" then corelog.Error("enterprise_colonization.ProduceItem_ASrv: Invalid productItemCount") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local ingredientsHostLocator = url.URLClass:new(serviceData.ingredientsHostLocator)
    if type(ingredientsHostLocator) ~= "table" then corelog.Error("enterprise_colonization.ProduceItem_ASrv: Invalid ingredientsHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local destinationHostLocator = url.URLClass:new(serviceData.destinationHostLocator)
    if type(destinationHostLocator) ~= "table" then corelog.Error("enterprise_colonization.ProduceItem_ASrv: Invalid destinationHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = serviceData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_colonization.ProduceItem_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_colonization.ProduceItem_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- get forest
    local forest = coredht.GetData(db.dhtRoot, db.dhtForest)

    -- check for birchlog or sapling
    local localSupplierLocator = nil
    if productItemName == "minecraft:birch_log" then
        localSupplierLocator = GetLocalLogsLocator()
    elseif productItemName == "minecraft:birch_sapling" then
        localSupplierLocator = GetLocalSaplingsLocator()
    else
        corelog.Error("enterprise_colonization.ProduceItem_ASrv: This is not a producer for item "..productItemName) return coreutils.DoCallback(callback, callbackData, {success = false})
    end

    -- check items already available in localSupplierLocator
    local localItemsLocator = localSupplierLocator:copy()
    local productItemsQuery = { [productItemName] = productItemCount }
    localItemsLocator:setQuery(productItemsQuery)
    if enterprise_isp.ItemsAvailableVia_SSrv( { itemsLocator = localItemsLocator} ).success then
        -- yes: return the items
        local transferData = {
            sourceItemsLocator      = localItemsLocator,
            destinationHostLocator  = destinationHostLocator,
            assignmentsPriorityKey  = assignmentsPriorityKey,
        }
        corelog.WriteToLog(">Procuring from local forest Supplier: "..textutils.serialise(productItemsQuery).."")
        enterprise_isp.TransferItemsFromTo_ASrv(transferData, callback, callbackData)
    else
        -- construct taskData
        local harvestForestTaskData = {
            firstTreeLocation   = coremove.GetRelativeLocation(forest.location, 3, 2, 0),
            nTrees              = forest.nTrees,

            priorityKey         = assignmentsPriorityKey,
        }

        -- create project service data
        local projectDef = {
            steps = {
                -- ToDo: consider retrieving birchSapling from it's local localSupplierLocator 
                --          (or will this be part of harvestForest?)
                { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                    { keyDef = "taskFunctionName"       , valueSource = 0, keyDefSource = "harvestForest_Task" },
                    { keyDef = "metaData"               , valueSource = 0, keyDefSource = "harvestForestMetaData" },
                    { keyDef = "taskData"               , valueSource = 0, keyDefSource = "harvestForestTaskData" },
                }},
                -- ToDo: consider storing the harvested goods in the local localSupplierLocator's for birch_log and birchSapling 
                --          (or will this be part of harvestForest?)
                -- ToDo: consider storing rest/ waste materials (e.g. sticks)
                { stepName = "enterprise_colonization.ProduceItem_ASrv", async = true, stepDataDef = { -- note: recursive call
                    { keyDef = "productItemName"        , valueSource = 0, keyDefSource = "productItemName" },
                    { keyDef = "productItemCount"       , valueSource = 0, keyDefSource = "productItemCount" },
                    { keyDef = "ingredientsHostLocator" , valueSource = 0, keyDefSource = "ingredientsHostLocator" },
                    { keyDef = "destinationHostLocator" , valueSource = 0, keyDefSource = "destinationHostLocator" },
                    { keyDef = "assignmentsPriorityKey" , valueSource = 0, keyDefSource = "assignmentsPriorityKey" },
                }},
                { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                    { keyDef = "success1"               , valueSource = 1, keyDefSource = "success" },
                    { keyDef = "success2"               , valueSource = 2, keyDefSource = "success" },
                }},
            },
            returnData  = {
                { keyDef = "success"                    , valueSource = 3, keyDefSource = "success" },
                { keyDef = "destinationItemsLocator"    , valueSource = 2, keyDefSource = "destinationItemsLocator" },
            }
        }
        local projectData = {
            productItemName         = productItemName,
            productItemCount        = productItemCount, -- ToDo: consider lower count with possible # items already present in localSupplierLocator
            ingredientsHostLocator  = ingredientsHostLocator:copy(),
            destinationHostLocator  = destinationHostLocator:copy(),

            harvestForest_Task      = "role_settler.HarvestForest_Task",
            harvestForestTaskData   = harvestForestTaskData,
            harvestForestMetaData   = role_settler.HarvestForest_MetaData(harvestForestTaskData),

            assignmentsPriorityKey  = assignmentsPriorityKey,
        }
        local projectServiceData = {
            projectDef  = projectDef,
            projectData = projectData,
        }

        -- start project
        corelog.WriteToLog(">Harvesting from forest: "..textutils.serialise(productItemsQuery).."")
        enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
    end
end

function GetLocalLogsLocator()
    -- ToDo: generalise this, e.g. make a property of the specific forest (could for example also be a chest)
    return enterprise_turtle.GetHostLocator_SSrv({ }).hostLocator
end

function GetLocalSaplingsLocator()
    -- ToDo: generalise this, e.g. make a property of the specific forest (could for example also be a chest)
    return enterprise_turtle.GetHostLocator_SSrv({ }).hostLocator
end
