local db = {
    dhtRoot     = "enterprise_colonization",
    dhtForest   = "forest", -- ToDo: consider allowing multiple (once part of enterprise_woods)
    hostName    = "colonization",
}

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function CreateNewWorld_ASrv(serviceData, callback, callbackData)
    --[[
        This public async service creates a new CCWorldPlatform world.
            It bootstraps the world logic by building an initiating several enterprise (sites). 

            The turtle should already have (either equiped or in it's inventory)
                one modem
                one axe
                one crafting station
                one birchSapling
            It is not necessary for the turtle to have any energy. The turtle will start by placing the sapling in front of itself.

            The function also defines the coordinate system by assuming the turtle starts at the location {x= 3, y= 2, z= 1, dx=0, dy=1}. This
            allows for the initial forest that is build to fit in the 6x6 grid that is used in patterns with the lower left coordinate of the base 
            of that forest being location {x= 0, y= 0, z= 1, dx=0, dy=1}

        Return value:
            nil

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the service executed successfully

        Parameters:
            serviceData         - (table) data about the service
                <currently none>
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function
    --]]

    -- check input
    if type(callback) ~= "string" then corelog.Error("enterprise_colonization.CreateNewWorld_ASrv: callback not a string") return false end

    -- ensure enterprise has a key in the dht
    if coredht.GetData(db.dhtRoot) == nil then
        -- create the entry
        coredht.SaveData({}, db.dhtRoot)

        -- reset forest
        ResetForest()
    end

    -- get forest
    local forest = coredht.GetData(db.dhtRoot, db.dhtForest)

    -- construct arguments
    local startLocation             = {x= 3, y= 2, z= 1, dx=0, dy=1}
    local primaryTaskData =  {
        startLocation               = coremove.CopyLocation(startLocation),
    }
    local factoryLocation           = {x=12, y= 0, z= 1, dx=0, dy=1}
    local treesNeeded = 6
    local settleData = {
        materialsHostLocator        = enterprise_shop.GetHostLocator_SSrv({ }).hostLocator,

        primaryTaskData             = primaryTaskData,
        startLocation               = coremove.CopyLocation(startLocation),

        plantFirstSaplingMetaData   = role_settler.PlantFirstSapling_MetaData(primaryTaskData),
        plantFirstSapling_Task      = "role_settler.PlantFirstSapling_Task",

        factoryVersion0             = "v0",
        upgradeFalse                = false,

        waitFirstTreeMetaData       = role_settler.WaitFirstTree_MetaData(primaryTaskData),
        waitFirstTree_Task          = "role_settler.WaitFirstTree_Task",

        ingredientsSupplierLocator  = enterprise_shop.GetHostLocator_SSrv({ }).hostLocator, -- ToDo: somehow pass this to enterprise_energy

        chopFirstTreeMetaData       = role_settler.ChopFirstTree_MetaData(primaryTaskData),
        chopFirstTree_Task          = "role_settler.ChopFirstTree_Task",

        forestFirstTree             = 1,

        collectCobbleStoneMetaData  = role_settler.CollectCobbleStone_MetaData(primaryTaskData),
        collectCobbleStone_Task     = "role_settler.CollectCobbleStone_Task",

        factoryLocation             = coremove.CopyLocation(factoryLocation),
        factoryVersion1             = "v1",

        treesNeeded                 = treesNeeded,

        forestLocation              = coremove.CopyLocation(forest.location),
        forestV2BasePattern         = role_builder.CopyPattern(enterprise_forest.tree_pattern), -- ToDo: use a new pattern including chests
        forestBuildFromAbove        = true,
        forestReplacePresentObjects = false,

        factoryVersion2             = "v2",
        upgradeToV2                 = true,

        siloLocation                = {x=12, y=12, z= 1, dx=0, dy=1},
        type                        = "silo",
        siloType                    = "basic",
        topChests                   = 2,
        layers                      = 2,
    }

    -- create project definition
    local createNewWorldProjectDef = {
        steps   = {
            { stepName = "enterprise_factory.BuildAndStartNewSite_ASrv", async = true, stepDataDef = {
                { keyDef = "baseLocation"               , valueSource = 0, keyDefSource = "startLocation" },
                { keyDef = "siteVersion"                , valueSource = 0, keyDefSource = "factoryVersion0" },
                { keyDef = "upgrade"                    , valueSource = 0, keyDefSource = "upgradeFalse" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            -- ToDo: implement forest related steps in/ via enterprise_wood/ forest
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"           , valueSource = 0, keyDefSource = "plantFirstSapling_Task" },
                { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "plantFirstSaplingMetaData" },
                { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "primaryTaskData" },
            }},
            { stepName = "enterprise_colonization.UpdateForestInfo_SSrv", async = false, stepDataDef = {
                { keyDef = "forestNTrees"               , valueSource = 0, keyDefSource = "forestFirstTree" },
            }},
            -- ToDo: consider calling HarvestForest_Task
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"           , valueSource = 0, keyDefSource = "waitFirstTree_Task" },
                { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "waitFirstTreeMetaData" },
                { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "primaryTaskData" },
            }},
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"           , valueSource = 0, keyDefSource = "chopFirstTree_Task" },
                { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "chopFirstTreeMetaData" },
                { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "primaryTaskData" },
            }},
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"           , valueSource = 0, keyDefSource = "collectCobbleStone_Task" },
                { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "collectCobbleStoneMetaData" },
                { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "primaryTaskData" },
            }},
            { stepName = "enterprise_factory.BuildAndStartNewSite_ASrv", async = true, stepDataDef = {
                { keyDef = "baseLocation"               , valueSource = 0, keyDefSource = "factoryLocation" },
                { keyDef = "siteVersion"                , valueSource = 0, keyDefSource = "factoryVersion1" },
                { keyDef = "upgrade"                    , valueSource = 0, keyDefSource = "upgradeFalse" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            { stepName = "enterprise_factory.StopAndDismantleSite_ASrv", async = true, stepDataDef = {
                { keyDef = "baseLocation"               , valueSource = 0, keyDefSource = "startLocation" },
                { keyDef = "siteVersion"                , valueSource = 0, keyDefSource = "factoryVersion0" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            { stepName = "enterprise_colonization.ExtendForest_ASrv", async = true, stepDataDef = {
                { keyDef = "forestLocation"             , valueSource = 0, keyDefSource = "forestLocation" },
                { keyDef = "treesNeeded"                , valueSource = 0, keyDefSource = "treesNeeded" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            -- Finish Forest ("redo base/ first tree according to pattern")
            -- ToDo: consider changing this to a forest service that upgrades the forest to next level (v1 or v2 (incl chests))
            { stepName = "enterprise_construction.BuildRectangularPattern_ASrv", async = true, stepDataDef = {
                { keyDef = "startpoint"                 , valueSource = 0, keyDefSource = "forestLocation" },
                { keyDef = "buildFromAbove"             , valueSource = 0, keyDefSource = "forestBuildFromAbove" },
                { keyDef = "replacePresentObjects"      , valueSource = 0, keyDefSource = "forestReplacePresentObjects" },
                { keyDef = "pattern"                    , valueSource = 0, keyDefSource = "forestV2BasePattern" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            { stepName = "enterprise_factory.BuildAndStartNewSite_ASrv", async = true, stepDataDef = {
                { keyDef = "baseLocation"               , valueSource = 0, keyDefSource = "factoryLocation" },
                { keyDef = "siteVersion"                , valueSource = 0, keyDefSource = "factoryVersion2" },
                { keyDef = "upgrade"                    , valueSource = 0, keyDefSource = "upgradeToV2" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            { stepName = "enterprise_storage.BuildAndStartNewSite_ASrv", async = true, stepDataDef = {
                { keyDef = "location"                   , valueSource = 0, keyDefSource = "siloLocation" },
                { keyDef = "type"                       , valueSource = 0, keyDefSource = "type" },
                { keyDef = "siloType"                   , valueSource = 0, keyDefSource = "siloType" },
                { keyDef = "topChests"                  , valueSource = 0, keyDefSource = "topChests" },
                { keyDef = "layers"                     , valueSource = 0, keyDefSource = "layers" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                { keyDef = "success1"                   , valueSource = 1, keyDefSource = "success" },
                { keyDef = "success2"                   , valueSource = 2, keyDefSource = "success" },
                { keyDef = "success3"                   , valueSource = 3, keyDefSource = "success" },
                { keyDef = "success4"                   , valueSource = 4, keyDefSource = "success" },
                { keyDef = "success5"                   , valueSource = 5, keyDefSource = "success" },
                { keyDef = "success6"                   , valueSource = 6, keyDefSource = "success" },
                { keyDef = "success7"                   , valueSource = 7, keyDefSource = "success" },
                { keyDef = "success8"                   , valueSource = 8, keyDefSource = "success" },
                { keyDef = "success9"                   , valueSource = 9, keyDefSource = "success" },
                { keyDef = "success10"                  , valueSource = 10, keyDefSource = "success" },
                { keyDef = "success11"                  , valueSource = 11, keyDefSource = "success" },
                { keyDef = "success12"                  , valueSource = 12, keyDefSource = "success" },
                { keyDef = "success13"                  , valueSource = 13, keyDefSource = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                        , valueSource = 14, keyDefSource = "success" },
        }
    }
    local projectServiceData = {
        projectDef  = createNewWorldProjectDef,
        projectData = settleData,
    }

    -- start project
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function ResetForest()
    coredht.SaveData({
        location    = {x= 0, y= 0, z= 1, dx=0, dy=1},
        nTrees      = 0,
    }, db.dhtRoot, db.dhtForest)
end

function ExtendForest_ASrv(serviceData, callback, callbackData)
    --[[
        This private async service extends the forest from 1 tree to a number of trees.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully

        Parameters:
            serviceData                 - (table) data about the service
                forestLocation          - (table) base location of factory
                treesNeeded             - (number) number of trees to extend forest to
                materialsHostLocator    - (URL) locating the host of the building materials
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local forestLocation = serviceData.forestLocation
    if type(forestLocation) ~= "table" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid forestLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local treesNeeded = serviceData.treesNeeded
    if type(treesNeeded) ~= "number" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid treesNeeded") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local materialsHostLocator = url.URLClass:new(serviceData.materialsHostLocator)
    if type(materialsHostLocator) ~= "table" then corelog.Error("enterprise_colonization.BuildForestTree_ASrv: Invalid materialsHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- determine projectSteps and projectData
    local projectSteps = { }
    local areAllTrueStepDataDef = {}
    local projectData = {
        forestLocation          = forestLocation,
        materialsHostLocator    = materialsHostLocator,
    }

    -- get forest
    local forest = coredht.GetData(db.dhtRoot, db.dhtForest)

    -- add project step for all trees to add 
    local iStep = 0
    local forestNTrees = forest.nTrees    -- note: first already created in PlantFirstSapling_Task
    for iTree = forestNTrees + 1, treesNeeded do
        -- ToDo: simplify looping (currentNTreesStr and newNTreesStr are related/ almost the same)

        -- add collect and build tree step
        iStep = iStep + 1
        local iStepStr = tostring(iStep)
        local currentNTreesStr = "currentNTreeStep"..iStepStr
        table.insert(projectSteps,
            { stepName = "enterprise_colonization.CollectAndBuildForestTree_ASrv", async = true, stepDataDef = {
                { keyDef = "forestLocation"         , valueSource = 0, keyDefSource = "forestLocation" },
                { keyDef = "currentNTrees"          , valueSource = 0, keyDefSource = currentNTreesStr },
                { keyDef = "materialsHostLocator"   , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }}
        )

        -- add step data
        projectData[currentNTreesStr] = iTree - 1

        -- add success stepDataDef
        table.insert(areAllTrueStepDataDef, { keyDef = "success"..iStepStr, valueSource = iStep, keyDefSource = "success" })

        -- update forest info
        iStep = iStep + 1
        iStepStr = tostring(iStep)
        local newNTreesStr = "newNTreeStep"..iStepStr
        table.insert(projectSteps,
            { stepName = "enterprise_colonization.UpdateForestInfo_SSrv", async = false, stepDataDef = {
                { keyDef = "forestNTrees"           , valueSource = 0, keyDefSource = newNTreesStr },
            }}
        )

        -- add step data
        projectData[newNTreesStr] = iTree

        -- add success stepDataDef
        table.insert(areAllTrueStepDataDef, { keyDef = "success"..iStepStr, valueSource = iStep, keyDefSource = "success" })
    end
    -- add check for all a success
    iStep = iStep + 1
    table.insert(projectSteps,
        { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = areAllTrueStepDataDef}
    )
    local iAreAllTrueStep = iStep

    -- create project service data
    local projectDef = {
        steps = projectSteps,
        returnData  = {
            { keyDef = "success"    , valueSource = iAreAllTrueStep, keyDefSource = "success" },
        }
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    corelog.WriteToLog(">Extending forest to " .. treesNeeded .. " trees")
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function CollectAndBuildForestTree_ASrv(serviceData, callback, callbackData)
    --[[
        This private async service first collects the resources and than extends the forest with 1 tree.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully

        Parameters:
            serviceData                 - (table) data about the service
                forestLocation          - (table) base location of factory
                currentNTrees           - (number) current number of trees in the forest
                materialsHostLocator    - (URL) locating the host of the building materials
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_colonization.CollectAndBuildForestTree_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local forestLocation = serviceData.forestLocation
    if type(forestLocation) ~= "table" then corelog.Error("enterprise_colonization.CollectAndBuildForestTree_ASrv: Invalid forestLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local currentNTrees = serviceData.currentNTrees
    if type(currentNTrees) ~= "number" then corelog.Error("enterprise_colonization.CollectAndBuildForestTree_ASrv: Invalid currentNTrees") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local materialsHostLocator = url.URLClass:new(serviceData.materialsHostLocator)
    if type(materialsHostLocator) ~= "table" then corelog.Error("enterprise_colonization.CollectAndBuildForestTree_ASrv: Invalid materialsHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_colonization.CollectAndBuildForestTree_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- create projectServiceData
    local treeBaseLocation = coremove.GetRelativeLocation(forestLocation, 0, 6 * currentNTrees, 0)
    local projectData = {
        treeBaseLocation        = treeBaseLocation,
        materialsHostLocator    = materialsHostLocator,
    }
    local projectDef = {
        steps = {
            { stepName = "enterprise_colonization.BuildForestTree_ASrv", async = true, stepDataDef = {
                { keyDef = "treeBaseLocation"       , valueSource = 0, keyDefSource = "treeBaseLocation" },
                { keyDef = "materialsHostLocator"   , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , valueSource = 1, keyDefSource = "success" },
        }
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    corelog.WriteToLog("  >Extending forest with one tree to "..(currentNTrees + 1).." trees")
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function UpdateForestInfo_SSrv(serviceData)
    --[[
        This private sync service updates the forest information.

        Return value:
                                        - (table)
                success                 - (boolean) whether the service executed successfully

        Parameters:
            serviceData                 - (table) data about the service
                forestNTrees            - (number) number of trees in the forest
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_colonization.UpdateForestInfo_SSrv: Invalid serviceData") return {success = false} end
    local forestNTrees = serviceData.forestNTrees
    if type(forestNTrees) ~= "number" then corelog.Error("enterprise_colonization.UpdateForestInfo_SSrv: Invalid forestNTrees") return {success = false} end

    -- get forest
    local forest = coredht.GetData(db.dhtRoot, db.dhtForest)

    -- set forest information
    forest.nTrees = forestNTrees

    -- save forest data
    coredht.SaveData(forest, db.dhtRoot, db.dhtForest)

    -- end
    return {success = true}
end

function BuildForestTree_ASrv(serviceData, callback, callbackData)
    --[[
        This private async service extends the forest with 1 tree

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully

        Parameters:
            serviceData                 - (table) data about this service
                treeBaseLocation        - (table) location of the base (lower left corner) of a forest tree (pattern)
                materialsHostLocator    - (URL) locating the host of the building materials
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_colonization.BuildForestTree_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local treeBaseLocation = serviceData.treeBaseLocation
    if type(treeBaseLocation) ~= "table" then corelog.Error("enterprise_colonization.BuildForestTree_ASrv: Invalid treeBaseLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local materialsHostLocator = url.URLClass:new(serviceData.materialsHostLocator)
    if type(materialsHostLocator) ~= "table" then corelog.Error("enterprise_colonization.BuildForestTree_ASrv: Invalid materialsHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_colonization.BuildForestTree_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- let construction enterprise build the tree
    local buildData = {
        startpoint = coremove.CopyLocation(treeBaseLocation),
        buildFromAbove = true,
        replacePresentObjects = false,
        pattern = enterprise_forest.tree_pattern,
        materialsHostLocator = materialsHostLocator,
    }
    corelog.WriteToLog(">Building tree (forest pattern) at "..textutils.serialise(buildData.startpoint))
    enterprise_construction.BuildRectangularPattern_ASrv(buildData, callback, callbackData)
end

function ProvideItemsTo_ASrv(serviceData, callback, callbackData) -- ToDo: move to enterprise_forest_birch
    --[[
        This async public Producer service produces multiple instances of a specific item in the enterprise. It does so 
        by ...

        Finally it delivers the created items to the requested Storage.

        Return value:
            nil

        Async service return value (to callback):
                                            - (table)
                success                     - (boolean) whether the service executed correctly
                destinationItemsLocator     - (URL) locating the final Storage and the items that where transferred to it
                                                (upon service succes the "host" component of this URL should be equal to destinationHostLocator, and
                                                the "query" should be equal to orderItems)

        Parameters:
            serviceData                     - (table) data for the service
                itemsLocator                - (URL) locating the items to provide
                                                (the "base" component of the URL specifies the Supplier that provides the items)
                                                (the "query" component of the URL specifies the items)
                storageLocator              - (URL) locating the Storage where the items need to be provided to
                ingredientsSupplierLocator  - (URL) locating where the production ingredients can be retrieved
                assignmentsPriorityKey      - (string) priorityKey that should be set for all assignments triggered by this service
            callback                        - (string) name of function to call once service is ready
            callbackData                    - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_colonization.ProvideItemsTo_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local itemsLocator = serviceData.itemsLocator
    if type(itemsLocator) ~= "string" then corelog.Error("enterprise_factory.ProvideItemsTo_ASrv: Invalid itemsLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local storageLocator = url.URLClass:new(serviceData.storageLocator)
    if type(storageLocator) ~= "table" then corelog.Error("enterprise_colonization.ProvideItemsTo_ASrv: Invalid storageLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local ingredientsSupplierLocator = url.URLClass:new(serviceData.ingredientsSupplierLocator)
    if type(ingredientsSupplierLocator) ~= "table" then corelog.Error("enterprise_colonization.ProvideItemsTo_ASrv: Invalid ingredientsSupplierLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = serviceData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_colonization.ProvideItemsTo_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_colonization.ProvideItemsTo_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- get forest
    local forest = coredht.GetData(db.dhtRoot, db.dhtForest)

    -- check itemsLocator is for this enterprise
    local serviceResults = IsColonizationURL_QSrv({ aURL = itemsLocator})
    if not serviceResults.success then corelog.Error("enterprise_colonization.ProvideItemsTo_ASrv: Invalid itemsLocator (="..itemsLocator:getURI()..").") return {success = false} end

    -- loop on items
    local provideItems = itemsLocator:getQuery()
    for itemName, itemCount in pairs(provideItems) do
        -- check
        if type(itemName) ~= "string" then corelog.Error("enterprise_colonization.ProvideItemsTo_ASrv: Invalid itemName (type="..type(itemName)..")") return coreutils.DoCallback(callback, callbackData, {success = false}) end
        if type(itemCount) ~= "number" then corelog.Error("enterprise_colonization.ProvideItemsTo_ASrv: Invalid itemCount (type="..type(itemCount)..")") return coreutils.DoCallback(callback, callbackData, {success = false}) end

        -- check for birchlog or sapling
        local localSupplierLocator = nil
        if itemName == "minecraft:birch_log" then
            localSupplierLocator = GetLocalLogsLocator()
        elseif itemName == "minecraft:birch_sapling" then
            localSupplierLocator = GetLocalSaplingsLocator()
        else
            corelog.Error("enterprise_colonization.ProvideItemsTo_ASrv: This is not a producer for item "..itemName) return coreutils.DoCallback(callback, callbackData, {success = false})
        end

        -- check items already available in localSupplierLocator
        local localItemsLocator = localSupplierLocator:copy()
        local productItemsQuery = { [itemName] = itemCount }
        localItemsLocator:setQuery(productItemsQuery)
        if enterprise_isp.ItemsAvailableVia_SSrv( { itemsLocator = localItemsLocator} ).success then
            -- yes: return the items
            local transferData = {
                sourceItemsLocator          = localItemsLocator,
                destinationStorageLocator   = storageLocator,
                assignmentsPriorityKey      = assignmentsPriorityKey,
            }
            corelog.WriteToLog(">Procuring from local forest Supplier: "..textutils.serialise(productItemsQuery).."")
            enterprise_isp.TransferItemsFromTo_ASrv(transferData, callback, callbackData)
        else
            -- construct taskData
            local harvestForestTaskData = {
                firstTreeLocation   = coremove.GetRelativeLocation(forest.location, 3, 2, 0),
                nTrees              = forest.nTrees,

                priorityKey         = assignmentsPriorityKey,
            }

            -- create project service data
            local projectDef = {
                steps = {
                    -- ToDo: consider retrieving birchSapling from it's local localSupplierLocator 
                    --          (or will this be part of harvestForest?)
                    { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                        { keyDef = "taskFunctionName"           , valueSource = 0, keyDefSource = "harvestForest_Task" },
                        { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "harvestForestMetaData" },
                        { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "harvestForestTaskData" },
                    }},
                    -- ToDo: consider storing the harvested goods in the local localSupplierLocator's for birch_log and birchSapling 
                    --          (or will this be part of harvestForest?)
                    -- ToDo: consider storing rest/ waste materials (e.g. sticks)
                    { stepName = "enterprise_colonization.ProvideItemsTo_ASrv", async = true, stepDataDef = { -- note: recursive call
                        { keyDef = "itemsLocator"               , valueSource = 0, keyDefSource = "itemsLocator" },
                        { keyDef = "storageLocator"             , valueSource = 0, keyDefSource = "storageLocator" },
                        { keyDef = "ingredientsSupplierLocator" , valueSource = 0, keyDefSource = "ingredientsSupplierLocator" },
                        { keyDef = "assignmentsPriorityKey"     , valueSource = 0, keyDefSource = "assignmentsPriorityKey" },
                    }},
                    { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                        { keyDef = "success1"                   , valueSource = 1, keyDefSource = "success" },
                        { keyDef = "success2"                   , valueSource = 2, keyDefSource = "success" },
                    }},
                },
                returnData  = {
                    { keyDef = "success"                        , valueSource = 3, keyDefSource = "success" },
                    { keyDef = "destinationItemsLocator"        , valueSource = 2, keyDefSource = "destinationItemsLocator" },
                }
            }
            local projectData = {
                itemsLocator                = itemsLocator, -- ToDo: consider lower count with possible # items already present in localSupplierLocator
                ingredientsSupplierLocator  = ingredientsSupplierLocator:copy(),
                storageLocator              = storageLocator:copy(),

                harvestForest_Task          = "role_settler.HarvestForest_Task",
                harvestForestTaskData       = harvestForestTaskData,
                harvestForestMetaData       = role_settler.HarvestForest_MetaData(harvestForestTaskData),

                assignmentsPriorityKey      = assignmentsPriorityKey,
            }
            local projectServiceData = {
                projectDef  = projectDef,
                projectData = projectData,
            }

            -- start project
            corelog.WriteToLog(">Harvesting from forest: "..textutils.serialise(productItemsQuery).."")
            enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
        end
    end
end

function Can_ProvideItems_QSrv(serviceData)
    --[[
        This sync public query service answers the question if this Supplier can provide specific items.
        
        Return value:
                                    - (table)
                success             - (boolean) whether the answer to the question is true

        Parameters:
            serviceData             - (table) data to the query
                itemName            - (string) name of item to provide
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_colonization.Can_ProvideItems_QSrv: Invalid serviceData") return {success = false} end
    local itemName = serviceData.itemName
    if type(itemName) ~= "string" then corelog.Error("enterprise_colonization.Can_ProvideItems_QSrv: Invalid itemName") return {success = false} end

    -- check for birchlog or sapling
    if itemName == "minecraft:birch_log" then
    elseif itemName == "minecraft:birch_sapling" then
    else
        return {success = false}
    end

    -- end
    return {
        success         = true,
    }
end

function GetISHURL()
    --[[
        This private function provides the (base) URL of this ISH.

        Return value:
            hostURL                 - (URL) locating this ISH

        Parameters:
            nil
    --]]

    local hostURL = url.URLClass:new()
    hostURL:setHost(db.hostName)

    return hostURL
end

function IsColonizationURL_QSrv(queryData)
    --[[
        This sync public service answers the question if a URL is that of a Colonization.
        
        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully

        Parameters:
            queryData               - (table) data about the query
                aURL                - (table) a URL that needs to be queried
    --]]

    -- check input
    if type(queryData) ~= "table" then corelog.Error("enterprise_chests.IsColonizationURL_QSrv: Invalid queryData") return {success = false} end
    local aURL = url.URLClass:new(queryData.aURL)
    if type(aURL) ~= "table" then corelog.Error("enterprise_chests.IsColonizationURL_QSrv: Invalid aURL") return {success = false} end

    -- check if of this Supplier
    local host = aURL:getHost()
    if type(host) ~= "string" then corelog.Error("enterprise_chests.IsColonizationURL_QSrv: Invalid host input in URL (="..aURL:getURI()..").") return {success = false} end
    if host == db.hostName then
        return {success = true}
    else
        return {success = false}
    end
end

function GetLocalLogsLocator()
    -- ToDo: generalise this, e.g. make a property of the specific forest (could for example also be a chest)
    return enterprise_turtle.GetHostLocator_SSrv({ }).hostLocator
end

function GetLocalSaplingsLocator()
    -- ToDo: generalise this, e.g. make a property of the specific forest (could for example also be a chest)
    return enterprise_turtle.GetHostLocator_SSrv({ }).hostLocator
end
