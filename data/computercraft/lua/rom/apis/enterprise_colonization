--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|


function CreateNewWorld_ASrv(serviceData, callback, callbackData)
    --[[
        This public async service creates a new CCWorldPlatform world.
            It bootstraps the world logic by building an initiating several enterprise (sites). 

            The turtle should already have (either equiped or in it's inventory)
                one modem
                one axe
                one crafting station
                one birchSapling
            It is not necessary for the turtle to have any energy. The turtle will start by placing the sapling in front of itself.

            The function also defines the coordinate system by assuming the turtle starts at the location {x= 3, y= 2, z= 1, dx=0, dy=1}. This
            allows for the initial forest that is build to fit in the 6x6 grid that is used in patterns with the lower left coordinate of the base 
            of that forest being location {x= 0, y= 0, z= 1, dx=0, dy=1}

        Return value:
            nil

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the service executed correctly

        Parameters:
            serviceData         - (table) data about the service
                <currently none>
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function
    --]]
    -- check input
    if type(callback) ~= "string" then corelog.Error("enterprise_colonization.CreateNewWorld_ASrv: callback not a string") return false end

    -- construct arguments
    local startLocation             = {x= 3, y= 2, z= 1, dx=0, dy=1}
    local forestLocation            = {x= 0, y= 0, z= 1, dx=0, dy=1}
    local primaryTaskData =  {
        startLocation               = coremove.CopyLocation(startLocation),
    }
    local initialRefuelItems        = { ["minecraft:birch_planks"] = 4 }
    local dummyTaskData =  {
    }
    local factoryLocation           = {x=12, y= 0, z= 1, dx=0, dy=1}
    local treesNeeded = 6
    local chestsNeeded = 24
    local torchesNeeded = 6
    local logsNeeded                = chestsNeeded * 2 + math.ceil(torchesNeeded / 2)
    local collectLogsTaskData = {
        startLocation               = coremove.CopyLocation(startLocation),
        factoryLocation             = coremove.CopyLocation(factoryLocation),
        nTrees                      = treesNeeded, -- note: it is assumed the needed trees are already there
        logsNeeded                  = logsNeeded,
    }
    local settleData = {
        materialsHostLocator        = enterprise_shop.GetHostLocator_SSrv({ }).hostLocator,

        primaryTaskData             = primaryTaskData,
        startLocation               = coremove.CopyLocation(startLocation),

        plantFirstSaplingMetaData   = role_settler.PlantFirstSapling_MetaData(primaryTaskData),
        plantFirstSapling_Task      = "role_settler.PlantFirstSapling_Task",

        factoryVersion0             = "v0",
        upgradeFalse                = false,

        waitFirstTreeMetaData       = role_settler.WaitFirstTree_MetaData(primaryTaskData),
        waitFirstTree_Task          = "role_settler.WaitFirstTree_Task",

        initialRefuelItems          = coreutils.DeepCopy(initialRefuelItems),

        chopFirstTreeMetaData       = role_settler.ChopFirstTree_MetaData(primaryTaskData),
        chopFirstTree_Task          = "role_settler.ChopFirstTree_Task",

        dummyTaskData               = dummyTaskData,
        reportStatusMetaData        = role_settler.ReportStatus_MetaData(dummyTaskData),
        reportStatus_Task           = "role_settler.ReportStatus_Task",

        collectCobbleStoneMetaData  = role_settler.CollectCobbleStone_MetaData(primaryTaskData),
        collectCobbleStone_Task     = "role_settler.CollectCobbleStone_Task",

        cleanupTask                 = "Cleanup",

        factoryLocation             = coremove.CopyLocation(factoryLocation),
        factoryVersion1             = "v1",

        treesNeeded                 = treesNeeded,

        collectLogs_Task            = "role_settler.CollectLogs_Task",
        collectLogsTaskData         = collectLogsTaskData,
        collectLogsMetaData         = role_settler.CollectLogs_MetaData(collectLogsTaskData),

        forestLocation              = coremove.CopyLocation(forestLocation),
        forestV2BasePattern         = role_builder.CopyPattern(enterprise_forest.tree_pattern), -- ToDo: use a new pattern including chests
        forestBuildFromAbove        = true,
        forestReplacePresentObjects = false,

        factoryVersion2             = "v2",
        upgradeToV2                 = true,

        siloLocation                = {x=12, y=12, z= 1, dx=0, dy=1},
        type                        = "silo",
        siloType                    = "basic",
        topChests                   = 2,
        layers                      = 2,
    }

    -- create project definition
    local createNewWorldProjectDef = {
        steps   = {
            -- ToDo: implement forest related steps in/ via enterprise_wood/ forest
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"           , valueSource = 0, keyDefSource = "plantFirstSapling_Task" },
                { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "plantFirstSaplingMetaData" },
                { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "primaryTaskData" },
            }},
            { stepName = "enterprise_factory.BuildAndStartNewSite_ASrv", async = true, stepDataDef = {
                { keyDef = "baseLocation"               , valueSource = 0, keyDefSource = "startLocation" },
                { keyDef = "siteVersion"                , valueSource = 0, keyDefSource = "factoryVersion0" },
                { keyDef = "upgrade"                    , valueSource = 0, keyDefSource = "upgradeFalse" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"           , valueSource = 0, keyDefSource = "waitFirstTree_Task" },
                { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "waitFirstTreeMetaData" },
                { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "primaryTaskData" },
            }},
            { stepName = "enterprise_colonization.Refuel_ASrv", async = true, stepDataDef = {
                { keyDef = "fuelItems"                  , valueSource = 0, keyDefSource = "initialRefuelItems" },
            }},
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"           , valueSource = 0, keyDefSource = "chopFirstTree_Task" },
                { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "chopFirstTreeMetaData" },
                { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "primaryTaskData" },
            }},
            { stepName = "enterprise_colonization.Refuel_ASrv", async = true, stepDataDef = {
                { keyDef = "fuelItems"                  , valueSource = 5, keyDefSource = "orderForFuel" },
            }},
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"           , valueSource = 0, keyDefSource = "reportStatus_Task" },
                { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "reportStatusMetaData" },
                { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "dummyTaskData" },
            }},
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"           , valueSource = 0, keyDefSource = "collectCobbleStone_Task" },
                { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "collectCobbleStoneMetaData" },
                { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "primaryTaskData" },
            }},
            { stepName = "enterprise_factory.BuildAndStartNewSite_ASrv", async = true, stepDataDef = {
                { keyDef = "baseLocation"               , valueSource = 0, keyDefSource = "factoryLocation" },
                { keyDef = "siteVersion"                , valueSource = 0, keyDefSource = "factoryVersion1" },
                { keyDef = "upgrade"                    , valueSource = 0, keyDefSource = "upgradeFalse" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            { stepName = "enterprise_factory.StopAndDismantleSite_ASrv", async = true, stepDataDef = {
                { keyDef = "baseLocation"               , valueSource = 0, keyDefSource = "startLocation" },
                { keyDef = "siteVersion"                , valueSource = 0, keyDefSource = "factoryVersion0" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            { stepName = "enterprise_colonization.ExtendForest_ASrv", async = true, stepDataDef = {
                { keyDef = "startLocation"              , valueSource = 0, keyDefSource = "startLocation" },
                { keyDef = "factoryLocation"            , valueSource = 0, keyDefSource = "factoryLocation" },
                { keyDef = "forestLocation"             , valueSource = 0, keyDefSource = "forestLocation" },
                { keyDef = "treesNeeded"                , valueSource = 0, keyDefSource = "treesNeeded" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            -- Collect enough logs to craft all remaining items (chests, torches, ...)
            -- ToDo: consider changing this to get it from forest service ProduceItem_ASrv
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"           , valueSource = 0, keyDefSource = "collectLogs_Task" },
                { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "collectLogsMetaData" },
                { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "collectLogsTaskData" },
            }},
            -- Finish Forest ("redo base/ first tree according to pattern")
            -- ToDo: consider changing this to a forest service that upgrades the forest to next level (v1 or v2 (incl chests))
            { stepName = "enterprise_construction.BuildRectangularPattern_ASrv", async = true, stepDataDef = {
                { keyDef = "startpoint"                 , valueSource = 0, keyDefSource = "forestLocation" },
                { keyDef = "buildFromAbove"             , valueSource = 0, keyDefSource = "forestBuildFromAbove" },
                { keyDef = "replacePresentObjects"      , valueSource = 0, keyDefSource = "forestReplacePresentObjects" },
                { keyDef = "pattern"                    , valueSource = 0, keyDefSource = "forestV2BasePattern" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            { stepName = "enterprise_factory.BuildAndStartNewSite_ASrv", async = true, stepDataDef = {
                { keyDef = "baseLocation"               , valueSource = 0, keyDefSource = "factoryLocation" },
                { keyDef = "siteVersion"                , valueSource = 0, keyDefSource = "factoryVersion2" },
                { keyDef = "upgrade"                    , valueSource = 0, keyDefSource = "upgradeToV2" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            { stepName = "enterprise_storage.BuildAndStartNewSite_ASrv", async = true, stepDataDef = {
                { keyDef = "location"                   , valueSource = 0, keyDefSource = "siloLocation" },
                { keyDef = "type"                       , valueSource = 0, keyDefSource = "type" },
                { keyDef = "siloType"                   , valueSource = 0, keyDefSource = "siloType" },
                { keyDef = "topChests"                  , valueSource = 0, keyDefSource = "topChests" },
                { keyDef = "layers"                     , valueSource = 0, keyDefSource = "layers" },
                { keyDef = "materialsHostLocator"       , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                { keyDef = "success1"                   , valueSource = 1, keyDefSource = "success" },
                { keyDef = "success2"                   , valueSource = 2, keyDefSource = "success" },
                { keyDef = "success3"                   , valueSource = 3, keyDefSource = "success" },
                { keyDef = "success4"                   , valueSource = 4, keyDefSource = "success" },
                { keyDef = "success5"                   , valueSource = 5, keyDefSource = "success" },
                { keyDef = "success6"                   , valueSource = 6, keyDefSource = "success" },
                { keyDef = "success7"                   , valueSource = 7, keyDefSource = "success" },
                { keyDef = "success8"                   , valueSource = 8, keyDefSource = "success" },
                { keyDef = "success9"                   , valueSource = 9, keyDefSource = "success" },
                { keyDef = "success10"                  , valueSource = 10, keyDefSource = "success" },
                { keyDef = "success11"                  , valueSource = 11, keyDefSource = "success" },
                { keyDef = "success12"                  , valueSource = 12, keyDefSource = "success" },
                { keyDef = "success13"                  , valueSource = 13, keyDefSource = "success" },
                { keyDef = "success14"                  , valueSource = 14, keyDefSource = "success" },
                { keyDef = "success15"                  , valueSource = 15, keyDefSource = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                        , valueSource = 16, keyDefSource = "success" },
        }
    }
    local projectServiceData = {
        projectDef  = createNewWorldProjectDef,
        projectData = settleData,
    }

    -- start project
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function ExtendForest_ASrv(serviceData, callback, callbackData)
    --[[
        This private async service extends the forest from 1 tree to a number of trees.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed correctly

        Parameters:
            serviceData                 - (table) data about the service
                startLocation           - (table) location where first steps are taken
                factoryLocation         - (table) location of the factory to use
                forestLocation          - (table) base location of factory
                treesNeeded             - (number) number of trees to extend forest to
                materialsHostLocator    - (URL) locating the host of the building materials
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local startLocation = serviceData.startLocation
    if type(startLocation) ~= "table" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid startLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local factoryLocation = serviceData.factoryLocation
    if type(factoryLocation) ~= "table" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid factoryLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local forestLocation = serviceData.forestLocation
    if type(forestLocation) ~= "table" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid forestLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local treesNeeded = serviceData.treesNeeded
    if type(treesNeeded) ~= "number" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid treesNeeded") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local materialsHostLocator = url.URLClass:new(serviceData.materialsHostLocator)
    if type(materialsHostLocator) ~= "table" then corelog.Error("enterprise_colonization.BuildForestTree_ASrv: Invalid materialsHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- determine projectSteps and projectData
    local projectSteps = { }
    local areAllTrueStepDataDef = {}
    local projectData = {
        startLocation           = startLocation,
        factoryLocation         = factoryLocation,
        forestLocation          = forestLocation,
        materialsHostLocator    = materialsHostLocator,
    }

    -- add project step for all trees to add 
    local iStep = 0
    for iTree = 2, treesNeeded do -- note: first already created in PlantFirstSapling_Task
        -- step index
        iStep = iStep + 1
        local iStepStr = tostring(iStep)

        -- add collect and build tree step
        local currentNTrees = "currentNTreeStep"..iStepStr
        table.insert(projectSteps,
            { stepName = "enterprise_colonization.CollectAndBuildForestTree_ASrv", async = true, stepDataDef = {
                { keyDef = "startLocation"          , valueSource = 0, keyDefSource = "startLocation" },
                { keyDef = "factoryLocation"        , valueSource = 0, keyDefSource = "factoryLocation" },
                { keyDef = "forestLocation"         , valueSource = 0, keyDefSource = "forestLocation" },
                { keyDef = "currentNTrees"          , valueSource = 0, keyDefSource = currentNTrees },
                { keyDef = "materialsHostLocator"   , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }}
        )

        -- add step data
        projectData[currentNTrees] = iTree - 1

        -- add success stepDataDef
        table.insert(areAllTrueStepDataDef, { keyDef = "success"..iStepStr, valueSource = iStep, keyDefSource = "success" })
    end
    -- add check for all a success
    iStep = iStep + 1
    table.insert(projectSteps,
        { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = areAllTrueStepDataDef}
    )
    local iAreAllTrueStep = iStep

    -- create project service data
    local projectDef = {
        steps = projectSteps,
        returnData  = {
            { keyDef = "success"    , valueSource = iAreAllTrueStep, keyDefSource = "success" },
        }
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    corelog.WriteToLog(">Extending forest to " .. treesNeeded .. " trees")
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function CollectAndBuildForestTree_ASrv(serviceData, callback, callbackData)
    --[[
        This private async service first collects the resources and than extends the forest with 1 tree.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed correctly

        Parameters:
            serviceData                 - (table) data about the service
                startLocation           - (table) location where first steps are taken
                factoryLocation         - (table) location of the factory to use
                forestLocation          - (table) base location of factory
                currentNTrees           - (number) current number of trees in the forest
                materialsHostLocator    - (URL) locating the host of the building materials
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local startLocation = serviceData.startLocation
    if type(startLocation) ~= "table" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid startLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local factoryLocation = serviceData.factoryLocation
    if type(factoryLocation) ~= "table" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid factoryLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local forestLocation = serviceData.forestLocation
    if type(forestLocation) ~= "table" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid forestLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local currentNTrees = serviceData.currentNTrees
    if type(currentNTrees) ~= "number" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid currentNTrees") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local materialsHostLocator = url.URLClass:new(serviceData.materialsHostLocator)
    if type(materialsHostLocator) ~= "table" then corelog.Error("enterprise_colonization.BuildForestTree_ASrv: Invalid materialsHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_colonization.ExtendForest_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- create projectServiceData
    local collectLogsTaskData = {
        startLocation           = coremove.CopyLocation(startLocation),
        factoryLocation         = coremove.CopyLocation(factoryLocation),
        nTrees                  = currentNTrees,
        logsNeeded              = 2,
    }
    local collectSaplingsTaskData = {
        startLocation           = coremove.CopyLocation(startLocation),
        factoryLocation         = coremove.CopyLocation(factoryLocation),
        nTrees                  = currentNTrees,
        saplingsNeeded          = 1,
    }
    local treeBaseLocation = coremove.GetRelativeLocation(forestLocation, 0, 6 * currentNTrees, 0)
    local projectData = {
        collectLogs_Task        = "role_settler.CollectLogs_Task",
        collectLogsTaskData     = collectLogsTaskData,
        collectLogsMetaData     = role_settler.CollectLogs_MetaData(collectLogsTaskData),

        collectSaplings_Task    = "role_settler.CollectSaplings_Task",
        collectSaplingsTaskData = collectSaplingsTaskData,
        collectSaplingsMetaData = role_settler.CollectSaplings_MetaData(collectSaplingsTaskData),

        orderTorches            = { ["minecraft:torch"] = 2 },

        treeBaseLocation        = treeBaseLocation,
        materialsHostLocator    = materialsHostLocator,
    }
    local projectDef = {
        steps = {
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"       , valueSource = 0, keyDefSource = "collectLogs_Task" },
                { keyDef = "metaData"               , valueSource = 0, keyDefSource = "collectLogsMetaData" },
                { keyDef = "taskData"               , valueSource = 0, keyDefSource = "collectLogsTaskData" },
            }},
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"       , valueSource = 0, keyDefSource = "collectSaplings_Task" },
                { keyDef = "metaData"               , valueSource = 0, keyDefSource = "collectSaplingsMetaData" },
                { keyDef = "taskData"               , valueSource = 0, keyDefSource = "collectSaplingsTaskData" },
            }},
            { stepName = "enterprise_turtle.GetHostLocator_SSrv", async = false, stepDataDef = {
            }},
            { stepName = "enterprise_shop.OrderItems_ASrv", async = true, stepDataDef = {
                { keyDef = "orderItems"             , valueSource = 0, keyDefSource = "orderTorches" },
                { keyDef = "destinationHostLocator" , valueSource = 3, keyDefSource = "hostLocator" },
            }},
            { stepName = "enterprise_colonization.BuildForestTree_ASrv", async = true, stepDataDef = {
                { keyDef = "treeBaseLocation"       , valueSource = 0, keyDefSource = "treeBaseLocation" },
                { keyDef = "materialsHostLocator"   , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
            { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                { keyDef = "success1"               , valueSource = 1, keyDefSource = "success" },
                { keyDef = "success2"               , valueSource = 2, keyDefSource = "success" },
                { keyDef = "success3"               , valueSource = 3, keyDefSource = "success" },
                { keyDef = "success4"               , valueSource = 4, keyDefSource = "success" },
                { keyDef = "success5"               , valueSource = 5, keyDefSource = "success" },
            }},            },
        returnData  = {
            { keyDef = "success"                    , valueSource = 6, keyDefSource = "success" },
        }
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    corelog.WriteToLog("  >Extending forest with one tree to "..(currentNTrees + 1).." trees")
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function BuildForestTree_ASrv(serviceData, callback, callbackData)
    --[[
        This private async service extends the forest with 1 tree

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed correctly

        Parameters:
            serviceData                 - (table) data about this service
                treeBaseLocation        - (table) location of the base (lower left corner) of a forest tree (pattern)
                materialsHostLocator    - (URL) locating the host of the building materials
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_colonization.BuildForestTree_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local treeBaseLocation = serviceData.treeBaseLocation
    if type(treeBaseLocation) ~= "table" then corelog.Error("enterprise_colonization.BuildForestTree_ASrv: Invalid treeBaseLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local materialsHostLocator = url.URLClass:new(serviceData.materialsHostLocator)
    if type(materialsHostLocator) ~= "table" then corelog.Error("enterprise_colonization.BuildForestTree_ASrv: Invalid materialsHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_colonization.BuildForestTree_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- let construction enterprise build the tree
    local buildData = {
        startpoint = coremove.CopyLocation(treeBaseLocation),
        buildFromAbove = true,
        replacePresentObjects = false,
        pattern = enterprise_forest.tree_pattern,
        materialsHostLocator = materialsHostLocator,
    }
    corelog.WriteToLog(">Building tree (forest pattern) at "..textutils.serialise(buildData.startpoint))
    enterprise_construction.BuildRectangularPattern_ASrv(buildData, callback, callbackData)
end

function Refuel_ASrv(serviceData, callback, callbackData) -- ToDo: consider moving this service to a different enterprise
    --[[
        This private async service refuels the current turtle from fuelItems.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed correctly

        Parameters:
            serviceData                 - (table) data about this service
                fuelItems               - (table) with one or more items (formatted as an array of [itemName] = itemCount key-value pairs) to refuel with
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_colonization.Refuel_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local fuelItems = serviceData.fuelItems
    if type(fuelItems) ~= "table" then corelog.Error("enterprise_colonization.Refuel_ASrv: Invalid fuelItems") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_colonization.Refuel_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- create project service data
    local currentTurtleId = os.getComputerID()
    local turtleToRefuelLocator = enterprise_turtle.GetTurtleLocator_SSrv({turtleId = currentTurtleId}).turtleLocator
    local refuelTaskData = {
        fuelItems   = coreutils.DeepCopy(fuelItems),
    }
    local buildBlueprintProjectDef = {
        steps   = {
            { stepName = "enterprise_shop.OrderItems_ASrv", async = true, stepDataDef = {
                { keyDef = "orderItems"             , valueSource = 0, keyDefSource = "fuelItems" },
                { keyDef = "destinationHostLocator" , valueSource = 0, keyDefSource = "turtleToRefuelLocator" },
            }},
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"       , valueSource = 0, keyDefSource = "refuel_Task" },
                { keyDef = "metaData"               , valueSource = 0, keyDefSource = "refuelMetaData" },
                { keyDef = "taskData"               , valueSource = 0, keyDefSource = "refuelTaskData" },
            }},
            { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                { keyDef = "success1"               , valueSource = 1, keyDefSource = "success" },
                { keyDef = "success2"               , valueSource = 2, keyDefSource = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , valueSource = 3, keyDefSource = "success" },
        }
    }
    local projectData = {
        fuelItems                   = coreutils.DeepCopy(fuelItems),
        turtleToRefuelLocator       = turtleToRefuelLocator,

        refuel_Task                 = "role_settler.Refuel_Task",
        refuelMetaData              = role_settler.Refuel_MetaData(refuelTaskData),
        refuelTaskData              = refuelTaskData,
    }
    local projectServiceData = {
        projectDef  = buildBlueprintProjectDef,
        projectData = projectData,
    }

    -- start project
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end
