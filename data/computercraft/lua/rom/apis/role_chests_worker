function FetchChestSlotsInventory_MetaData(taskData)
    --[[
        This function returns the metadata for the FetchChestSlotsInventory_Task supplied with argument taskData.
    --]]

    -- check input
    if type(taskData) ~= "table" then corelog.Error("role_chests_worker.FetchChestSlotsInventory_MetaData: taskData not a valid") return {success = false} end
    local location = taskData.location
    if type(location) ~= "table" then corelog.Error("role_chests_worker.FetchChestSlotsInventory_MetaData: location not valid") return {success = false} end
    local accessDirection = taskData.accessDirection
    if type(accessDirection) ~= "string" then corelog.Error("role_chests_worker.FetchChestSlotsInventory_MetaData: invalid accessDirection") return {success = false} end

    -- determine needed items
    local workingLocation = GetWorkingLocation(location, accessDirection)
    local fuelNeeded = 5 -- task starts at workingLocation, very little (0) movement from there, a few extra to be sure

    -- return metadata
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(workingLocation),
        needTool = false,
        needTurtle = true,
        fuelNeeded = fuelNeeded,
        itemsNeeded = {}
    }
end

function FetchChestSlotsInventory_Task(taskData)
    --[[
        This Task function fetches the slots inventory of a chest.

        The slots inventory is retrieved by the list method as described here: https://tweaked.cc/generic_peripheral/inventory.html

        Return value:
                                - (table)
                success         - (boolean) when the inventory was succesfully retrieved
                slots           - (table) the slots inventory of a chest

        Parameters:
            taskData            - (table) data about the chest
                location        - (table) location of the chest
                accessDirection - (string) whether to access chest from front, back, up, down, left or right (relative to location)
    --]]

    -- check input
    if type(taskData) ~= "table" then corelog.Error("role_chests_worker.FetchChestSlotsInventory_Task: taskData not a valid") return {success = false} end
    local location = taskData.location
    if type(location) ~= "table" then corelog.Error("role_chests_worker.FetchChestSlotsInventory_Task: location not valid") return {success = false} end
    local accessDirection = taskData.accessDirection
    if type(accessDirection) ~= "string" then corelog.Error("role_chests_worker.FetchChestSlotsInventory_Task: invalid accessDirection") return {success = false} end

    -- move to workingLocation
    local workingLocation = GetWorkingLocation(location, accessDirection)
    if type(workingLocation) ~= "table" then corelog.Error("role_chests_worker.FetchChestSlotsInventory_Task: Failed to determine workingLocation") return {success = false} end
--    corelog.WriteToLog("  moving to workingLocation="..textutils.serialize(workingLocation))
    coremove.GoTo(workingLocation)

    -- get access to chest
    local peripheralName = GetPeripheralName(accessDirection)
    local chest = peripheral.wrap(peripheralName)
    if type(chest) ~= "table" then corelog.Error("role_chests_worker.FetchChestSlotsInventory_Task: No chest at "..textutils.serialize(location).." accessible from "..accessDirection..".") return {success = false} end

    -- get inventory
    local slots = chest.list()

    -- end
    local result = {
        success = true,
        slots = slots,
    }
    return result
end

function FetchItemsFromChestIntoTurtle_MetaData(taskData)
    --[[
        This function returns the metadata for the FetchItemsFromChestIntoTurtle_Task supplied with argument taskData.
    --]]

    -- check input
    if type(taskData) ~= "table" then corelog.Error("role_chests_worker.FetchItemsFromChestIntoTurtle_MetaData: taskData not valid") return {success = false} end
    local location = taskData.location
    if type(location) ~= "table" then corelog.Error("role_chests_worker.FetchItemsFromChestIntoTurtle_MetaData: location not valid") return {success = false} end
    local accessDirection = taskData.accessDirection
    if type(accessDirection) ~= "string" then corelog.Error("role_chests_worker.FetchItemsFromChestIntoTurtle_MetaData: invalid accessDirection") return {success = false} end
    local priorityKey = taskData.priorityKey
    if priorityKey and type(priorityKey) ~= "string" then corelog.Error("role_chests_worker.FetchItemsFromChestIntoTurtle_MetaData: Invalid priorityKey") return {success = false} end

    -- determine needed items
    local workingLocation = GetWorkingLocation(location, accessDirection)
    local fuelNeeded = 5 -- task starts at workingLocation, very little (0) movement from there, a few extra to be sure

    -- return metadata
    return {
        startTime   = coreutils.UniversalTime(),
        location    = coremove.CopyLocation(workingLocation),
        needTool    = false,
        needTurtle  = true,
        fuelNeeded  = fuelNeeded,
        itemsNeeded = {},

        priorityKey = taskData.priorityKey,
    }
end

function FetchItemsFromChestIntoTurtle_Task(taskData)
    --[[
        This Task function fetches items from a chest into the inventory of a turtle.

        Return value:
                                - (table)
                success         - (boolean) whether the items were succesfully fetched
                slots           - (table) the slots inventory of the chest (after the items have been removed)
                turtleId        - (number) id of the turtle that has items in it's inventory
                itemResultQuery - (table) items retrieved into turtle

        Parameters:
            taskData            - (table) data about the task
                location        - (table) location of the chest
                accessDirection - (string) whether to access chest from front, back, up, down, left or right (relative to location)
                itemsQuery      - (table) which items to be fetched
    --]]

    -- check input
    if type(taskData) ~= "table" then corelog.Error("role_chests_worker.FetchItemsFromChestIntoTurtle_Task: taskData not valid") return {success = false} end
    local location = taskData.location
    if type(location) ~= "table" then corelog.Error("role_chests_worker.FetchItemsFromChestIntoTurtle_Task: location not valid") return {success = false} end
    local accessDirection = taskData.accessDirection
    if type(accessDirection) ~= "string" then corelog.Error("role_chests_worker.FetchItemsFromChestIntoTurtle_Task: invalid accessDirection") return {success = false} end
    local itemsQuery = taskData.itemsQuery
    if type(itemsQuery) ~= "table" then corelog.Error("role_chests_worker.FetchItemsFromChestIntoTurtle_Task: invalid itemsQuery") return {success = false} end

    -- move to workingLocation
    local workingLocation = GetWorkingLocation(location, accessDirection)
    if type(workingLocation) ~= "table" then corelog.Error("role_chests_worker.FetchItemsFromChestIntoTurtle_Task: Failed to determine workingLocation") return {success = false} end
--    corelog.WriteToLog("  moving to workingLocation="..textutils.serialize(workingLocation))
    coremove.GoTo(workingLocation)

    -- get access to chest
    local chestName = GetPeripheralName(accessDirection)
    local chest = peripheral.wrap(chestName)
    if type(chest) ~= "table" then corelog.Error("role_chests_worker.FetchItemsFromChestIntoTurtle_Task: No chest at "..textutils.serialize(location).." accessible from "..accessDirection..".") return {success = false} end

    -- loop on requested items
    local itemResultQuery = {}
    for requestItemName, requestItemCount in pairs(itemsQuery) do
        -- check
        if type(requestItemName) ~= "string" then corelog.Error("role_chests_worker.FetchItemsFromChestIntoTurtle_Task: requestItemName of wrong type = "..type(requestItemName)..".") return {success = false} end
        if type(requestItemCount) ~= "number" then corelog.Error("role_chests_worker.FetchItemsFromChestIntoTurtle_Task: requestItemCount of wrong type = "..type(requestItemCount)..".") return {success = false} end
--        corelog.WriteToLog("   fetching "..requestItemCount.." "..requestItemName.."'s from chest into turtle")

        -- check enough items
        local items = DetermineItemsInventory(chest.list())
        if not items[requestItemName] or items[requestItemName] < requestItemCount then corelog.Error("role_chests_worker.FetchItemsFromChestIntoTurtle_Task: not enough (="..requestItemCount..") "..requestItemName.." items available (="..(items[requestItemName] or "0")..") in chest.") return {success = false} end

        -- empty first slot
        local firstSlot = 1
        if not MakeSlotEmpty(chestName, firstSlot) then corelog.Error("role_chests_worker.FetchItemsFromChestIntoTurtle_Task: Failed making slot "..firstSlot.." empty.") return {success = false} end

        -- transfer to first slot and suck until enough
--        slots = chest.list()
        local remainingItemsToMove = requestItemCount
--        for slot, chestItem in pairs(slots) do
        for iSlot = 1, chest.size() do
                -- skip firstSlot
            if iSlot ~= firstSlot then
                -- get item details
                local chestItem = chest.getItemDetail(iSlot)
--                if type(chestItem) ~= "table" then corelog.Error("role_chests_worker.FetchItemsFromChestIntoTurtle_Task: chestItem of wrong type = "..type(chestItem)..".") return 0 end

                -- requested item in slot?
                if chestItem and chestItem.name == requestItemName then
                    -- move items to 
                    local countToMove = math.min(remainingItemsToMove, chestItem.count)
--                    corelog.WriteToLog("   moving "..countToMove.." "..chestItem.name.." from slot "..iSlot.." to slot "..firstSlot)
                    chest.pushItems(chestName, iSlot, countToMove, firstSlot)

                    -- suck the items
                    local itemsSucked = Suck(chestName, countToMove)
--                    corelog.WriteToLog("   itemsSucked "..itemsSucked)
                    if itemsSucked ~= countToMove then corelog.Error("role_chests_worker.FetchItemsFromChestIntoTurtle_Task: not enough (="..countToMove..") "..requestItemName.." items sucked (="..itemsSucked..") from chest.") return {success = false} end
                    itemResultQuery[requestItemName] = (itemResultQuery[requestItemName] or 0) + tonumber(itemsSucked)

                    -- more to move for this requested item?
                    remainingItemsToMove = remainingItemsToMove - countToMove
                    if remainingItemsToMove <= 0 then break end
                end
            end
        end
    end

    -- get final inventory
    local slots = chest.list()
    -- ToDo: consider double checking only exactly the requested items were moved to the turtle => itemResultQuery

    -- get turtleId
    local currentTurtleId = os.getComputerID()

    -- end
    local result = {
        success         = true,
        slots           = slots,
        turtleId        = currentTurtleId,
        itemResultQuery = itemResultQuery,
    }
    return result
end

function PutItemsFromTurtleIntoChest_MetaData(taskData)
    --[[
        This function returns the metadata for the PutItemsFromTurtleIntoChest_Task supplied with argument taskData.
    --]]

    -- check input
    if type(taskData) ~= "table" then corelog.Error("role_chests_worker.PutItemsFromTurtleIntoChest_MetaData: taskData not valid") return {success = false} end
    local turtleId = taskData.turtleId
    if type(turtleId) ~= "number" then corelog.Error("role_chests_worker.PutItemsFromTurtleIntoChest_MetaData: invalid turtleId") return {success = false} end
    local itemsQuery = taskData.itemsQuery
    if type(itemsQuery) ~= "table" then corelog.Error("role_chests_worker.PutItemsFromTurtleIntoChest_MetaData: invalid itemsQuery") return {success = false} end
    local location = taskData.location
    if type(location) ~= "table" then corelog.Error("role_chests_worker.PutItemsFromTurtleIntoChest_MetaData: location not valid") return {success = false} end
    local accessDirection = taskData.accessDirection
    if type(accessDirection) ~= "string" then corelog.Error("role_chests_worker.PutItemsFromTurtleIntoChest_MetaData: invalid accessDirection") return {success = false} end
    local priorityKey = taskData.priorityKey
    if priorityKey and type(priorityKey) ~= "string" then corelog.Error("role_chests_worker.PutItemsFromTurtleIntoChest_MetaData: Invalid priorityKey") return {success = false} end

    -- determine needed items
    local workingLocation = GetWorkingLocation(location, accessDirection)
    local fuelNeeded = 5 -- task starts at workingLocation, very little (0) movement from there, a few extra to be sure

    -- return metadata
    return {
        startTime   = coreutils.UniversalTime(),
        location    = coremove.CopyLocation(workingLocation),
        needTool    = false,
        needTurtle  = true,
        needTurtleId= turtleId,
        fuelNeeded  = fuelNeeded,
        itemsNeeded = {},

        priorityKey = taskData.priorityKey,
    }
end

function PutItemsFromTurtleIntoChest_Task(taskData)
    --[[
        This Task function puts items from a the inventory of a turtle into a chest.

        Return value:
                                - (table)
                success         - (boolean) whether the items were succesfully put
                slots           - (table) the slots inventory of the chest (after the items have been put)

        Parameters:
            taskData            - (table) data about the task
                turtleId        - (number) id of the turtle that has the items
                itemsQuery      - (table) which items to be put
                location        - (table) location of the chest
                accessDirection - (string) whether to access chest from front, back, up, down, left or right (relative to location)
    --]]

    -- check input
    if type(taskData) ~= "table" then corelog.Error("role_chests_worker.PutItemsFromTurtleIntoChest_Task: taskData not valid") return {success = false} end
    local turtleId = taskData.turtleId
    if type(turtleId) ~= "number" then corelog.Error("role_chests_worker.PutItemsFromTurtleIntoChest_Task: invalid turtleId") return {success = false} end
    local itemsQuery = taskData.itemsQuery
    if type(itemsQuery) ~= "table" then corelog.Error("role_chests_worker.PutItemsFromTurtleIntoChest_Task: invalid itemsQuery") return {success = false} end
    local location = taskData.location
    if type(location) ~= "table" then corelog.Error("role_chests_worker.PutItemsFromTurtleIntoChest_Task: location not valid") return {success = false} end
    local accessDirection = taskData.accessDirection
    if type(accessDirection) ~= "string" then corelog.Error("role_chests_worker.PutItemsFromTurtleIntoChest_Task: invalid accessDirection") return {success = false} end

    -- check correct turtle
    local currentTurtleId = os.getComputerID()
    if currentTurtleId ~= turtleId then corelog.Error("role_chests_worker.PutItemsFromTurtleIntoChest_Task: incorrect turtle(id="..currentTurtleId..") to execute specific turtle(id="..turtleId..")") return {success = false} end

    -- move to workingLocation
    local workingLocation = GetWorkingLocation(location, accessDirection)
    if type(workingLocation) ~= "table" then corelog.Error("role_chests_worker.PutItemsFromTurtleIntoChest_Task: Failed to determine workingLocation") return {success = false} end
--    corelog.WriteToLog("  moving to workingLocation="..textutils.serialize(workingLocation))
    coremove.GoTo(workingLocation)

    -- get access to chest
    local chestName = GetPeripheralName(accessDirection)
    local chest = peripheral.wrap(chestName)
    if type(chest) ~= "table" then corelog.Error("role_chests_worker.PutItemsFromTurtleIntoChest_Task: No chest at "..textutils.serialize(location).." accessible from "..accessDirection..".") return {success = false} end

    -- loop on requested items
    for requestItemName, requestItemCount in pairs(itemsQuery) do
        -- check
        if type(requestItemName) ~= "string" then corelog.Error("role_chests_worker.PutItemsFromTurtleIntoChest_Task: requestItemName of wrong type = "..type(requestItemName)..".") return {success = false} end
        if type(requestItemCount) ~= "number" then corelog.Error("role_chests_worker.PutItemsFromTurtleIntoChest_Task: requestItemCount of wrong type = "..type(requestItemCount)..".") return {success = false} end
--        corelog.WriteToLog("   putting "..requestItemCount.." "..requestItemName.."'s from turtle into chest")

        -- check enough items
        local turtleInventory = coreinventory.GetInventoryDetail()
        if turtleInventory.items[requestItemName] < requestItemCount then corelog.Error("role_chests_worker.PutItemsFromTurtleIntoChest_Task: not enough (="..requestItemCount..") "..requestItemName.." items available (="..turtleInventory.items[requestItemName]..") in inventory of turtle.") return {success = false} end

        -- drop the items into chest
        -- ToDo: handling (not enough) space in chest
        local remainingItemsToDrop = requestItemCount
        for slot, turtleItem in pairs(turtleInventory.slots) do
            -- check
            if type(turtleItem) ~= "table" then corelog.Error("role_chests_worker.FetchItemsFromChestIntoTurtle_Task: turtleItem of wrong type = "..type(turtleItem)..".") return {success = false} end

            -- requested item in turtle slot?
            if turtleItem.itemName == requestItemName then
                -- select turtle slot
                turtle.select(slot)

                -- move items to 
                local countToDrop = math.min(remainingItemsToDrop, turtleItem.itemCount)
--                corelog.WriteToLog("   dropping "..countToDrop.." "..turtleItem.itemName.." from turtle slot "..slot.." to chest")
                local itemsDropped = Drop(chestName, countToDrop)

                -- more to move for this requested item?
                remainingItemsToDrop = remainingItemsToDrop - itemsDropped
                if remainingItemsToDrop <= 0 then break end
            end
        end
    end

    -- get final inventory
    local slots = chest.list()
    -- ToDo: consider double checking only exactly the requested items were put into the chest

    -- end
    local result = {
        success         = true,
        slots           = slots,
    }
    return result
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--
--

function GetWorkingLocation(location, accessDirection)
    -- check input
    if type(location) ~= "table" then corelog.Error("role_chests_worker.GetWorkingLocation: location not valid") return nil end
    if type(accessDirection) ~= "string" then corelog.Error("role_chests_worker.GetWorkingLocation: invalid accessDirection") return nil end

    -- determine workingLocation from accessDirection, i.e. "bottom", "top", "left", "right", "front" or "back"
    local workingDirection = coremove.CopyLocation(location)
    if accessDirection == "bottom" then 
        workingDirection = coremove.GetRelativeLocationDown(workingDirection)
    elseif accessDirection == "top" then 
        workingDirection = coremove.GetRelativeLocationUp(workingDirection)
    elseif accessDirection == "left" then 
        workingDirection = coremove.GetRelativeLocationRight(workingDirection)
        workingDirection = coremove.GetRelativeLocationFront(workingDirection, - 1) -- back
    elseif accessDirection == "right" then
        workingDirection = coremove.GetRelativeLocationLeft(workingDirection)
        workingDirection = coremove.GetRelativeLocationFront(workingDirection, - 1) -- back
    elseif accessDirection == "front" then
        workingDirection = coremove.GetRelativeLocationFront(workingDirection)
        workingDirection = coremove.GetRelativeLocationLeft(workingDirection, 2) -- ensure facing back to location
    elseif accessDirection == "back" then
        workingDirection = coremove.GetRelativeLocationFront(workingDirection, - 1) -- back
    else corelog.Error("role_chests_worker.GetWorkingLocation: Unsupported accessDirection="..accessDirection) return nil end

    -- end
    return workingDirection
end

function GetPeripheralName(accessDirection)
    -- check input
    if type(accessDirection) ~= "string" then corelog.Error("role_chests_worker.GetPeripheralName: invalid accessDirection") return nil end

    -- determine peripheralName from accessDirection
    local peripheralName = "front"
    if accessDirection == "bottom" then
        peripheralName = "top"
    elseif accessDirection == "top" then
        peripheralName = "bottom"
    end

    -- end
    return peripheralName
end

function MakeSlotEmpty(chestName, slotToClear)
    local chest = peripheral.wrap(chestName)
    if type(chest) ~= "table" then corelog.Error("role_chests_worker.MakeSlotEmpty: No chest with chestName = "..chestName..".") return false end

    -- get slots inventory
    local slots = chest.list()
    if slots[slotToClear] then
        -- find slot for item in slot (either empty or with room)
        local countToClear = slots[slotToClear].count
        local nameToClear = slots[slotToClear].name
        local remainingItemsToMove = countToClear
--        corelog.WriteToLog("   moving "..countToClear.." "..nameToClear.." from slot "..slotToClear.." (e).")
        for iSlot=1,chest.size() do
            -- skip slotToClear
            if iSlot ~= slotToClear then
                -- determine countToMove
                local countToMove = 0
                local chestItem = slots[iSlot]
                if not chestItem then -- empty slot
                    countToMove = remainingItemsToMove
                elseif chestItem.name == nameToClear then
--                    corelog.WriteToLog("     chestItem.count="..chestItem.count.." (e).")
                    countToMove = math.min(remainingItemsToMove, coreinventory.GetStackSize(nameToClear) - chestItem.count)
                end

                -- move items
                if countToMove > 0 then
--                    corelog.WriteToLog("     try moving "..countToMove.." "..nameToClear.." from slot "..slotToClear.." to slot "..iSlot.." (e).")
                    local countTransferred = chest.pushItems(chestName, 1, countToMove, iSlot)
--                    corelog.WriteToLog("     countTransferred="..countTransferred.." (e).")
                    remainingItemsToMove = remainingItemsToMove - countTransferred
                    if remainingItemsToMove == 0 then break end
                end
            end
        end
        if remainingItemsToMove ~= 0 then corelog.Error("role_chests_worker.MakeSlotEmpty: could not find suitable slot to move remaining "..remainingItemsToMove.." "..nameToClear.."'s from slot "..slotToClear.." to.") return false end
    else
--        corelog.WriteToLog("   slot "..slotToClear.." already empty")
    end

    -- end
    return true
end

function Suck(chestName, itemCount)
    if chestName == "bottom" then
        turtle.suckDown(itemCount)
    elseif chestName == "top" then
        turtle.suckUp(itemCount)
    elseif chestName == "front" then
        turtle.suck(itemCount)
    else
        corelog.Error("role_chests_worker.Suck: Don't know how to suck "..chestName..".") return 0
    end

    -- end
    return itemCount
end

function Drop(chestName, itemCount)
    if chestName == "bottom" then
        turtle.dropDown(itemCount)
    elseif chestName == "top" then
        turtle.dropUp(itemCount)
    elseif chestName == "front" then
        turtle.drop(itemCount)
    else
        corelog.Error("role_chests_worker.Drop: Don't know how to drop "..chestName..".") return 0
    end

    -- end
    return itemCount
end

function DetermineItemsInventory(slots)
    -- construct item inventory
    local items = {}

    -- loop on slots
    for slot, item in pairs(slots) do
        -- right item?
        if type(item) == "table" then
            -- add to items
            items[ item.name ]  = (items[ item.name ] or 0) + item.count
        end
    end

    -- end
    return items
end
