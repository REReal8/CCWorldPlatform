local db = {
    dhtRoot     = "projects",
}

function StartProject(projectDefinition, projectData, callbackFunction, callbackData)
    -- data of the project
    local project   = {
        projectDefinition   = projectDefinition,
        callbackFunction    = callbackFunction,
        callbackData        = callbackData,

        projectId           = coreutils.NewId(),

        currentStep         = 0,
        outputs             = {}
    }

    -- check the definition
    if type(projectDefinition.returnData) ~= "table" then projectDefinition.returnData = {} end

    -- save
    coredht.SaveData(nil, db.dhtRoot) -- ToDo: remove
    coredht.SaveData(project, db.dhtRoot, project.projectId)

    -- let's start
    NextProjectStep({projectId = project.projectId}, projectData)
end

function NextProjectStep(projectData, stepResults)
    corelog.WriteToLog("enterprise_projects.NextProjectStep( "..textutils.serialize(projectData)..", "..textutils.serialize(stepResults)..")")
    -- get the project informatino
    local project   = coredht.GetData(db.dhtRoot, projectData.projectId)

    -- save the results for the previous step
    project.outputs[ project.currentStep ] = stepResults

    -- was this the last step?
    if #project.projectDefinition.services == project.currentStep then CompleteProject({projectId = project.projectId}) return nil end

    -- next step
    project.currentStep = project.currentStep + 1

    -- save to dht
    coredht.SaveData(project, db.dhtRoot, projectData.projectId)

    -- prepare to execute this step
    local step  = project.projectDefinition.services[ project.currentStep ]
    local input = {}

    -- make the input
    for i, inputDefinition in ipairs(step.input) do

        -- add the requested key
        input[ inputDefinition.keyName ] = project.outputs[ inputDefinition.valueSource ][ inputDefinition.sourceKey ]
    end

    -- prepare function call
    local serviceName           = step.serviceName
    local inputTableString      = textutils.serialize(input)
    local callbackString        = "'enterprise_projects.NextProjectStep'"
    local callbackDataString    = textutils.serialize(projectData)

    -- type of service?
    if step.async == true then

        -- async function call
        local f, err = loadstring(serviceName.."("..inputTableString..", "..callbackString..", "..callbackDataString..")")
        if f then f() else corelog.Error("enterprise_projects.NextProjectStep(): loadstring did not supply a function, error given: "..err) end
    else
        -- sync function call, use the results
        local f, err = loadstring("return "..serviceName.."("..inputTableString..")")
        if not f then corelog.Error("enterprise_projects.NextProjectStep(): loadstring did not supply a function, error given: "..err) return end

        -- execute the step and save the results
        local results = f()

        -- recursive is the future!
        NextProjectStep(projectData, results)
    end
end

function CompleteProject(projectData)
    -- get the project informatino
    local project   = coredht.GetData(db.dhtRoot, projectData.projectId)
    local input     = {}

    -- create the return data table
    for i, inputDefinition in ipairs(project.projectDefinition.returnData) do
        -- add the requested key
        input[ inputDefinition.keyName ] = project.outputs[ inputDefinition.valueSource ][ inputDefinition.sourceKey ]
    end

    -- prepare callback
    local callbackString        = project.callbackFunction
    local callbackDataString    = textutils.serialise(project.callabackData)
    local inputTableString      = textutils.serialize(input)

    -- we are done, do the callback
    local f, err = loadstring(callbackString.."("..callbackDataString..", "..inputTableString..")")
    if f then f() else corelog.Error("enterprise_projects.CompleteProject(): loadstring did not supply a function, error given: "..err) end

    -- forget about this project
--    coredht.SaveData(nil, db.dhtRoot, projectData.projectId)
print("!")
end
