local db = {
    dhtRoot     = "projects",
}

--[[
    The projects enterprise offers services to group together multiple enterprise services based on a predefined project definition.

    Currently the project definition can contain a sequence of services that need to be executed.

    For another description of this enterprise and it's usage see https://github.com/REReal8/CCWorldPlatform/wiki/enterprise_projects 
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function StartProject(projectDefinition, projectInputData, callbackFunction, callbackData)
    -- check input
    if type(projectDefinition) ~= "table" then corelog.Error('enterprise_projects.StartProject: Invalid projectDefinition') return nil end
    if type(projectDefinition.returnData) ~= "table" then projectDefinition.returnData = {} end
    if type(projectInputData) ~= "table" then corelog.Error('enterprise_projects.StartProject: Invalid projectInputData') return nil end
    if type(callbackFunction) ~= "string" then corelog.Error('enterprise_projects.StartProject: Invalid callbackFunction') return nil end
    if type(callbackData) ~= "table" then callbackData = {} end

    -- data of the project
    local project   = {
        projectDefinition   = projectDefinition,
        callbackFunction    = callbackFunction,
        callbackData        = callbackData,

        projectId           = coreutils.NewId(),

        currentStep         = 0,
        outputs             = {}
    }

    -- save
    corelog.WriteToProjectsLog("Add new: "..textutils.serialize(project), project.projectId)
    coredht.SaveData(project, db.dhtRoot, project.projectId)

    -- let's start
    NextProjectStep({projectId = project.projectId}, projectInputData) -- the input projectInputData is interpreted as the result of virtual step 0
end

function RemoveProjects()
    local projects = coredht.GetData(db.dhtRoot)
    if not projects or type(projects) ~= "table" then corelog.Warning("coreassignment.ClearProjects: projects not valid") return nil end

    -- remove all assignments
    corelog.WriteToProjectsLog("All projects are being removed!")
    for projectId, project in pairs(projects) do
        -- remove project
        corelog.WriteToProjectsLog("Removed", projectId)
        coredht.SaveData(nil, db.dhtRoot, projectId)
    end
end

function AllTrue(serviceData) -- ToDo: considering naming this query service differently. maybe AND?
    --[[
        This sync public query service returns if all supplied boolean arguments are true. 
        
        It can typically be used as the last step of a sequence of steps in a project description to combine the success results of all steps into one.

        Return value:
                                    - (table)
                success             - (boolean) whether all supplied boolean arguments are true.

        Parameters:
            serviceData             - (table) data of this service
                <boolean argument1> - (boolean) a boolean argument
                <boolean argument2> - (boolean) another boolean argument
                <boolean argumentN> - (boolean) and another boolean argument
                <other argument1>    - (not boolean) a none boolean argument
                <other argumentN>    - (not boolean) another none boolean argument
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_projects.AllTrue: Invalid input") return {success = false} end

    -- use remaining input
    local allTrue = true
    for key, serviceArgument in pairs(serviceData) do
        -- check if it's boolean
        if type(serviceArgument) =="boolean" then
            allTrue = allTrue and serviceArgument
        end
    end

    -- end
    return {success = allTrue}
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function NextProjectStep(internalProjectData, stepResults)
    -- get the project information
    local project   = coredht.GetData(db.dhtRoot, internalProjectData.projectId)
    if type(project) ~= "table" then
        corelog.Error('enterprise_projects.NextProjectStep: Invalid/ no project retrieved from '..internalProjectData.projectId)
        return nil
    end

    -- save the results for the previous step
    if type(stepResults) ~= "table" then stepResults = {} end
    project.outputs[ project.currentStep ] = stepResults
    corelog.WriteToProjectsLog("Save results step "..project.currentStep..": "..textutils.serialize(stepResults), project.projectId)

    -- was this the last step?
    if #project.projectDefinition.services == project.currentStep then EndProject(internalProjectData) return nil end

    -- next step
    project.currentStep = project.currentStep + 1

    -- save to dht
    coredht.SaveData(project, db.dhtRoot, internalProjectData.projectId)

    -- prepare to execute this step
    local step  = project.projectDefinition.services[ project.currentStep ]
    local input = {}

    -- make the input
    for i, inputDefinition in ipairs(step.input) do
        -- add the requested key
        input[ inputDefinition.keyName ] = project.outputs[ inputDefinition.valueSource ][ inputDefinition.sourceKey ]
    end

    -- prepare function call
    local serviceName           = step.serviceName
    local inputTableString      = textutils.serialize(input)
    local callbackString        = "'enterprise_projects.NextProjectStep'"
    local callbackDataString    = textutils.serialize(internalProjectData)

    -- type of service?
    if step.async == true then
        corelog.WriteToProjectsLog("Start step "..project.currentStep.." async", project.projectId)

        -- async function call
        local f, err = loadstring(serviceName.."("..inputTableString..", "..callbackString..", "..callbackDataString..")")
        if f then f() else corelog.Error("enterprise_projects.NextProjectStep(): loadstring did not supply a function, error given: "..err) end
    else
        corelog.WriteToProjectsLog("Start step "..project.currentStep.." sync", project.projectId)

        -- sync function call, use the results
        local f, err = loadstring("return "..serviceName.."("..inputTableString..")")
        if not f then corelog.Error("enterprise_projects.NextProjectStep(): loadstring did not supply a function, error given: "..err) return end

        -- execute the step and save the results
        local results = f()

        -- recursive is the future!
        NextProjectStep(internalProjectData, results)
    end
end

function EndProject(internalProjectData)
    -- get the project informatino
    local project   = coredht.GetData(db.dhtRoot, internalProjectData.projectId)
    local input     = {}

    -- create the return data table
    for i, inputDefinition in ipairs(project.projectDefinition.returnData) do
        -- add the requested key
        input[ inputDefinition.keyName ] = project.outputs[ inputDefinition.valueSource ][ inputDefinition.sourceKey ]
    end

    -- prepare callback
    local callbackString        = project.callbackFunction
    local callbackDataString    = textutils.serialise(project.callbackData)
    local inputTableString      = textutils.serialize(input)

    -- we are done, do the callback
    corelog.WriteToProjectsLog("Calling callback function: "..callbackString.."("..callbackDataString..", "..inputTableString..")", project.projectId)
    local f, err = loadstring(callbackString.."("..callbackDataString..", "..inputTableString..")")
    if f then f() else corelog.Error("enterprise_projects.CompleteProject(): loadstring did not supply a function, error given: "..err) end

    -- forget about this project
    corelog.WriteToProjectsLog("Ended", project.projectId)
    coredht.SaveData(nil, db.dhtRoot, internalProjectData.projectId)
end
