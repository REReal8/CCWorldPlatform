local db = {
    dhtRoot     = "projects",
}

--[[
    The projects enterprise offers services to group together multiple enterprise services based on a predefined project definition.

    Currently the project definition can contain a sequence of services that need to be executed.

    For another description of this enterprise and it's usage see https://github.com/REReal8/CCWorldPlatform/wiki/enterprise_projects 
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function StartProject_ASrv(serviceData, callback, callbackData)
    --[[
        This async public service starts a project.

        Return value:
            nil 

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the project was successfully executed
                <other results> - (?) as defined in the project definition

        Parameters:
            serviceData         - (table) data for this service
                projectDef      - (table) definition of the project
                projectData     - (table) input data to the project
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_projects.StartProject_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local projectDef = serviceData.projectDef
    if type(projectDef) ~= "table" then corelog.Error("enterprise_projects.StartProject_ASrv: Invalid projectDef") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(projectDef.returnData) ~= "table" then projectDef.returnData = {} end
    local projectData = serviceData.projectData
    if type(projectData) ~= "table" then corelog.Error("enterprise_projects.StartProject_ASrv: Invalid projectData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_projects.StartProject_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- data of the project
    local project   = {
        projectDef          = projectDef,
        callbackFunction    = callback,
        callbackData        = callbackData,

        projectId           = coreutils.NewId(),

        currentStep         = 0,
        outputs             = {}
    }

    -- save
    corelog.WriteToProjectsLog("Add new: "..textutils.serialize(project), project.projectId)
    coredht.SaveData(project, db.dhtRoot, project.projectId)

    -- let's start
    NextProjectStep({projectId = project.projectId}, projectData) -- the input projectData is interpreted as the result of virtual step 0
end

function AreAllTrue_QSrv(serviceData)
    --[[
        This sync public query service returns if all supplied boolean arguments are true. 
        
        It can typically be used as the last step of a sequence of steps in a project description to combine the success results of all steps into one.

        Return value:
                                    - (table)
                success             - (boolean) whether all supplied boolean arguments are true.

        Parameters:
            serviceData             - (table) data of this service
                <boolean argument1> - (boolean) a boolean argument
                <boolean argument2> - (boolean) another boolean argument
                <boolean argumentN> - (boolean) and another boolean argument
                <other argument1>    - (not boolean) a none boolean argument
                <other argumentN>    - (not boolean) another none boolean argument
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_projects.AreAllTrue_QSrv: Invalid input") return {success = false} end

    -- use remaining input
    local allTrue = true
    for key, serviceArgument in pairs(serviceData) do
        -- check if it's boolean
        if type(serviceArgument) == "boolean" then
            allTrue = allTrue and serviceArgument
        end
    end

    -- end
    return {success = allTrue}
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function DeleteProjects()
    local projects = coredht.GetData(db.dhtRoot)
    if not projects or type(projects) ~= "table" then corelog.Warning("coreassignment.DeleteProjects: projects not valid") return nil end

    -- remove all projects
    corelog.WriteToProjectsLog("All projects are being deleted!")
    for projectId, project in pairs(projects) do
        -- remove project
        corelog.WriteToProjectsLog("Deleted", projectId)
        coredht.SaveData(nil, db.dhtRoot, projectId)
    end
end

function NextProjectStep(internalProjectData, stepResults)
    -- get the project information
    local project   = coredht.GetData(db.dhtRoot, internalProjectData.projectId)
    if type(project) ~= "table" then corelog.Error("enterprise_projects.NextProjectStep: Invalid/ no project retrieved from "..internalProjectData.projectId) TerminateProject(internalProjectData) return nil end

    -- save the results for the previous step
    if type(stepResults) ~= "table" then stepResults = {} end -- ToDo: consider checking (or even enforcing?) {success = true}
    project.outputs[ project.currentStep ] = stepResults
    corelog.WriteToProjectsLog("Save results step "..project.currentStep..": "..textutils.serialize(stepResults), project.projectId)

    -- was this the last step?
    if #project.projectDef.steps == project.currentStep then EndProject(internalProjectData) return nil end

    -- next step
    project.currentStep = project.currentStep + 1

    -- save to dht
    coredht.SaveData(project, db.dhtRoot, internalProjectData.projectId)

    -- get new step
    local step = project.projectDef.steps[ project.currentStep ]

    -- prepare step service call
    local serviceName = step.stepName
    local serviceData = {}
    for i, inputDef in ipairs(step.stepDataDef) do
        -- get sourceStepData
        local sourceStepNr = inputDef.valueSource
        local sourceStepData = project.outputs[ sourceStepNr ]
        if type(sourceStepData) ~= "table" then corelog.Error("enterprise_projects.NextProjectStep: Invalid sourceStepData for step "..i) TerminateProject(internalProjectData) return nil end

        -- get sourceValue
        local sourceValue = GetNestedIndexSourceValue(sourceStepData, inputDef.keyDefSource)
        if type(sourceValue) == "nil" then corelog.Error("enterprise_projects.NextProjectStep: Invalid sourceValue for step "..i) TerminateProject(internalProjectData) return nil end

        -- add the requested key
        local setSuccess = SetNestedIndexValue(serviceData, inputDef.keyDef, sourceValue)
        if not setSuccess then corelog.Error("enterprise_projects.NextProjectStep: Failed setting serviceData for step "..i) TerminateProject(internalProjectData) return nil end
    end

    -- type of service?
    if step.async == true then
        corelog.WriteToProjectsLog("Start step "..project.currentStep.." async", project.projectId)

        -- do async function call
        local callback          = "'enterprise_projects.NextProjectStep'"
        local callbackData      = internalProjectData
        coreutils.DoASyncService(serviceName, serviceData, callback, callbackData)
    else
        corelog.WriteToProjectsLog("Start step "..project.currentStep.." sync", project.projectId)

        -- do sync function call, keep the results
        local results = coreutils.DoSyncService(serviceName, serviceData)

        -- recursive is the future!
        NextProjectStep(internalProjectData, results)
    end
end

local indexingPattern = "(%w+)[%.]?"

function GetNestedIndexSourceValue(sourceStepData, sourceKeyName)
    -- check input

    --        corelog.WriteToProjectsLog("    sourceKeyName = "..sourceKeyName.."", project.projectId)
    local sourceValue = sourceStepData

    -- loop on indexing
    for indexName in string.gmatch(sourceKeyName, indexingPattern) do
        if type(indexName) ~= "string" then corelog.Error("enterprise_projects.GetNestedIndexSourceValue: Invalid (type="..type(indexName)..") indexName") return nil end
        if type(sourceValue) ~= "table" then corelog.Error("enterprise_projects.GetNestedIndexSourceValue: Can't index further into sourceValue="..sourceValue.." (type="..type(sourceValue)..")") return nil end
        sourceValue = sourceValue[indexName]
        if type(sourceValue) == "nil" then corelog.Error("enterprise_projects.GetNestedIndexSourceValue: Invalid (type="..type(sourceValue)..") sourceValue") return nil end
    end
    --        corelog.WriteToProjectsLog("    sourceValue = "..textutils.serialize(sourceValue).."", project.projectId)

    -- end
    return sourceValue
end

function SetNestedIndexValue(resultData, keyName, sourceValue)
    -- check input

    -- loop on indexing
    local indexedData = resultData
    for indexName in string.gmatch(keyName, indexingPattern) do
        if type(indexName) ~= "string" then corelog.Error("enterprise_projects.SetNestedIndexValue: Invalid (type="..type(indexName)..") indexName") return false end
        corelog.WriteToProjectsLog("    indexName = "..indexName.."")
        if type(indexedData) ~= "table" then corelog.Error("enterprise_projects.SetNestedIndexValue: Can't index further into indexedData="..indexedData.." (type="..type(indexedData)..")") return false end
        corelog.WriteToProjectsLog("    indexedData = "..textutils.serialize(indexedData).." (1)")

        indexedData = indexedData[indexName]
--        if type(indexedData) == "nil" then corelog.Error("enterprise_projects.SetNestedIndexValue: Invalid (type="..type(indexedData)..") indexedData") return false end
    end
    indexedData = sourceValue
    corelog.WriteToProjectsLog("    indexedData = "..textutils.serialize(indexedData).." (2)")

--[[
    local a = {
        ["l1"] = {
            ["l2"] = {
                ["l3"] = "waarde"
            }

        }
    }

    a["l1"]["l2"]["l3"] = "nieuwe waarde 1"
    a.l1.l2.l3 = "nieuwe waarde 2"

    local b = a
    b = b.l1
    b = b.l2
    b = b.l3
    b = "nieuwe waarde 3"
]]

    -- end
    return true
end

function TerminateProject(internalProjectData)
    local project   = coredht.GetData(db.dhtRoot, internalProjectData.projectId)
    if type(project) ~= "table" then corelog.Error("enterprise_projects.TerminateProject: Invalid/ no project retrieved from "..internalProjectData.projectId) return nil end

    corelog.WriteToProjectsLog("Warning!: Early Termination", project.projectId)

    EndProject(internalProjectData)
end

function EndProject(internalProjectData)
    -- get the project informatino
    local project   = coredht.GetData(db.dhtRoot, internalProjectData.projectId)
    local projectResult = {}

    -- create the projectResult
    for i, inputDef in ipairs(project.projectDef.returnData) do
        -- get sourceStepData
        local sourceStepNr = inputDef.valueSource
        local sourceStepData = project.outputs[ sourceStepNr ]
        if type(sourceStepData) ~= "table" then corelog.Warning("enterprise_projects.EndProject: Invalid sourceStepData for "..i) break end

        -- get sourceValue
        local sourceValue = GetNestedIndexSourceValue(sourceStepData, inputDef.keyDefSource)
        if type(sourceValue) == "nil" then corelog.Error("enterprise_projects.EndProject: Invalid sourceValue step "..i) break end

        -- add the requested key
        local setSuccess = SetNestedIndexValue(projectResult, inputDef.keyDef, sourceValue)
        if not setSuccess then corelog.Error("enterprise_projects.EndProject: Failed setting projectResult step "..i) break end
    end
    corelog.WriteToProjectsLog("Project results: "..textutils.serialize(projectResult), project.projectId)

    -- we are done, do the callback
    corelog.WriteToProjectsLog("Calling callback function", project.projectId)
    coreutils.DoCallback(project.callbackFunction, project.callbackData, projectResult)

    -- forget about this project
    corelog.WriteToProjectsLog("Ended", project.projectId)
    coredht.SaveData(nil, db.dhtRoot, internalProjectData.projectId)
end
