-- declare display space
local db    = {
    x           = 0,
    y           = 0,
    update      = {}								-- list with all schreen updates
}
local screen    = {}

-- init function for the display
function Init()
	-- get current position
    db.x, db.y = term.getSize()

    -- set default screen
    MainMenu(DefaultMainMenu())
end

-- setup function for the display
function Setup()
end

-- to know if the dislay is still being used
function Active()
    return db.mainmenu ~= nil
end

-- endless loop function for the display
function Run()
	-- only continue as long as there is a main menu defined
	while db.mainmenu ~= nil and core.IsSystemRunning() do
		-- get de next screen definition
		local n = NextScreen()

		-- custom screen?
		if n.custom	then n.custom(n)
					else DoScreen(n)
		end
	end

	-- next line
	print("")
end

-- function to get or set the main menu
function MainMenu(t)
	if t then db.mainmenu = t
	else return db.mainmenu
	end
end

-- a nice default main menu, very usefull
function DefaultMainMenu()
	if turtle then
		return {
			clear   = true,
			intro   = "Choose your action",
			option  = {
				{key = "c", desc = "Execute code",  			func = ExecuteCode,	    		param = {step = 1}},
				{key = "t", desc = "Execute general tests", 	func = ExecuteTest,	    		param = {}},
				{key = "r", desc = "Execute role tests",		func = ExecuteRoleTest,			param = {}},
				{key = "o", desc = "Execute mobj tests",		func = ExecuteMObjTest,			param = {}},
				{key = "e", desc = "Execute enterprise tests",	func = ExecuteEnterpriseTest,	param = {}},
				{key = "l", desc = "Load event",				func = LoadEvent,				param = {}},
				{key = "m", desc = "Move turtle",   			func = MoveTurtle,	    		param = {}},
				{key = "q", desc = "Quit",          			func = core.DoQuit,				param = {}},
			},
			question	= "Make your choice",
		}
	else
		return {
			clear   = true,
			intro   = "Choose your action",
			option  = {
				{key = "c", desc = "Execute code",  			func = ExecuteCode,	    param = {step = 1}},
				{key = "t", desc = "Execute general tests",  	func = ExecuteTest,	    param = {}},
				{key = "l", desc = "Load event",				func = LoadEvent,		param = {}},
				{key = "q", desc = "Quit",          			func = core.DoQuit,		param = {}},
			},
			question	= "Make your choice",
		}
	end

end

-- get the next screen
function NextScreen(t)
	if t				then screen[#screen + 1] = t
	elseif #screen > 0	then return table.remove(screen)
						else return MainMenu()
	end
end

-- function to execute a screen from a screentable
function DoScreen(t)
	local success
	local response

	-- now print the screen
	if not t.dontclear then term.clear() term.setCursorPos(1,1) end

	-- print the intro
	if t.intro then print(t.intro) end

	-- print the list
	if t.option then for i=1,#t.option do print(t.option[i].key, t.option[i].desc) end end

	-- print the final question
	if t.question then write(t.question.." ") end

	-- print any messages
	UpdateToDisplay()

	-- wait for input...
	while not success do
		if t.option then
			-- wait for the key
			response = ReadChar()

			-- find the right function to run
			for i=1,#t.option do
				if not success and response == t.option[i].key then
					success = t.option[i].func(t.option[i].param, response)
				end
			end
		else
			success = t.func(t.param, ReadLine())
		end
	end

	-- run the function -- weird again, can never happen !!!
--    	if func then func(response, param) end
end

function IndexToKey(i) if i < 10 then return tostring(i) else return string.char(87 + i) end end
function ReadChar() while true do local event, c = os.pullEvent() if event == "char" then return c end end end
function ReadLine() return read() end

-- for executing custom code
function ExecuteCode(t, code)
	-- first screen?
	if t.step == 1 then
		NextScreen({
			clear       = true,
			func	    = ExecuteCode,
			intro       = "Please type your line of code below\n",
			param	    = {step = 2},
			question    = nil
		})
	else
		local f, err = loadstring(code)

		-- valid function?
		if f then
			-- executing the code as wordt
			coretask.AddWork(f)
			UpdateToDisplay("Your code is queued for execution")
		else
			UpdateToDisplay(err)
			return false
		end
	end

	-- done
	return true
end

function ExecuteTest(t)

	if type(t) == "table" and type(t.func) == "string" and type(t.filename) == "string" then
		-- execute function

		-- seems our user has made a choice
		local f, err = loadstring(t.filename.."."..t.func.."()")

		-- valid function?
		if f then
			-- executing the code as wordt
			coretask.AddWork(f)
			UpdateToDisplay(t.func.." is queued for execution")
		else
			UpdateToDisplay(err)
			return false
		end
	elseif type(t) == "table" and type(t.file) == "table" then
		-- test functions screen

		-- variables
		local functions	= {}
		local options	= {}

		-- get all functions in test file / object
		for key, value in pairs(t.file) do
			-- add key if the value is a function and name starts with T_
			if type(value) == "function" and string.find(key, "T_") then table.insert(functions, key) end
		end

		-- order this shit
		table.sort(functions)

		-- create the list of options
		for i, name in ipairs(functions) do options[i] = {key = IndexToKey(i), desc = string.sub(name,3,-1), func = ExecuteTest, param = {func = name, filename = t.filename}} end
		table.insert(options, {key = "x", desc = "Back to test menu", func = ExecuteTest, param = {}})

		-- this is the next screen
		NextScreen({
			clear       = true,
			intro       = "Choose a test function",
			option      = options,
			question    = "Make your choice"
		})
	elseif type(t) ~= "table" or type(t.func) ~= "string" then
		-- test files screen

		-- test options
		local options	= {
			{key = "g", desc = "general", 			func = ExecuteTest, param = {file = t_main, filename = "t_main"}},
			{key = "t", desc = "enterprise_test",	func = ExecuteTest, param = {file = t_test, filename = "t_test"}},
			{key = "m", desc = "move", 				func = ExecuteTest, param = {file = t_move, filename = "t_move"}},
			{key = "u", desc = "URL", 				func = ExecuteTest, param = {file = t_obj_url, filename = "t_obj_url"}},
			{key = "d", desc = "coredht", 			func = ExecuteTest, param = {file = t_coredht, filename = "t_coredht"}},
			{key = "x", desc = "Back to main menu", func = function () return true end }
		}

		-- this is the next screen
		NextScreen({
			clear       = true,
			intro       = "Choose a test type",
			option      = options,
			question    = "Make your choice"
		})
	else
		corelog.WriteToLog("ExecuteTest: should not happen")
	end

	-- done
	return true
end

function ExecuteRoleTest(t)

	if type(t) == "table" and type(t.func) == "string" and type(t.filename) == "string" then
		-- execute function

		-- seems our user has made a choice
		local f, err = loadstring(t.filename.."."..t.func.."()")

		-- valid function?
		if f then
			-- executing the code as wordt
			coretask.AddWork(f)
			UpdateToDisplay(t.func.." is queued for execution")
		else
			UpdateToDisplay(err)
			return false
		end
	elseif type(t) == "table" and type(t.file) == "table" then
		-- test functions screen

		-- variables
		local functions	= {}
		local options	= {}

		-- get all functions in test file / object
		for key, value in pairs(t.file) do
			-- add key if the value is a function and name starts with T_
			if type(value) == "function" and string.find(key, "T_") then table.insert(functions, key) end
		end

		-- order this shit
		table.sort(functions)

		-- create the list of options
		for i, name in ipairs(functions) do options[i] = {key = IndexToKey(i), desc = string.sub(name,3,-1), func = ExecuteRoleTest, param = {func = name, filename = t.filename}} end
		table.insert(options, {key = "x", desc = "Back to role test menu", func = ExecuteRoleTest, param = {}})

		-- this is the next screen
		NextScreen({
			clear       = true,
			intro       = "Choose a role test function",
			option      = options,
			question    = "Make your choice"
		})
	elseif type(t) ~= "table" or type(t.func) ~= "string" then
		-- test files screen

		-- test options
		local options	= {
			{key = "a", desc = "alchemist", 		func = ExecuteRoleTest, param = {file = t_alchemist, filename = "t_alchemist"}},
			{key = "b", desc = "builder", 			func = ExecuteRoleTest, param = {file = t_builder, filename = "t_builder"}},
			{key = "x", desc = "Back to main menu", func = function () return true end }
		}

		-- this is the next screen
		NextScreen({
			clear       = true,
			intro       = "Choose a role test type",
			option      = options,
			question    = "Make your choice"
		})
	else
		corelog.WriteToLog("ExecuteRoleTest: should not happen")
	end

	-- done
	return true
end

function ExecuteMObjTest(t)
	if type(t) == "table" and type(t.func) == "string" and type(t.filename) == "string" then
		-- execute function

		-- seems our user has made a choice
		local f, err = loadstring(t.filename.."."..t.func.."()")

		-- valid function?
		if f then
			-- executing the code as wordt
			coretask.AddWork(f)
			UpdateToDisplay(t.func.." is queued for execution")
		else
			UpdateToDisplay(err)
			return false
		end
	elseif type(t) == "table" and type(t.file) == "table" then
		-- test functions screen

		-- variables
		local functions	= {}
		local options	= {}

		-- get all functions in test file / object
		for key, value in pairs(t.file) do
			-- add key if the value is a function and name starts with T_
			if type(value) == "function" and string.find(key, "T_") then table.insert(functions, key) end
		end

		-- order this shit
		table.sort(functions)

		-- create the list of options
		for i, name in ipairs(functions) do options[i] = {key = IndexToKey(i), desc = string.sub(name,3,-1), func = ExecuteMObjTest, param = {func = name, filename = t.filename}} end
		table.insert(options, {key = "x", desc = "Back to mobj test menu", func = ExecuteMObjTest, param = {}})

		-- this is the next screen
		NextScreen({
			clear       = true,
			intro       = "Choose an mobj test function",
			option      = options,
			question    = "Make your choice"
		})
	elseif type(t) ~= "table" or type(t.func) ~= "string" then
		-- test files screen

		-- test options
		local options	= {
			{key = "b", desc = "block",				func = ExecuteMObjTest, param = {file = t_obj_block, filename = "t_obj_block"}},
			{key = "l", desc = "layerRectangle",	func = ExecuteMObjTest, param = {file = t_obj_layer_rectangle, filename = "t_obj_layer_rectangle"}},
			{key = "f", desc = "birchForest",		func = ExecuteMObjTest, param = {file = t_mobj_birchforest, filename = "t_mobj_birchforest"}},
			{key = "x", desc = "Back to main menu", func = function () return true end }
		}

		-- this is the next screen
		NextScreen({
			clear       = true,
			intro       = "Choose a mobj test type",
			option      = options,
			question    = "Make your choice"
		})
	else
		corelog.WriteToLog("ExecuteMObjTest: should not happen")
	end

	-- done
	return true
end

function ExecuteEnterpriseTest(t)

	if type(t) == "table" and type(t.func) == "string" and type(t.filename) == "string" then
		-- execute function

		-- seems our user has made a choice
		local f, err = loadstring(t.filename.."."..t.func.."()")

		-- valid function?
		if f then
			-- executing the code as wordt
			coretask.AddWork(f)
			UpdateToDisplay(t.func.." is queued for execution")
		else
			UpdateToDisplay(err)
			return false
		end
	elseif type(t) == "table" and type(t.file) == "table" then
		-- test functions screen

		-- variables
		local functions	= {}
		local options	= {}

		-- get all functions in test file / object
		for key, value in pairs(t.file) do
			-- add key if the value is a function and name starts with T_
			if type(value) == "function" and string.find(key, "T_") then table.insert(functions, key) end
		end

		-- order this shit
		table.sort(functions)

		-- create the list of options
		for i, name in ipairs(functions) do options[i] = {key = IndexToKey(i), desc = string.sub(name,3,-1), func = ExecuteEnterpriseTest, param = {func = name, filename = t.filename}} end
		table.insert(options, {key = "x", desc = "Back to enterprise test menu", func = ExecuteEnterpriseTest, param = {}})

		-- this is the next screen
		NextScreen({
			clear       = true,
			intro       = "Choose an enterprise test function",
			option      = options,
			question    = "Make your choice"
		})
	elseif type(t) ~= "table" or type(t.func) ~= "string" then
		-- test files screen

		-- test options
		local options	= {
			{key = "a", desc = "assignmentboard",	func = ExecuteEnterpriseTest, param = {file = t_assignmentboard, filename = "t_assignmentboard"}},
			{key = "p", desc = "projects", 			func = ExecuteEnterpriseTest, param = {file = t_projects, filename = "t_projects"}},
			{key = "e", desc = "energy", 			func = ExecuteEnterpriseTest, param = {file = t_energy, filename = "t_energy"}},
			{key = "t", desc = "turtle", 			func = ExecuteEnterpriseTest, param = {file = t_turtle, filename = "t_turtle"}},
			{key = "c", desc = "chests", 			func = ExecuteEnterpriseTest, param = {file = t_chests, filename = "t_chests"}},
			{key = "i", desc = "isp", 				func = ExecuteEnterpriseTest, param = {file = t_isp, filename = "t_isp"}},
			{key = "b", desc = "construction", 		func = ExecuteEnterpriseTest, param = {file = t_construction, filename = "t_construction"}},
			{key = "s", desc = "storage", 			func = ExecuteEnterpriseTest, param = {file = t_storage, filename = "t_storage"}},
			{key = "f", desc = "factory", 			func = ExecuteEnterpriseTest, param = {file = t_factory, filename = "t_factory"}},
			{key = "w", desc = "forestry", 			func = ExecuteEnterpriseTest, param = {file = t_forestry, filename = "t_forestry"}},
			{key = "o", desc = "shop", 				func = ExecuteEnterpriseTest, param = {file = t_shop, filename = "t_shop"}},
			{key = "n", desc = "colonization", 		func = ExecuteEnterpriseTest, param = {file = t_colonization, filename = "t_colonization"}},
			{key = "x", desc = "Back to main menu", func = function () return true end }
		}

		-- this is the next screen
		NextScreen({
			clear       = true,
			intro       = "Choose an enterprise test type",
			option      = options,
			question    = "Make your choice"
		})
	else
		corelog.WriteToLog("ExecuteEnterpriseTest: should not happen")
	end

	-- done
	return true
end

-- for loading an event from file
function LoadEvent(t)
	-- first screen
	if t == nil or t.dir == nil then
		local list	= fs.list("/event/")
		local tmp	= {}

		-- create the list of options
		for i=1,#list do tmp[i] = {key = IndexToKey(i), desc = list[i], func = LoadEvent, param = {dir = list[i]}} end
		tmp[#tmp + 1] = {key = "x", desc = "Back to main menu", func = function () return true end}

		-- this is the next screen
		NextScreen({
			clear       = true,
			intro       = "Choose a protocol",
			option      = tmp,
			question    = "Make your choice"
		})

	-- second screen
	elseif t.dir and t.filename == nil then
		local list	= fs.list( "/event/"..t.dir.."/" )
		local tmp	= {}

		-- create the list of options
		print(#list)
		for i=1,#list do tmp[i] = {key = IndexToKey(i), desc = list[i], func = LoadEvent, param = {dir = t.dir, filename = list[i]}} end
		tmp[#tmp + 1] = {key = "x", desc = "Back to protocol selection", func = LoadEvent, param = {}}

		-- this is the next screen
		NextScreen({
			clear       = true,
			intro       = "Choose a file (protocol="..t.dir..")",
			option      = tmp,
			question    = "Make your choice"
		})
	elseif t.dir and t.filename then
		local envelope = coreutils.ReadTableFromFile("/event/"..t.dir.."/"..t.filename)
		os.queueEvent("modem_message", nil, envelope.to, envelope.from, textutils.serialize(envelope), envelope.distance)
	end

	-- always good!
	return true
end

-- screen to move the turtle around
function MoveTurtle( t )
	-- chech if this is a turtle
	if not turtle then UpdateToDisplay("Only available for turtles") return false end

	-- first screen?
	if t == nil or t.direction == nil then
		NextScreen({
			clear = true,
			intro = "Available actions",
			option = {
				{key = "w", desc = "Forward",		    func = MoveTurtle, param = {direction = "Forward"   }},
				{key = "s", desc = "Backward",		    func = MoveTurtle, param = {direction = "Backward"  }},
				{key = "a", desc = "Turn left",	        func = MoveTurtle, param = {direction = "Left"      }},
				{key = "d", desc = "Turn right",	    func = MoveTurtle, param = {direction = "Right"     }},
				{key = "e", desc = "Up",			    func = MoveTurtle, param = {direction = "Up"        }},
				{key = "q", desc = "Down",				func = MoveTurtle, param = {direction = "Down"      }},
				{key = "x", desc = "Back to main menu", func = function () return true end }
			},
			question = "Which direction?"
		})
		return true
	else
			if t.direction == "Forward"		then coretask.AddWork(function () coremove.Forward()	end)
		elseif t.direction == "Backward"	then coretask.AddWork(function () coremove.Backward()	end)
		elseif t.direction == "Left"		then coretask.AddWork(function () coremove.Left()		end)
		elseif t.direction == "Right"		then coretask.AddWork(function () coremove.Right()		end)
		elseif t.direction == "Up"			then coretask.AddWork(function () coremove.Up()			end)
		elseif t.direction == "Down"		then coretask.AddWork(function () coremove.Down()		end)
		end

        -- makes the previous screen stays loaded, so the human kan move the turtle again
		return false
	end
end

-- local function to update the display with messages for the user.
function UpdateToDisplay(update, alive)
	local now	= os.clock()
	alive       = alive or 5

	-- do we have a new update?
	if update then db.update[#db.update + 1] = {text = update, endTime = now + alive} end

	-- presever the current coordinates
	local x, y = term.getCursorPos()
	local c = #db.update

	-- write second update?
	if c > 1 then
		term.setCursorPos( 1, db.y - 0 )
		term.clearLine()
		term.write( db.update[c - 1].text )
	end

	-- write third update?
	if c > 0 then
		term.setCursorPos( 1, db.y - 1 )
		term.clearLine()
		term.write( db.update[c].text )
	end

	-- resotre cursor
	term.setCursorPos( x, y )
end
