local db = {
    dhtRoot     = "enterprise_storage",
    dhtSites    = "sites",
}

function StoreItems(site, itemList)
    -- just loop all top chests, ignore the itemList (for now)
    for i, topChest in ipairs(site.topChests) do

        -- this one free?
        if topChest.status == "free" then

            -- save this to the dht
            coredht.SaveData("used", db.dhtRoot, db.dhtSites, site.sitesIndex, "topChests", i, "status")

            -- return the location of this top chest
            return topChest.location
        end
    end
end

function ItemsDelivered(sitesIndex, topChestIndex, itemList, location)
    -- variables
    local assignmentMeta        = {
        startTime       = 0,
        location        = coremove.CopyLocation(location),
        needTool        = false,
        needTurtle      = true,
        fuelNeeded      = 100
    }
    local assignmentArguments   = {
        sitesIndex      = sitesIndex,
        topChestIndex   = topChestIndex
    }

    -- now we need to get some work done, time for a new assignment
    coreassignment.AddAssignment(
        assignmentMeta,                                         -- meta data about the assignment
        "enterprise_storage_silo.ItemsDeliveredAssignement",    -- taskFunction
        assignmentArguments,                                    -- taskArgumentTable
        "coreassignment.DummyCallback",                       -- callbackFunction
        {}                                                      -- callbackArgumentTable
    )
end

function ItemPresent(site, itemName)
    -- variables
    local itemCount = 0

    -- loop all storage chests
    for i, storageChests in ipairs(site.storageChests) do

        -- right item?
        if storageChests.itemName == itemName then

            -- update the counter with the actual value || virual might be smarter though
            itemCount = itemCount + storageChests.actual
        end
    end

    -- done
    return itemCount
end

function RetrieveItems(sitesIndex, itemList, callback, callbackArgs)

    -- variables
    local site      = coredht.GetData(db.dhtRoot, db.dhtSites, sitesIndex)
    local location  = nil

    -- part 1: make a reservation for a pick up box
    -- just loop all top chests, ignore the itemList (for now)
    for i, topChest in ipairs(site.topChests) do

        -- this one free?
        if topChest.status == "free" then

            -- save this to the dht
            coredht.SaveData("used", db.dhtRoot, db.dhtSites, site.sitesIndex, "topChests", i, "status")

            -- return the location of this top chest
            location = topChest.location

            -- done with the loop
            break
        end
    end

    -- found any?
    if location == nil then coreutils.Error("enterprise_storage_silo.RetrieveItems: no free top chest") return nil end

    -- part 2: make an assignment for the actual pickup
    local assignmentMeta        = {
        startTime       = 0,
        location        = coremove.CopyLocation(site.entryLocation),
        needTool        = false,
        needTurtle      = true,
        fuelNeeded      = 100
    }
    local assignmentArguments   = {
        sitesIndex      = sitesIndex,
        itemList        = itemList,
        dropLocation    = coremove.CopyLocation(location),
    }

    -- now we need to get some work done, time for a new assignment
    coreassignment.AddAssignment(
        assignmentMeta,                                         -- meta data about the assignment
        "enterprise_storage_silo.RetrieveItemsAssignement",     -- taskFunction
        assignmentArguments,                                    -- taskArgumentTable
        callback,                                               -- callbackFunction
        callbackArgs                                            -- callbackArgumentTable
    )

    -- return the location of the pickup box
    return location
end

function ItemsCollected(site, topChest)
    -- mark the topchest free, that's all
    coredht.SaveData("free", db.dhtRoot, db.dhtSites, site.sitesIndex, "topChests", topChest.chestIndex, "status")
end

function NewSite(siteData)
    -- variables
    local site  = {
        type            = "silo",
        location        = siteData.location,
        entryLocation   = coremove.GetRelativeLocation(siteData.location, 3, 3, 0),
        topChests       = {},
        storageChests   = {},

        sitesIndex      = 0,    -- set later
    }

    -- check input, use default
    siteData.siloType = siteData.siloType or "basic"

    -- what kind of new silo is this?
    if siteData.siloType == "basic" then

        -- defaults to input
        siteData.topChests  = siteData.topChests    or 2
        siteData.layers     = siteData.layers       or 2

        -- add our top chests, depending how many we have
        if siteData.topChests >= 1 then table.insert(site.topChests, {status="free", location=coremove.GetRelativeLocation(siteData.location, 2, 5, 0), chestIndex=1}) end
        if siteData.topChests >= 2 then table.insert(site.topChests, {status="free", location=coremove.GetRelativeLocation(siteData.location, 4, 5, 0), chestIndex=2}) end
        if siteData.topChests >= 3 then table.insert(site.topChests, {status="free", location=coremove.GetRelativeLocation(siteData.location, 5, 4, 0), chestIndex=3}) end
        if siteData.topChests >= 4 then table.insert(site.topChests, {status="free", location=coremove.GetRelativeLocation(siteData.location, 5, 2, 0), chestIndex=4}) end
        if siteData.topChests >= 5 then table.insert(site.topChests, {status="free", location=coremove.GetRelativeLocation(siteData.location, 4, 1, 0), chestIndex=5}) end
        if siteData.topChests >= 6 then table.insert(site.topChests, {status="free", location=coremove.GetRelativeLocation(siteData.location, 2, 1, 0), chestIndex=6}) end
        if siteData.topChests >= 7 then table.insert(site.topChests, {status="free", location=coremove.GetRelativeLocation(siteData.location, 1, 2, 0), chestIndex=7}) end
        if siteData.topChests >= 8 then table.insert(site.topChests, {status="free", location=coremove.GetRelativeLocation(siteData.location, 1, 4, 0), chestIndex=8}) end

        -- loop the layers
        for i=1, siteData.layers, 1 do

            -- do the floor
            local shaft = coremove.GetRelativeLocation(site.entryLocation, 0, 0, -1 - i)
            table.insert(site.storageChests, {status="free", itemName=nil, location=coremove.GetDivergentDirection(shaft,  0,  1), actual=0, virtual=0, stackSize=0, chestIndex=#site.storageChests+1})
            table.insert(site.storageChests, {status="free", itemName=nil, location=coremove.GetDivergentDirection(shaft,  1,  0), actual=0, virtual=0, stackSize=0, chestIndex=#site.storageChests+1})
            table.insert(site.storageChests, {status="free", itemName=nil, location=coremove.GetDivergentDirection(shaft,  0, -1), actual=0, virtual=0, stackSize=0, chestIndex=#site.storageChests+1})
            table.insert(site.storageChests, {status="free", itemName=nil, location=coremove.GetDivergentDirection(shaft, -1,  0), actual=0, virtual=0, stackSize=0, chestIndex=#site.storageChests+1})
        end

        -- reserve the first chest for charcoal
        site.storageChests[1].status    = "used"
        site.storageChests[1].itemName  = "minecraft:charcoal"
        site.storageChests[1].stackSize = 64
    end

    -- add this new site to our data
    local sites = coredht.GetData(db.dhtRoot, db.dhtSites)

    -- set the index
    site.sitesIndex = #sites + 1

    -- add this site to the dht
    table.insert(sites, site)

    -- save the dht
    coredht.SaveData(sites, db.dhtRoot, db.dhtSites)
end

function FindSiteByTopChest(site, location)
--[[
    This function checks of this site has a topchest which matches the given location. Returns nil if not found
--]]

    -- loop our top chests
    for i, topChest in ipairs(site.topChests) do

        -- this the one?
        if coremove.IsSameLocation(location, topChest.location) then return topChest end
    end

    -- still here? Then we have found no match
    return nil
end

--[[
                _                                  _
               (_)                                | |
   __ _ ___ ___ _  __ _ _ __  _ __ ___   ___ _ __ | |_ ___
  / _` / __/ __| |/ _` | '_ \| '_ ` _ \ / _ \ '_ \| __/ __|
 | (_| \__ \__ \ | (_| | | | | | | | | |  __/ | | | |_\__ \
  \__,_|___/___/_|\__, |_| |_|_| |_| |_|\___|_| |_|\__|___/
                   __/ |
                  |___/
--]]

function ItemsDeliveredAssignement(data)

    -- variables from the assignment data
    local site      = coredht.GetData(db.dhtRoot, db.dhtSites, data.sitesIndex)
    local topChest  = site.topChests[ data.topChestIndex ]

    -- go to the pickup point
    coremove.MoveTo(coremove.GetRelativeLocationUp(topChest.location, 1))

    -- get all items from the chest
    turtle.select(1)
    coreinventory.GetAllItems("down")

    -- asume it's empty and mark it as free
    coredht.SaveData("free", db.dhtRoot, db.dhtSites, data.sitesIndex, "topChests", data.topChestIndex, "status")

    -- make list of items in inventory
    local inventory = coreinventory.GetInventoryDetail()

    -- loop all storage chests and see which we need
    for i, storageChest in ipairs(site.storageChests) do

        -- unused chest?
        if storageChest.status == "free" then

            -- anything left to store?
            local itemName, itemCount = next(inventory.items, nil)

            -- we will use this chest for this item, if any item still present in our inventory
            if itemName ~= nil then

                -- make a reservation for this item
                storageChest.status     = "used"
                storageChest.itemName   = itemName
                storageChest.stackSize  = coreinventory.GetStackSize( itemName )
                storageChest.actual     = 0
                storageChest.virtual    = 0

                -- save info
            else
                -- seems there is nothing left to store
                break
            end
        end

        -- see if this chest matches any of our
        if inventory.items[ storageChest.itemName ] ~= nil then

            -- nice, we have a match, let's store! for now ignore that the chest might be full
            -- move to the chest
            coremove.GoTo(storageChest.location)

            -- dump the stuff
            for slot=1,16 do

                -- anything present in this slot, with the right name?
                if type(inventory.slots[ slot ]) == "table" and inventory.slots[ slot ].itemName == storageChest.itemName then

                    -- select this slot, since it will be used!
                    turtle.select(slot)

                    -- for some math
                    local beforeCount   = turtle.getItemCount()

                    -- transfer!
                    turtle.drop()

                    -- more math
                    local afterCount    = turtle.getItemCount()

                    -- update storage information
                    storageChest.actual     = storageChest.actual   + (beforeCount - afterCount)
                    storageChest.virtual    = storageChest.virtual  + (beforeCount - afterCount)
                    coredht.SaveData(storageChest, db.dhtRoot, db.dhtSites, site.sitesIndex, "storageChests", storageChest.chestIndex)

                    -- this slot is empty now
                    if afterCount == 0 then inventory.slots[ slot ] = nil end

                    -- adjust total present in inventory
                    inventory.items[ storageChest.itemName ] = inventory.items[ storageChest.itemName ] - (beforeCount - afterCount)
                end
            end

            -- all gone?
            if inventory.items[ storageChest.itemName ] <= 0 then inventory.items[ storageChest.itemName ] = nil end

        end
    end

    -- store all the items & update site information
    -- ? done ?
end

function RetrieveItemsAssignement(data)
    -- variables
    local site          = coredht.GetData(db.dhtRoot, db.dhtSites, data.sitesIndex)
    local itemList      = data.itemList
    local dropLocation  = data.dropLocation

    coreutils.WriteToLog("data")
    coreutils.WriteToLog(data)

    -- get to work
    turtle.select(1)
    coremove.MoveTo(site.entryLocation)

    -- loop the storage chests to see if there is anything we need
    for chestIndex, storageChest in ipairs(site.storageChests) do

        -- unused chest?
        local itemName  = storageChest.itemName

        if storageChest.status == "used" and storageChest.actual > 0 and itemList[ itemName ] ~= nil and itemList[ itemName ] > 0 then

            -- nice, we have a match, let's get what we need!
            -- move to the chest
            coremove.GoTo(storageChest.location)

            -- how much can we grab?
            local toSuck    = math.min(storageChest.actual, itemList[ itemName ], storageChest.stackSize)

            -- keep working while usefull
            while toSuck > 0 do

                -- suck this amount
                turtle.suck( toSuck )

                -- update values
                storageChest.actual     = storageChest.actual               - toSuck
                storageChest.virtual    = storageChest.virtual              - toSuck
                itemList[ itemName ]    = itemList[ itemName ]              - toSuck

                -- storage cheset updated, write to dht
                coredht.SaveData(storageChest, db.dhtRoot, db.dhtSites, site.sitesIndex, "storageChests", chestIndex)

                -- recalculate
                toSuck    = math.min(storageChest.actual, itemList[ storageChest.itemName ], storageChest.stackSize)
            end
        end
    end

    -- time to drop our stuff
    coremove.MoveTo(coremove.GetRelativeLocationUp(dropLocation, 1))
    local cargoList = coreinventory.DropAllItems("down")

    -- done
    return cargoList
end
