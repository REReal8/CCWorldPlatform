
--[[
    The chest mobj represents a chest in the minecraft world and provides services to operate on that chest.

??    This enterprise is both a Supplier and a Storage, hence it provides the mandatory services and functions for the types (like e.g. Can_ProvideItems_QSrv, GetItemsIntoTurtle_ASrv and PutItemsFromTurtle_ASrv).

    The following design decisions are made
        - Chests should never be accessed directly but only via the services of this mobj.
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function FetchChestSlotsInventory_ASrv(...)
    -- get & check input from description
    local checkSuccess, chest, callback, callbackData = coreutils.CheckInput([[
        This async private service fetches the slots inventory from a chest.

        Return value:
            nil

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the service executed successfully
                slots           - (table) the slots inventory of a chest

        Parameters:
            serviceData         - (table) data about the service
                chest           + (table) the chest
            callback            + (string) name of function to call once service is ready
            callbackData        + (table, {}) data to supply to callback function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.mobj_chest: Invalid input") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- fetch with an assignment
    local taskData = {
        location = coremove.CopyLocation(chest.location),
        accessDirection = chest.accessDirection,
    }
    local assignmentServiceData = {
        metaData    = role_chests_worker.FetchChestSlotsInventory_MetaData(taskData),
        task        = "role_chests_worker.FetchChestSlotsInventory_Task",
        taskData    = taskData,
    }
    enterprise_assignmentboard.DoAssignment_ASrv(assignmentServiceData, callback, callbackData)
end

function FetchItemsFromChestIntoTurtle_ASrv(...)
    -- get & check input from description
    local checkSuccess, chest, itemsQuery, assignmentsPriorityKey, callback, callbackData = coreutils.CheckInput([[
        This async private service fetches items from a chest into the inventory of a turtle.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                slots                   - (table) the slots inventory of the chest (after the items have been removed)
                turtleURL               - (table) a URL stating the turtle and the items it has gotton in it's inventory

        Parameters:
            serviceData                 - (table) data about the service
                chest                   + (table) the chest
                itemsQuery              + (table) items to be fetched
                assignmentsPriorityKey  + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                    + (string) name of function to call once service is ready
            callbackData                + (table, {}) data to supply to callback function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("mobj_chest.FetchItemsFromChestIntoTurtle_ASrv: Invalid input") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- fetch with an assignment
    local taskData = {
        location        = coremove.CopyLocation(chest.location),
        accessDirection = chest.accessDirection,
        itemsQuery      = itemsQuery,

        priorityKey     = assignmentsPriorityKey,
    }
    local assignmentServiceData = {
        metaData    = role_chests_worker.FetchItemsFromChestIntoTurtle_MetaData(taskData),
        task        = "role_chests_worker.FetchItemsFromChestIntoTurtle_Task",
        taskData    = taskData,
    }
    enterprise_assignmentboard.DoAssignment_ASrv(assignmentServiceData, callback, callbackData)
end

function PutItemsFromTurtleIntoChest_ASrv(...)
    -- get & check input from description
    local checkSuccess, turtleItemsLocator, chest, assignmentsPriorityKey, callback, callbackData = coreutils.CheckInput([[
        This async private service puts items from a the inventory of a turtle into a chest.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                slots                   - (table) the slots inventory of the chest (after the items have been put)

        Parameters:
            serviceData                 - (table) data about the service
                turtleItemsLocator      + (URL) stating a specific turtle and the items in it's inventory that need to be put
                chest                   + (table) the chest
                assignmentsPriorityKey  + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                    + (string) name of function to call once service is ready
            callbackData                + (table, {}) data to supply to callback function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("mobj_chest.PutItemsFromTurtleIntoChest_ASrv: Invalid input") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- check source is a turtle
    local serviceResults = enterprise_turtle.IsTurtleURL_QSrv({ aURL = turtleItemsLocator})
    if not serviceResults.success then corelog.Error("mobj_chest.PutItemsFromTurtleIntoChest_ASrv: Invalid turtle source URL (="..turtleItemsLocator:getURI()..").") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- put with an assignment
    local taskData = {
        turtleId        = turtleItemsLocator:getPort(),
        itemsQuery      = coreutils.DeepCopy(turtleItemsLocator:getQuery()),
        location        = coremove.CopyLocation(chest.location),
        accessDirection = chest.accessDirection,

        priorityKey     = assignmentsPriorityKey,
    }
    local assignmentServiceData = {
        metaData    = role_chests_worker.PutItemsFromTurtleIntoChest_MetaData(taskData),
        task        = "role_chests_worker.PutItemsFromTurtleIntoChest_Task",
        taskData    = taskData,
    }
    enterprise_assignmentboard.DoAssignment_ASrv(assignmentServiceData, callback, callbackData)
end

function CopyChest(...)
    -- get & check input from description
    local checkSuccess, id, location, accessDirection, itemsInventory = coreutils.CheckInput([[
        This async private function copies a chest mobj.

        Return value:
            chest                       - (table) copy of the chest

        Parameters:
            chest                       - (table) chest to copy
                id                      + (string) id of the chest
                location                + (table) location to the chest
                accessDirection         + (string) whether to access chest from "bottom", "top", "left", "right", "front" or "back" (relative to location)
                itemsInventory          + (table) the (items) inventory of the chest
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("mobj_chest.CopyChest: Invalid input") return nil end

	return {
        id              = id,

        location        = coremove.CopyLocation(location),
        accessDirection = accessDirection,

        itemsInventory  = coreinventory.CopyItems(itemsInventory)
	}
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

