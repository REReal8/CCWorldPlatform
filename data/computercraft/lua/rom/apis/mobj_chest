
--[[
    The Chest mobj represents a chest in the minecraft world and provides services to operate on that chest.

??    This enterprise is both a Supplier and a Storage, hence it provides the mandatory services and functions for the types (like e.g. Can_ProvideItems_QSrv, GetItemsIntoTurtle_ASrv and PutItemsFromTurtle_ASrv).

    The following design decisions are made
        - Chest s should never be accessed directly but only via the services of this mobj.
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function UpdateChestInventory_ASrv(...)
    -- get & check input from description
    local checkSuccess, chest, callback, callbackData = coreutils.CheckInput([[
        This async private service updates (fetches) the inventory from a chest.

        Return value:
            nil

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the service executed successfully
                chest           - (table) the chest

        Parameters:
            serviceData         - (table) data about the service
                chest           + (table) the chest
            callback            + (string) name of function to call once service is ready
            callbackData        + (table, {}) data to supply to callback function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.mobj_chest: Invalid input") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- create project definition
    local taskData = {
        location = coremove.CopyLocation(chest.location),
        accessDirection = chest.accessDirection,
    }
    local projectData = {
        chest           = mobj_chest.CopyChest(chest),

        task            = "role_chests_worker.FetchChestSlotsInventory_Task",
        metaData        = role_chests_worker.FetchChestSlotsInventory_MetaData(taskData),
        taskData        = taskData,
    }
    local projectDef = {
        steps   = {
            { stepName = "enterprise_assignmentboard.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "task"                   , valueSource = 0, keyDefSource = "task" },
                { keyDef = "metaData"               , valueSource = 0, keyDefSource = "metaData" },
                { keyDef = "taskData"               , valueSource = 0, keyDefSource = "taskData" },
            }},
            { stepName = "mobj_chest.DetermineItemsList_SSrv", async = false, stepDataDef = {
                { keyDef = "slots"                  , valueSource = 1, keyDefSource = "slots" },
            }},
            { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                { keyDef = "success1"               , valueSource = 1, keyDefSource = "success" },
                { keyDef = "success2"               , valueSource = 2, keyDefSource = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , valueSource = 3, keyDefSource = "success" },
            { keyDef = "chest"                      , valueSource = 0, keyDefSource = "chest" },
            { keyDef = "chest.itemsInventory"       , valueSource = 2, keyDefSource = "items" },
        }
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function FetchItemsFromChestIntoTurtle_ASrv(...)
    -- get & check input from description
    local checkSuccess, chest, items, assignmentsPriorityKey, callback, callbackData = coreutils.CheckInput([[
        This async private service fetches items from a chest into the inventory of a turtle.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                chest                   - (table) the chest (after the items have been removed)
                turtleItemsLocator      - (URL) locating a specific turtle and the items it has gotton in it's inventory

        Parameters:
            serviceData                 - (table) data about the service
                chest                   + (table) the chest
                items                   + (table) items to be fetched
                assignmentsPriorityKey  + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                    + (string) name of function to call once service is ready
            callbackData                + (table, {}) data to supply to callback function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("mobj_chest.FetchItemsFromChestIntoTurtle_ASrv: Invalid input") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- create project definition
    local taskData = {
        location        = coremove.CopyLocation(chest.location),
        accessDirection = chest.accessDirection,
        itemsQuery      = items,

        priorityKey     = assignmentsPriorityKey,
    }
    local projectData = {
        chest           = mobj_chest.CopyChest(chest),

        task            = "role_chests_worker.FetchItemsFromChestIntoTurtle_Task",
        metaData        = role_chests_worker.FetchItemsFromChestIntoTurtle_MetaData(taskData),
        taskData        = taskData,
    }
    local projectDef = {
        steps   = {
            { stepName = "enterprise_assignmentboard.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "task"                   , valueSource = 0, keyDefSource = "task" },
                { keyDef = "metaData"               , valueSource = 0, keyDefSource = "metaData" },
                { keyDef = "taskData"               , valueSource = 0, keyDefSource = "taskData" },
            }},
            { stepName = "mobj_chest.DetermineItemsList_SSrv", async = false, stepDataDef = {
                { keyDef = "slots"                  , valueSource = 1, keyDefSource = "slots" },
            }},
            { stepName = "enterprise_turtle.GetItemsLocator_SSrv", async = false, stepDataDef = {
                { keyDef = "turtleId"               , valueSource = 1, keyDefSource = "turtleId" },
                { keyDef = "itemsQuery"             , valueSource = 1, keyDefSource = "itemResultQuery" },
            }},
            { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                { keyDef = "success1"               , valueSource = 1, keyDefSource = "success" },
                { keyDef = "success2"               , valueSource = 2, keyDefSource = "success" },
                { keyDef = "success3"               , valueSource = 3, keyDefSource = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , valueSource = 4, keyDefSource = "success" },
            { keyDef = "chest"                      , valueSource = 0, keyDefSource = "chest" },
            { keyDef = "chest.itemsInventory"       , valueSource = 2, keyDefSource = "items" },
            { keyDef = "turtleItemsLocator"         , valueSource = 3, keyDefSource = "itemsLocator" },
        }
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function PutItemsFromTurtleIntoChest_ASrv(...)
    -- get & check input from description
    local checkSuccess, chest, turtleItemsLocator, assignmentsPriorityKey, callback, callbackData = coreutils.CheckInput([[
        This async private service puts items from a the inventory of a turtle into a chest.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                chest                   - (table) the chest (after the items have been put)

        Parameters:
            serviceData                 - (table) data about the service
                chest                   + (table) the chest
                turtleItemsLocator      + (URL) stating a specific turtle and the items in it's inventory that need to be put
                assignmentsPriorityKey  + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                    + (string) name of function to call once service is ready
            callbackData                + (table, {}) data to supply to callback function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("mobj_chest.PutItemsFromTurtleIntoChest_ASrv: Invalid input") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- check source is a turtle
    local serviceResults = enterprise_turtle.IsTurtleURL_QSrv({ aURL = turtleItemsLocator})
    if not serviceResults.success then corelog.Error("mobj_chest.PutItemsFromTurtleIntoChest_ASrv: Invalid turtle source URL (="..turtleItemsLocator:getURI()..").") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- create project definition
    local taskData = {
        turtleId        = turtleItemsLocator:getPort(),
        itemsQuery      = coreutils.DeepCopy(turtleItemsLocator:getQuery()),
        location        = coremove.CopyLocation(chest.location),
        accessDirection = chest.accessDirection,

        priorityKey     = assignmentsPriorityKey,
    }
    local projectData = {
        chest           = mobj_chest.CopyChest(chest),

        task            = "role_chests_worker.PutItemsFromTurtleIntoChest_Task",
        metaData        = role_chests_worker.PutItemsFromTurtleIntoChest_MetaData(taskData),
        taskData        = taskData,
    }
    local projectDef = {
        steps   = {
            { stepName = "enterprise_assignmentboard.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "task"                   , valueSource = 0, keyDefSource = "task" },
                { keyDef = "metaData"               , valueSource = 0, keyDefSource = "metaData" },
                { keyDef = "taskData"               , valueSource = 0, keyDefSource = "taskData" },
            }},
            { stepName = "mobj_chest.DetermineItemsList_SSrv", async = false, stepDataDef = {
                { keyDef = "slots"                  , valueSource = 1, keyDefSource = "slots" },
            }},
            { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                { keyDef = "success1"               , valueSource = 1, keyDefSource = "success" },
                { keyDef = "success2"               , valueSource = 2, keyDefSource = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , valueSource = 3, keyDefSource = "success" },
            { keyDef = "chest"                      , valueSource = 0, keyDefSource = "chest" },
            { keyDef = "chest.itemsInventory"       , valueSource = 2, keyDefSource = "items" },
        }
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function CopyChest(...)
    -- get & check input from description
    local checkSuccess, id, location, accessDirection, itemsInventory = coreutils.CheckInput([[
        This async private function copies a chest mobj.

        Return value:
            chest                       - (table) copy of the chest

        Parameters:
            chest                       - (table) chest to copy
                id                      + (string) id of the chest
                location                + (table) location to the chest
                accessDirection         + (string) whether to access chest from "bottom", "top", "left", "right", "front" or "back" (relative to location)
                itemsInventory          + (table) the (items) inventory of the chest
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("mobj_chest.CopyChest: Invalid input") return nil end

	return {
        id              = id,

        location        = coremove.CopyLocation(location),
        accessDirection = accessDirection,

        itemsInventory  = coreinventory.CopyItems(itemsInventory)
	}
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function DetermineItemsList_SSrv(...)
    -- get & check input from description
    local checkSuccess, slots = coreutils.CheckInput([[
        This sync private service determined an items list from a slots inventory.

        Return value:
                                - (table)
                success         - (boolean) whether the service executed successfully
                items           - (table) items list of a chest

        Parameters:
            serviceData         - (table) data for this service
                slots           + (table) slots inventory of a chest
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.DetermineItemsList_SSrv: Invalid input") return {success = false} end

    -- determine items inventory
    local items = coreinventory.DetermineItemsList(slots)

    -- end
    return {
        success = true,
        items   = items,
    }
end
