local db	= {
	dbFilename  	= "/db/coreutils.lua",
	logfile			= "/log/log.txt",
	protocol		= "coreutils",
    serial			= 0,                                -- for unique id's
	loggerChannel	= 65534,
}

local monitorLeft	= nil
local monitorRight	= nil

-- laatste serial uit de file lezen?
function Init()
	-- read from file
	local dbFile = ReadTableFromFile(db.dbFilename)

	-- check for empty table --> https://stackoverflow.com/questions/1252539/most-efficient-way-to-determine-if-a-lua-table-is-empty-contains-no-entries
	if next(dbFile) ~= nil then db = dbFile end

	-- uniek random nummer
	math.randomseed(os.time())

	-- place markers in the logfile
	WriteToLog("--- starting up ---", "overwrite")
end

-- niet nodig voor utils
function Setup()
	-- start sending messages when we are ready to receive them too
	coreevent.EventReadyFunction(EventReadySetup)

	-- let others check our pulse
	coreevent.AddEventListener(DoEventPulseRequest,	db.protocol, "pulse request")

	-- check if we have monitors on our side (and we are not a turtle, so a handheld or computer)
	if peripheral.getType("left") == "monitor" and peripheral.getType("right") == "monitor" and not turtle then

		-- get monitor handles
		monitorLeft		= peripheral.wrap("left")
		monitorRight	= peripheral.wrap("right")

		-- start at the bottom
		monitorLeft.clear()
		local w, h = monitorLeft.getSize()
		monitorLeft.setCursorPos(1,h)

		-- we will be the logger of this system
		coreassignment.RejectAllAssignments()

		-- listen to the logger port
		coreevent.OpenChannel(db.loggerChannel, db.protocol)

		-- listen to our events
		coreevent.AddEventListener(DoEventWriteToLog, db.protocol, "write to log")

		-- show who's boss!
		WriteToMonitor("--- starting up monitor ---", monitorLeft)
	end
end

function EventReadySetup()
	-- startup, read from disk or get data from peers? Why not both!
--	coreevent.SendMessage({protocol=db.protocol, subject="what is the current time"})
end

-- generates a new id
function NewId()

	-- eentje ophogen
	db.serial = db.serial + 1

	-- write to disk
	WriteToFile(db.dbFilename, db, "overwrite")

	-- id is een altijd een string
	return os.getComputerID() .. ":" .. db.serial
end

function IdCreator(id)
	local t	= {}

	-- split op :
	for str in string.gmatch(id, "([^:]+)") do table.insert(t, str) end

	-- waarde voor de : is de creator
	return t[0]
end

function IdSerial(id)
	local t	= {}

	-- split op :
	for str in string.gmatch(id, "([^:]+)") do table.insert(t, str) end

	-- waarde voor de : is de creator
	return t[1]
end

function ReadTableFromFile(filename)
	-- does the db file exist?
	if fs.exists(filename) then
		-- var's
		local fh = fs.open(filename, 'r')

		-- read from the file
		local text = fh.readAll()

		-- text to table
		local tbl = textutils.unserialize(text)

		-- close the file
		fh.close()

		-- return the table
		return tbl
	end

	-- still here? empty table
	return {}
end

function WriteToFile(filename, message, writemode)
	local mode	= "a"

	-- check writemode
	if writemode == "overwrite" then mode = "w" end

	-- if we get a table, make it a string
	if type(message) == "table" then message = textutils.serialize(message)	end

	-- bestandsnaam controleren, moet gewoon een string zijn natuurlijk
	if type(filename) ~= "string" then filename = db.logfile message = message..debug.traceback() end

	-- bestand openen, schrijven en sluiten
	local fileHandle = fs.open(filename, mode)
	if fileHandle then
		fileHandle.writeLine(message)
		fileHandle.close()
	else
		print("Cannot open file "..filename)
	end
end

function WriteToLog(message, writeMode)
	-- set the default
	writeMode = writeMode or "append"

	-- write to the logfile
	WriteToFile(db.logfile, message, writeMode)

	-- send message
	if monitorLeft then
		-- we are the logging station, don't send message
		WriteToMonitor(message, monitorLeft)
	else

		-- send message two whoever is loggin our stuff
		coreevent.SendMessage({
			channel		= db.loggerChannel,
			protocol	= db.protocol,
			subject		= "write to log",
			message		= {text = message} })
	end
end

function WriteToMonitor(message, monitor)
	-- default monitor
	monitor = monitor or monitorLeft

	-- write to an attached monitor if available (usefull for a stataus monitor screen)
	if monitor then
		local w, h = monitor.getSize()

		-- scroll the existing stuff up
		monitor.scroll(1)

		-- write the message
		monitor.write(message)

		-- set the cursus back at the start of the line
		monitor.setCursorPos(1,h)
	end
end

function Warning(message)
	-- write to the logfile
	WriteToFile(db.logfile, message, "append")
end

function Error(message)
	-- write to the logfile
	WriteToFile(db.logfile, "ERROR:", "append")
	WriteToFile(db.logfile, message, "append")
end

function UniversalTime()
	return 24 * os.day() + os.time() -- https://computercraft.info/wiki/Os.time (waarde tussen 0 en 23.999)
end

function CoreUtilsProtocolName()
	return db.protocol
end

--                         _
--                        | |
--     _____   _____ _ __ | |_ ___
--    / _ \ \ / / _ \ '_ \| __/ __|
--   |  __/\ V /  __/ | | | |_\__ \
--    \___| \_/ \___|_| |_|\__|___/
--
--

function DoEventPulseRequest(subject, envelope)
	local fuelLevel

	-- computers don't have a fuel level
	if turtle	then fuelLevel = turtle.getFuelLevel()
				else fuelLevel = 0
	end

	-- send some information about us back
    coreevent.ReplyToMessage(envelope, "pulse response", {fuelLevel=fuelLevel})
end

function DoEventWriteToLog(subject, envelope)
	-- write the message on the monitor
	WriteToMonitor(envelope.message.text, monitorLeft)
end