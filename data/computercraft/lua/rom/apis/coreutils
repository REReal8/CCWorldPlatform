local db	= {
	dbFilename  	= "/db/coreutils.lua",
	protocol		= "coreutils",
    serial			= 0,                                -- for unique id's
}

-- laatste serial uit de file lezen?
function Init()
	-- read from file
	local dbFile = ReadTableFromFile(db.dbFilename)

	-- check for empty table --> https://stackoverflow.com/questions/1252539/most-efficient-way-to-determine-if-a-lua-table-is-empty-contains-no-entries
	if next(dbFile) ~= nil then db = dbFile end

	-- uniek random nummer
	math.randomseed(os.time())
end

-- niet nodig voor utils
function Setup()
	-- start sending messages when we are ready to receive them too
	coreevent.EventReadyFunction(EventReadySetup)		-- ToDo: consider removing as nothing is done
end

function EventReadySetup()
	-- startup, read from disk or get data from peers? Why not both!
--	coreevent.SendMessage({protocol=db.protocol, subject="what is the current time"})
end

-- generates a new id
function NewId()

	-- eentje ophogen
	db.serial = db.serial + 1

	-- write to disk
	WriteToFile(db.dbFilename, db, "overwrite")

	-- id is een altijd een string
	return os.getComputerID() .. ":" .. db.serial
end

function IdCreator(id)
	local t	= {}

	-- split op :
	for str in string.gmatch(id, "([^:]+)") do table.insert(t, str) end

	-- waarde voor de : is de creator
	return t[0]
end

function IdSerial(id)
	local t	= {}

	-- split op :
	for str in string.gmatch(id, "([^:]+)") do table.insert(t, str) end

	-- waarde voor de : is de creator
	return t[1]
end

function ReadTableFromFile(filename)
	-- does the db file exist?
	if fs.exists(filename) then
		-- var's
		local fh = fs.open(filename, 'r')

		-- read from the file
		local text = fh.readAll()

		-- text to table
		local tbl = textutils.unserialize(text)

		-- close the file
		fh.close()

		-- return the table
		return tbl
	end

	-- still here? empty table
	return {}
end

function WriteToFile(filename, message, writemode)
	local mode	= "a"

	-- check writemode
	if writemode == "overwrite" then mode = "w" end

	-- if we get a table, make it a string
	if type(message) == "table" then message = textutils.serialize(message)	end

	-- bestandsnaam controleren, moet gewoon een string zijn natuurlijk
	if type(filename) ~= "string" then filename = db.logfile message = message..debug.traceback() end

	-- bestand openen, schrijven en sluiten
	local fileHandle = fs.open(filename, mode)
	if fileHandle then
		fileHandle.writeLine(message)
		fileHandle.close()
	else
		print("Cannot open file "..filename)
	end
end

function UniversalTime()
	return 24 * os.day() + os.time() -- https://computercraft.info/wiki/Os.time (waarde tussen 0 en 23.999)
end

function CoreUtilsProtocolName() -- ToDo: is this used? If not consider removing (including protocol variable from db)
	return db.protocol
end

function DoCallback(callback, callbackData, result)
    -- check input
    if type(callback) ~= "string" then corelog.Error("coreutils.DoCallback: Invalid callback function") return nil end
    if type(callbackData) ~= "table" then corelog.Error("coreutils.DoCallback: Invalid callbackData") return nil end
    if type(result) ~= "table" then corelog.Error("coreutils.DoCallback: Invalid calback result") return nil end

    -- call callBack function
    local stringToLoad = callback.."("..textutils.serialize(callbackData)..","..textutils.serialize(result).. ")"
    local f, err = loadstring(stringToLoad)
    if f then f() else corelog.Error("coreutils.DoCallback: loadstring("..stringToLoad..") did not supply a function, error given: "..err) end
end

function DoSyncService(service, serviceData)
	-- check input
	if type(service) ~= "string" then corelog.Error("coreutils.DoSyncService: Invalid service function") return nil end
	if type(serviceData) ~= "table" then corelog.Error("coreutils.DoSyncService: Invalid serviceData") return nil end

    -- check service actually exists
    -- ToDo: implement

	-- prepare sync service call
	local f, err = loadstring("return "..service.."("..textutils.serialize(serviceData)..")")
	if not f then corelog.Error("coreutils.DoSyncService(): loadstring did not supply a function, error given: "..err) return end

	-- execute the service
	local results = f()

	-- end
	return results
end

function DoASyncService(service, serviceData, callback, callbackData)
	-- check input
	if type(service) ~= "string" then corelog.Error("coreutils.DoASyncService: Invalid service function") return nil end
	if type(serviceData) ~= "table" then corelog.Error("coreutils.DoASyncService: Invalid serviceData") return nil end
	if type(callback) ~= "string" then corelog.Error("coreutils.DoASyncService: Invalid callback function") return nil end
	if type(callbackData) ~= "table" then corelog.Error("coreutils.DoASyncService: Invalid callbackData") return nil end

    -- check service actually exists
    -- ToDo: implement

	-- prepare async service call
	local f, err = loadstring(service.."("..textutils.serialize(serviceData)..", '"..callback.."', "..textutils.serialize(callbackData)..")")
	if not f then corelog.Error("coreutils.DoASyncService(): loadstring did not supply a function, error given: "..err) return nil end

	-- execute the service
	f()

	-- end
	return nil
end

function DeepCopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[DeepCopy(orig_key)] = DeepCopy(orig_value)
        end
        setmetatable(copy, DeepCopy(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

function CheckInput(description, ...)
    -- for debugging
    corelog.WriteToLog("coreutils.CheckInput: debug.getinfo(2).source = "..debug.getinfo(2).source)

    -- controle of description wel een string is
    if type(description) ~= "string" then corelog.Error("CheckInput:"..debug.getinfo(2).name..": description is not a string") return false end

    -- dit hebben we nodig om de tekst te lezen
    local parameterStart    = nil
    local indentSize        = 0
    local lastIndent        = 0
    local lastArgument      = 0
    local indenting         = {}
    local returns           = {}

    -- regel voor regels langs lopen
    for stringPart in description:gmatch("[^\r\n]+") do

        -- hebben we al het woord 'parameter' gevonden?
        if parameterStart then

            -- zoeken of de parameter regel matched
            local start, parameter, needed, typeType = string.match(stringPart, "(%s+)(%w+)%s*([%+%-])%s*%(([^%)]+)%)")

            -- might be a dummy line
            if start then

                -- default opgegeven?
                local defaultPresent = false
                local theType, theDefault = string.match(typeType, "^%s*([^,]+)%s*,%s*([^,]+)%s*$")
                if theType and theDefault then

                    -- default verwerken
                    typeType        = theType
                    defaultPresent  = true

                    -- default instellen
                    local theDefaultFunction = load("return " .. theDefault)
                    if theDefaultFunction then theDefault = theDefaultFunction() end
                end

                -- indent al bekend?
                if indentSize == 0 then indentSize = string.len(start) - parameterStart end

                -- huidige indenting berekenen
                local indent = math.floor((string.len(start) - parameterStart) / indentSize)

                -- controle
                if indent < 1 or indent > lastIndent + 1 then corelog.Error("CheckInput:"..debug.getinfo(2).name..": indent error (indent = "..indent..", lastIndent = "..lastIndent..")") return false end

                -- argument opzoeken
                local argument
                if indent == 1 then

                    -- komt blijkbaar uit de lijst met argumenten
                    lastArgument = lastArgument + 1
                    argument = arg[ lastArgument ]
                else

                    -- komt blijkbaar uit een van de andere argumenten
                    if type(indenting[ indent - 1 ]) == "table" then argument = indenting[ indent - 1 ][ parameter ]
                                                                else corelog.Error("CheckInput:"..debug.getinfo(2).name..": indent parent not a table") return false
                    end
                end

                -- wellicht default toepassen
                if argument == nil and defaultPresent and theDefault ~= nil then argument = theDefault end

                -- voldoet het argument aan het opgegeven type?
                if type(argument) ~= typeType and not (typeType == "URL" and type(argument) == "table") then corelog.Error("CheckInput:"..debug.getinfo(2).name..": argument '"..parameter.."' not a "..typeType) return false end

                -- URL omvormen
                if typeType == "URL" then argument = url.URLClass:new(argument) end

                -- is deze gewenst om terug te geven?
                if needed == '+' then table.insert(returns, argument) end

                -- laatste van deze indent onthouden
                indenting[ indent ] = argument
                lastIndent          = indent
            end

        -- hmm, het woord 'parameter' nog niet eens gevonden
        else
            -- zoeken naar waar de parameters beginnen
            local start = string.find(stringPart, "[Pp]arameters")
            if start then parameterStart = start - 1 end
        end
    end

    -- done
    return true, table.unpack(returns)
end

-- function GetItemsIntoTurtle_ASrv(...)
--     -- check input
--     local success, sourceItemsLocator, assignmentsPriorityKey, callback, callbackData = CheckInput([[
--         This async public service ensures items are gathered in the Supplier and transferred to the inventory of a turtle.

--         Return value:
--             nil

--         Async service return value (to callback):
--                                         - (table)
--                 success                 - (boolean) whether the service executed successfully
--                 turtleItemsLocator      - (URL) locating a specific turtle and the items it has gotton in it's inventory

--         Parameters:
--             transferData                - (table) data about the transfer
--                 sourceItemsLocator      + (URL) locating the items that need transfer
--                                             (the "query" component of the URL specifies the items to be transferred)
--                                             (the "host" component of the URL should specify this host (i.e. a chest) where the items are located)
--                 assignmentsPriorityKey  + (string) priorityKey that should be set for all assignments triggered by this service
--             callback                    + (string) name of function to call once service is ready
--             callbackData                + (table, {}) data to supply to callback function
--     ]], table.unpack(arg))
--     if not success then coreutils.Error("oops") return end

--     print("success = ", success)
--     print("sourceItemsLocator = ",     sourceItemsLocator)
--     print("assignmentsPriorityKey = ", assignmentsPriorityKey)
--     print("callback = ",               callback)
--     print("callbackData = ",           callbackData)
-- end



-- ToDo: consider adding method to check for nested tables (to be able to catch the annoying errors)

--                         _
--                        | |
--     _____   _____ _ __ | |_ ___
--    / _ \ \ / / _ \ '_ \| __/ __|
--   |  __/\ V /  __/ | | | |_\__ \
--    \___| \_/ \___|_| |_|\__|___/
--
--
