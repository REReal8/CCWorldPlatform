local db = {
    dhtRoot                 = "coreassignment",
    listRoot                = "assignmentList",
    rejectAllAssignments    = false,
    lastSkipReason          = "",
}

--[[
    coreassignment offers functionalitt to handle assignments to be executed by turtles.

    An assignment revolves around a Task. A Task is a sequence of things that needs to be done (i.e. moving, rotating, placing etc) without interruption 
    in the physical minecraft world. A Task typically takes some time to execute.

    Two functions are involved with each assignment:
        - a task function defining the Task that needs to be executed.
        - a callback function that needs to be executed once the task has completed.

    A task function should take one parameter
        taskData                - (table) data to supply to task function to be able to perform the task
    and return a single result
        taskResult              - (table) with return data of the task function
    By convention a task function name should end with _Task (e.g. DoSomeWork_Task)

    A callback function should take two parameters
        callbackData            - (table) with predefined (additional) data to supply the callback with
        taskResult              - (table) with the return data of the task function
    and does not have a return value (i.e. it's nil).
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function Init()
end

function Setup()
    -- pas als de dht klaar is...
    coredht.DHTReadyFunction(DHTReadySetup)
end

function AddAssignment(metaData, taskFunction, taskData, callbackFunction, callbackData)
    --[[
        This public function adds a new assignment to the assignmentList.
        
        Return value:
                                    - (table)
                success             - (boolean) whether adding the assignment was a success

        Parameters:
            metaData                - (table) with meta data about the assignment that is used in the assignment selection proces (e.g. the fuel needs of the task)
            taskFunction            - (string) name of task function to execute
            taskData                - (table) data to supply to task function
            callback                - (string) name of function to call once task has been executed
            callbackData            - (table) data to supply to callback function
    ]]

    -- check input
    metaData.startTime     = metaData.startTime     or coreutils.UniversalTime()        --> tijd wanneer de assignment uitgevoerd moet worden, zal niet starten voor deze tijd
    metaData.location      = metaData.location      or nil                              --> nil-waarde voor locatie geeft aan dat locatie geen rol speelt bij de selectie
    metaData.needTool      = metaData.needTool      or false                            --> needTool geeft aan dat de turtle zelf voor een tool moet zorgen
    metaData.needTurtle    = metaData.needTurtle    or true
    metaData.needTurtleId  = metaData.needTurtleId  or nil                              --> nil-waarde voor needTurtleId geeft aan dat turtleId geen rol speelt bij de selectie
    metaData.fuelNeeded    = metaData.fuelNeeded    or 500                              --> minimum amount of fuel needed to grant assignment
    metaData.itemsNeeded   = metaData.itemsNeeded   or {}                               --> items needed in inventory to grant assignment
    if type(taskFunction) ~= "string" then corelog.Error("coreassignment.AddAssignment: taskFunction not a string") return end
    -- ToDo: investigate if there is a way to check if the actual function exists and has the proper argument without actually calling it
    if type(taskData) ~= "table" then corelog.Error("coreassignment.AddAssignment: taskData not a table") return end
    if type(callbackFunction) ~= "string" then corelog.Error("coreassignment.AddAssignment: callbackFunction not a string") return end
    -- ToDo: investigate if there is a way to check if the actual function exists and has the proper arguments without actually calling it
    if type(callbackData) ~= "table" then corelog.Error("coreassignment.AddAssignment: callbackData not a table") return end

    -- create assignment
    local assignmentId  = coreutils.NewId()
    local assignment = {
        assignmentId            = assignmentId,
        status                  = "open",
        applications            = {},

        metaData                = metaData,
        taskFunction            = taskFunction,
        taskData                = taskData,
        callbackFunction        = callbackFunction,
        callbackData            = callbackData,
    }

    -- log assignment
    corelog.WriteToAssignmentLog("Add new: "..textutils.serialize(assignment), assignmentId)

    -- store assignment
    coredht.SaveData(assignment, db.dhtRoot, db.listRoot, assignmentId)
end

-- coreassignment.Dummy_Callback
function Dummy_Callback(emptyTable)
    corelog.WriteToAssignmentLog("Dummy_Callback called")
    -- do nothing
end

function Run()
    -- is the dth available?
    while not coredht.IsReady() do

        -- just wait
        os.sleep(0.25)
    end

    -- infinite loop
    while core.IsSystemRunning() and not db.rejectAllAssignments do

        -- we zijn nu werkeloos
        local nextAssignment = nil

        -- look for best next assignment
        local assignmentApplication = FindBestAssignment()

        -- did we find one?
        if assignmentApplication then
            -- apply
            ApplyToAssignment(assignmentApplication)

            -- wait, maybe more turtles have applied
            os.sleep(1.25)

            -- check who gets the assignment
            nextAssignment = AssignmentSelectionProcedure(assignmentApplication)
        end

        -- did we get the assignment?
        if nextAssignment then
            DoAssignment(nextAssignment)
        else os.sleep(0.25)     -- apparently no assignment for me now
        end
    end
end

function RejectAllAssignments()
    -- just remember for now, nothing else
    db.rejectAllAssignments = true
end

function EndAssignments()
    local assignmentList = coredht.GetData(db.dhtRoot, db.listRoot)
    if not assignmentList or type(assignmentList) ~= "table" then corelog.Warning("coreassignment.EndAssignments: not a (valid) assignmentList") return nil end

    -- remove all assignments
    corelog.WriteToAssignmentLog("All Assignments are being ended!")
    for assignmentId, assignmentData in pairs(assignmentList) do
        -- check status and startTime
        EndAssignment(assignmentId)
    end
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/


function DHTReadySetup()
    -- bestaat de entry al in de dht?
    if not coredht.GetData(db.dhtRoot)              then coredht.SaveData({}, db.dhtRoot ) end
    if not coredht.GetData(db.dhtRoot, db.listRoot) then coredht.SaveData({}, db.dhtRoot, db.listRoot ) end
end

function FindBestAssignment()
--    corelog.WriteToAssignmentLog("Running FindBestVacancy")

    -- zoeken naar een assignment om op in te schrijven
    local assignmentList = coredht.GetData(db.dhtRoot, db.listRoot)

    -- check assignmentList
    if not assignmentList or type(assignmentList) ~= "table" then corelog.Error("coreassignment.FindBestAssignment: invalid assignmentList") return nil end

    -- check for assignments
    if next(assignmentList) == nil then
--        corelog.WriteToAssignmentLog("There are no assignments")
        return nil
    end

    -- select assignments satisfying meta conditions
    local candidateList = {}
    for assignmentId, assignmentData in pairs(assignmentList) do
        -- check assignment open
        if assignmentData.status == "open" then
            -- check metaconditions
            local conditionsMet, skipReason = MetaDataConditionsMet(assignmentData.metaData)
            if conditionsMet then
                table.insert(candidateList, {
                    id = assignmentId,
                    metaData = assignmentData.metaData,
                })
            else
                -- debug message
                if skipReason and skipReason ~= db.lastSkipReason then
                    -- Report reason for skipping for debugging purposes
                    corelog.WriteToAssignmentLog("Skipped because "..skipReason, assignmentId)

                    db.lastSkipReason = skipReason -- remember such that the log isn't floaded with similar messages
                end
            end
        end
    end

    -- select best assignment
    local bestCandidateData = nil
    for i, candidateData in ipairs(candidateList) do
        bestCandidateData = BestCandidate(bestCandidateData, candidateData)
    end

    -- end
    if bestCandidateData then
        return bestCandidateData.id
    else
        -- corelog.WriteToAssignmentLog("No assignment satisfying conditions")
        return nil
    end
end

function BestCandidate(candidateData1, candidateData2)
    -- check for data
    if not candidateData1 then
        return candidateData2
    end
    if not candidateData2 then
        return candidateData1
    end

    -- check needTurtleId
    local needTurtleId1 = candidateData1.metaData.needTurtleId
    local needTurtleId2 = candidateData2.metaData.needTurtleId
    if needTurtleId1 and not needTurtleId2 then
        return candidateData1
    elseif needTurtleId2 and not needTurtleId1 then
        return candidateData2
    else -- both are equal w.r.t. this condition
    end

    -- check fuelNeeded
    -- ToDo implement

    -- check age
    -- ToDo implement

    -- nothing else distinquishes the candidates => take first 
    return candidateData1
end

function MetaDataConditionsMet(metaData)
    -- check startTime
    local now            = coreutils.UniversalTime()
    if metaData.startTime > now then
--        return false, "assignment in the future (="..metaData.startTime..") (now ="..now..")"
        return false, "assignment in the future (="..metaData.startTime..")"
    end

    -- check optional turtle conditions
    if metaData.needTurtle then
        -- check mandatory turtle 
        if not turtle then
            return false, "mandatory turtle not present"
        end

        -- check needTurtleId
        if metaData.needTurtleId then
            local currentTurtleId = os.getComputerID()
            if currentTurtleId ~= metaData.needTurtleId then 
                return false, "turtle does not have(="..currentTurtleId..") mandatory turtleId (="..metaData.needTurtleId..")"
            end
        end

        -- check enough fuel for assignment (including traveling there from current location)
        local fuelNeeded = metaData.fuelNeeded + coreinventory.NeededFuelToFrom(metaData.location, coremove.GetLocation())
        if fuelNeeded > 0 then
            local fuelLevel = turtle.getFuelLevel()
            if fuelLevel < fuelNeeded then
                return false, "not enough(="..fuelNeeded..") fuel present(="..fuelLevel..")"
            end
        end

        -- check need pickaxe
        if metaData.needTool then
            -- check mandatory pickaxe
            local axePresent = coreinventory.Equip("minecraft:diamond_pickaxe")
            if not axePresent then
                return false, "mandatory pickaxe not present"
            end
        end

        -- check items in inventory
        -- ToDo: implement more efficient by using coreinventory.GetInventoryDetail
        for itemName, itemCount in pairs(metaData.itemsNeeded) do
            -- get items in inventory
            local items = coreinventory.CountItem(itemName)

            -- enough?
            if items < itemCount then
                return false, "not enough(="..itemCount..") "..itemName.." in inventory (="..items..")"
            end
        end
    end

    return true, ""
end

function ApplyToAssignment(assignmentId)
--    corelog.WriteToAssignmentLog("Running ApplyToAssignment", assignmentId)

    -- alleen solliciteren indien de assignment open is
    if coredht.GetData(db.dhtRoot, db.listRoot, assignmentId, "status") == "open" then
        -- wie zijn we?
        local me = os.getComputerID()

        -- onzelf (os.getComputerID()) toevoegen aan de lijst met inschrijvingen
        coredht.SaveData({
            time            = coreutils.UniversalTime(),
            dice            = math.random(),
            applicant       = me,
        }, db.dhtRoot, db.listRoot, assignmentId, "applications", me)
    end
end

function AssignmentSelectionProcedure(assignmentId)
--    corelog.WriteToAssignmentLog("Running assignmentSelectionProcedure", assignmentId)

    -- data van de assignment ophalen
    local assignment = coredht.GetData(db.dhtRoot, db.listRoot, assignmentId)

    -- see if this assignment is still open
    if assignment.status == "open" then
        --
        local applications = coredht.GetData(db.dhtRoot, db.listRoot, assignmentId, "applications")

        -- see who got the highest dice
        local highestDiceTurtle = nil
        local highestDiceValue = 0
        for turtleId, applicationData in pairs(applications) do
            if applicationData.dice >= highestDiceValue then
                highestDiceValue = applicationData.dice
                highestDiceTurtle = applicationData.applicant
            end
        end

        -- check if I got the highest dice
        if highestDiceTurtle == os.getComputerID() then
            return assignment
        end
    end

    -- apparently it's not for me
    return nil
end

function DoAssignment(assignment)
    -- we have taken this assignment!
    local assignmentId = assignment.assignmentId
    TakeAssignment(assignmentId)

    -- call task function
    corelog.WriteToAssignmentLog("Starting task", assignmentId)
    local taskResult = coreutils.DoSyncService(assignment.taskFunction, assignment.taskData)
    corelog.WriteToAssignmentLog("Completed task", assignmentId)

    -- call callBack function
    corelog.WriteToAssignmentLog("Calling callback function", assignmentId)
    coreutils.DoCallback(assignment.callbackFunction, assignment.callbackData, taskResult)

    -- we have done all for this assignment that we needed to do
    EndAssignment(assignmentId)
end

function TakeAssignment(assignmentId)
    -- data van de assignment ophalen
    local assignment = coredht.GetData(db.dhtRoot, db.listRoot, assignmentId)

    -- see if this assignment is still open
    if assignment.status == "open" then
        -- mark as staffed
        coredht.SaveData("staffed", db.dhtRoot, db.listRoot, assignmentId, "status")

        corelog.WriteToAssignmentLog("Taken", assignmentId)
    end
end

function EndAssignment(assignmentId)
    -- easy
    coredht.SaveData(nil, db.dhtRoot, db.listRoot, assignmentId)
    corelog.WriteToAssignmentLog("Ended", assignmentId)
end
