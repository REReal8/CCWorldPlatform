local db = {
    rejectAllAssignments    = false,
    fuelTurtlePriorityKey   = nil,
    fuelTurtleCallsSkippedBecausePriorityKey = 0,
}

--[[
    coreassignment offers functionality to have computers or turtles execute assignments advertised by enterprise_assignmentboard.

    An assignment revolves around a Task. A Task is a sequence of things that needs to be done (i.e. moving, rotating, placing etc) without interruption
    in the physical minecraft world. A Task typically takes some time to execute.

    Two functions are involved with each assignment:
        - a task function defining the Task that needs to be executed.
        - a callback function that needs to be executed once the task has completed.

    A task function should take one parameter
        taskData                - (table) data to supply to task function to be able to perform the task
    and return a single result
        taskResult              - (table) with return data of the task function
    By convention a task function name should end with _Task (e.g. DoSomeWork_Task)

    A callback function should take two parameters
        callbackData            - (table) with predefined (additional) data to supply the callback with
        taskResult              - (table) with the return data of the task function
    and does not have a return value (i.e. it's nil).
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function Init()
end

function Setup()
    -- pas als de dht klaar is...
    coredht.DHTReadyFunction(enterprise_assignmentboard.DHTReadySetup) -- ToDo: consider doing this in enterprise_assignmentboard itself
end

function Run()
    -- is the dth available?
    while not coredht.IsReady() do

        -- just wait
        os.sleep(0.25)
    end

    -- some variables
    local computerId = os.getComputerID()

    -- infinite loop
    while core.IsSystemRunning() and not db.rejectAllAssignments do
        -- turtle currently does not have an assignment (it is unemployed)
        local nextAssignment = nil

        -- (re)fuel turtle if needed
        FuelTurtleIfNeeded()

        -- ToDo: consider if an assignment board should determine what is best...
        -- look for best next assignment
        local assignmentFilter = {
            priorityKeyNeeded   = db.fuelTurtlePriorityKey,
        }
        local turtleResume = nil
        if turtle then
            turtleResume = {
                turtleId        = computerId,
                location        = coremove.GetLocation(),
                fuelLevel       = turtle.getFuelLevel(),
                axePresent      = coreinventory.Equip("minecraft:diamond_pickaxe"), -- ToDo: consider only checking not actually equiping
                inventoryItems  = coreinventory.GetInventoryDetail().items,
            }
        end
        local serviceResults = enterprise_assignmentboard.FindBestAssignment_SSrv({ assignmentFilter = assignmentFilter, turtleResume = turtleResume })
        if not serviceResults.success then corelog.Error("enterprise_chests.Run: FindBestAssignment_SSrv failed.") end
        local assignmentIdApplication = serviceResults.assignmentId

        -- did we find one?
        if assignmentIdApplication then
            -- apply
            enterprise_assignmentboard.ApplyToAssignment(assignmentIdApplication)

            -- wait, maybe more turtles have applied
            os.sleep(1.25)

            -- check who gets the assignment
            nextAssignment = enterprise_assignmentboard.AssignmentSelectionProcedure(assignmentIdApplication)
        end

        -- did we get the assignment?
        if nextAssignment then
            -- do the assignment
            DoAssignment(nextAssignment)
        else os.sleep(0.25)     -- apparently no assignment for me now
        end
    end
end

function RejectAllAssignments()
    -- just remember for now, nothing else
    db.rejectAllAssignments = true
end

function Reset()
    -- reset (local) db
    db.rejectAllAssignments                     = false
    db.fuelTurtlePriorityKey                    = nil
    db.fuelTurtleCallsSkippedBecausePriorityKey = 0
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function DoAssignment(assignment)
    -- we have taken this assignment!
    local assignmentId = assignment.assignmentId
    enterprise_assignmentboard.TakeAssignment(assignmentId)

    -- call task function
    corelog.WriteToAssignmentLog("Starting task", assignmentId)
    corelog.WriteToLog("Starting "..assignment.taskFunction)
    local taskResult = coreutils.DoSyncService(assignment.taskFunction, assignment.taskData)
    corelog.WriteToAssignmentLog("Completed task (result="..textutils.serialize(taskResult)..")", assignmentId)

    -- call callBack function
    corelog.WriteToAssignmentLog("Calling callback function", assignmentId)
    coreutils.DoCallback(assignment.callbackFunction, assignment.callbackData, taskResult)

    -- we have done all for this assignment that we needed to do
    enterprise_assignmentboard.EndAssignment(assignmentId)
end

function FuelTurtleIfNeeded()
    -- check if turtle is already focusing on fueling itself
    local turtleId = os.getComputerID()
    if db.fuelTurtlePriorityKey == nil then
        -- ensure this turtle now only starts taking new assignments with the priority key
        local priorityKey = coreutils.NewId()
        db.fuelTurtlePriorityKey = priorityKey

        -- prepare service call
        -- ToDo: it seems not right to call an enterprise from core code. Consider doing this differently (maybe make part of coreassignment into an enterprise?)
        local fuelLevel = turtle.getFuelLevel()
        local ingredientsSupplierLocator = enterprise_shop.GetHostLocator_SSrv({ }).hostLocator -- ToDo: get from elsewhere
        local serviceData = {
            assignmentsPriorityKey      = priorityKey,

            turtleId                    = turtleId,
            turtleFuelLevel             = fuelLevel,
            ingredientsSupplierLocator  = ingredientsSupplierLocator,
        }
        local callback = "coreassignment.Fuel_Callback"
        local callbackData = {
            turtleId = turtleId,
        }

        -- call service
        enterprise_energy.FuelTurtleToLevelIfNeeded_ASrv(serviceData, callback, callbackData)
    else
        -- remember skipping to ensure we can do another round once above FuelTurtleToLevelIfNeeded_ASrv is finished to ensure turtle is updated to latest levels
        db.fuelTurtleCallsSkippedBecausePriorityKey = db.fuelTurtleCallsSkippedBecausePriorityKey + 1
        corelog.WriteToAssignmentLog("Already (n="..db.fuelTurtleCallsSkippedBecausePriorityKey..") focusing on refueling with fuelTurtlePriorityKey="..db.fuelTurtlePriorityKey)
--        corelog.WriteToLog("* Already (n="..db.fuelTurtleCallsSkippedBecausePriorityKey..") focusing on refueling with fuelTurtlePriorityKey="..db.fuelTurtlePriorityKey.." *")
    end
end

function Fuel_Callback(callbackData, serviceResults)
    -- check input
    if type(callbackData) ~= "table" then corelog.Error("coreassignment.Fuel_Callback: Invalid callbackData") return {success = false} end
    local turtleId = callbackData.turtleId
    if type(turtleId) ~= "number" then corelog.Error("coreassignment.Fuel_Callback: Invalid turtleId") return {success = false} end

    -- check correct turtle
    local currentTurtleId = os.getComputerID()
    if currentTurtleId ~= turtleId then corelog.Error("coreassignment.Fuel_Callback: Current turtle(id="..currentTurtleId..") not equal to callback turtle(id="..turtleId..")") return {success = false} end

    -- release priority key condition
    db.fuelTurtlePriorityKey = nil

    -- check for skipping calls
    if db.fuelTurtleCallsSkippedBecausePriorityKey > 0 then
        -- do another round to be sure turtle has current fuelLevel
        corelog.WriteToAssignmentLog("FuelTurtleIfNeeded after skipping "..db.fuelTurtleCallsSkippedBecausePriorityKey.." times because it was already being refueled.")
--        corelog.WriteToLog("* FuelTurtleIfNeeded after skipping "..db.fuelTurtleCallsSkippedBecausePriorityKey.." times because it was already being refueled. *")
        db.fuelTurtleCallsSkippedBecausePriorityKey = 0
        FuelTurtleIfNeeded()
    end

    -- end
    return {success = true}
end
