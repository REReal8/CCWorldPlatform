local db = {
    dhtRoot                 = "coreassignment",
    listRoot                = "assignmentList",
    rejectAllAssignments    = false,
}

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function Init()
end

function Setup()
    -- pas als de dht klaar is...
    coredht.DHTReadyFunction(DHTReadySetup)
end

function AddAssignment(metaData, taskFunction, taskArgumentTable, callbackFunction, callbackArgumentTable)
    -- check input
    metaData.startTime     = metaData.startTime     or coreutils.UniversalTime()        --> tijd wanneer de assignment uitgevoerd moet worden, zal niet starten voor deze tijd
    metaData.location      = metaData.location      or nil                              --> nil-waarde voor locatie geeft aan dat locatie geen rol speelt bij de selectie
    metaData.needTool      = metaData.needTool      or false                            --> needTool geeft aan dat de turtle zelf voor een tool moet zorgen
    metaData.needTurtle    = metaData.needTurtle    or true
    metaData.fuelNeeded    = metaData.fuelNeeded    or 500                              --> minimum amount of fuel needed to grant assignment
    metaData.itemsNeeded   = metaData.itemsNeeded   or {}                               --> items needed in inventory to grant assignment
    if type(taskArgumentTable) ~= "table" then coreutils.Error("coreassignment.AddAssignment: taskArgumentTable not a table") return end
    if type(taskFunction) ~= "string" then
        coreutils.Error("coreassignment.AddAssignment: taskFunction not a string") return
    else
        -- ToDo: investigate if there is a way to check if the actual function exists and has the proper argument without actually calling it
    end
    if type(callbackFunction) ~= "string" then
        coreutils.Error("coreassignment.AddAssignment: callbackFunction not a string") return
    else                                                                                --> callbackFunction should take two arguments:
                                                                                        -->   callbackArgumentTable (the extra information to the callback function)
         if type(callbackArgumentTable) ~= "table" then coreutils.Error("coreassignment.AddAssignment: callbackArgumentTable not a table") return end
                                                                                        -->   taskResult            (the result of the function taskFunction)
        -- ToDo: investigate if there is a way to check if the actual function exists and has the proper arguments without actually calling it
    end

    -- create assignmentId
    local assignmentId  = coreutils.NewId()

    -- store assignment
    coredht.SaveData({
        assignmentId            = assignmentId,
        status                  = "open",
        applications            = {},

        metaData                = metaData,
        taskFunction            = taskFunction,
        taskArgumentTable       = taskArgumentTable,
        callbackFunction        = callbackFunction,
        callbackArgumentTable   = callbackArgumentTable,
    }, db.dhtRoot, db.listRoot, assignmentId)
end

-- coreassignment.Dummy_Callback
function Dummy_Callback(emptyTable)
    -- do nothing
end

function Run()
    -- is the dth available?
    while not coredht.IsReady() do

        -- just wait
        os.sleep(0.25)
    end

    -- infinite loop
    while core.IsSystemRunning() and not db.rejectAllAssignments do

        -- we zijn nu werkeloos
        local nextAssignment = nil

        -- look for best next assignment
        local assignmentApplication = FindBestAssignment()

        -- did we find one?
        if assignmentApplication then
            -- apply
            ApplyToAssignment(assignmentApplication)

            -- wait, maybe more turtles have applied
            os.sleep(1.25)

            -- check who gets the assignment
            nextAssignment = AssignmentSelectionProcedure(assignmentApplication)
        end

        -- did we get the assignment?
        if nextAssignment then
            DoAssignment(nextAssignment)
        else os.sleep(0.25)     -- bapparently no assignment now
        end
    end
end

function RejectAllAssignments()
    -- just remember for now, nothing else
    db.rejectAllAssignments = true
end

function ClearAssignmentList()
    local assignmentList = coredht.GetData(db.dhtRoot, db.listRoot)
    if not assignmentList or type(assignmentList) ~= "table" then coreutils.Warning("coreassignment.ClearAssignmentList: not a (valid) assignmentList") return nil end

    -- remove all assignments
    for assignmentId, assignmentData in pairs(assignmentList) do
        -- check status and startTime
        EndAssignment(assignmentId)
    end
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/


function DHTReadySetup()
    -- bestaat de entry al in de dht?
    if not coredht.GetData(db.dhtRoot)              then coredht.SaveData({}, db.dhtRoot ) end
    if not coredht.GetData(db.dhtRoot, db.listRoot) then coredht.SaveData({}, db.dhtRoot, db.listRoot ) end
end

function FindBestAssignment()
--    coreutils.WriteToLog("Running FindBestVacancy")

    -- zoeken naar een assignment om op in te schrijven
    local assignmentList = coredht.GetData(db.dhtRoot, db.listRoot)

    -- check assignmentList
    if not assignmentList or type(assignmentList) ~= "table" then coreutils.Error("coreassignment.FindBestAssignment: invalid assignmentList") return nil end

    -- look for best assignment
    for assignmentId, assignmentData in pairs(assignmentList) do
        -- check assignment open
        if assignmentData.status == "open" then
            -- check metaconditions
            if MetaDataConditionsMet(assignmentData.metaData) then
                return assignmentId
            else
                -- ToDo: remember reason to skip for debugging purposes
            end
        end
    end

    -- nothing found
    return nil
end

function MetaDataConditionsMet(metaData)
    -- check startTime
    local now            = coreutils.UniversalTime()
    if metaData.startTime > now then
--        coreutils.WriteToLog("coreassignment.MetaDataConditionsMet: Assignment in the future (="..metaData.startTime..") (now ="..now..") => skipped")
        return false
    end

    -- check optional turtle conditions
    if metaData.needTurtle then
        -- check mandatory turtle 
        if not turtle then
            coreutils.WriteToLog("coreassignment.MetaDataConditionsMet: Mandatory turtle not present => skipped")
            return false
        end

        -- check enough fuel for assignment (including traveling there from current location)
        local fuelNeeded = metaData.fuelNeeded -- ToDo include fuel needed to travel to the metaData.location
        if fuelNeeded > 0 then
            local fuelLevel = turtle.getFuelLevel()
            if fuelLevel < fuelNeeded then
                coreutils.WriteToLog("coreassignment.MetaDataConditionsMet: Not enough(="..fuelNeeded..") fuel present(="..fuelLevel..") => skipped")
                return false
            end
        end

        -- check need pickaxe
        if metaData.needTool then
            -- check mandatory pickaxe
            local axePresent = coreinventory.Equip("minecraft:diamond_pickaxe")
            if not axePresent then
                coreutils.WriteToLog("coreassignment.MetaDataConditionsMet: Mandatory pickaxe not present => skipped")
                return false
            end
        end

        -- check items in inventory
        for i, item in ipairs(metaData.itemsNeeded) do
            -- get items in inventory
            local items = coreinventory.CountItem(item.itemName)

            -- enough?
            if items < item.itemCount then
                coreutils.WriteToLog("coreassignment.MetaDataConditionsMet: Not enough(="..item.itemCount..") "..item.itemName.." (="..items..") in inventory for assignment => skipped")
                return false
            end
        end
    end

    return true
end

function ApplyToAssignment(assignmentId)
--    coreutils.WriteToLog("Running ApplyToassignment")

    -- alleen solliciteren indien de assignment open is
    if coredht.GetData(db.dhtRoot, db.listRoot, assignmentId, "status") == "open" then
        -- wie zijn we?
        local me = os.getComputerID()

        -- onzelf (os.getComputerID()) toevoegen aan de lijst met inschrijvingen
        coredht.SaveData({
            time            = coreutils.UniversalTime(),
            dice            = math.random(),
            applicant       = me,
        }, db.dhtRoot, db.listRoot, assignmentId, "applications", me)
    end
end

function AssignmentSelectionProcedure(assignmentId)
--    coreutils.WriteToLog("Running assignmentSelectionProcedure")

    -- data van de assignment ophalen
    local assignment = coredht.GetData(db.dhtRoot, db.listRoot, assignmentId)

    -- see if this assignment is still open
    if assignment.status == "open" then
        --
        local applications = coredht.GetData(db.dhtRoot, db.listRoot, assignmentId, "applications")

        -- see who got the highest dice
        local highestDiceTurtle = nil
        local highestDiceValue = 0
        for turtleId, applicationData in pairs(applications) do
            if applicationData.dice >= highestDiceValue then
                highestDiceValue = applicationData.dice
                highestDiceTurtle = applicationData.applicant
            end
        end

        -- check if I got the highest dice
        if highestDiceTurtle == os.getComputerID() then
            return assignment
        end
    end

    -- apparently it's not for me
    return nil
end

function DoAssignment(assignment)
    local taskResult = nil

    -- we have taken this assignment!
    TakeAssignment(assignment.assignmentId)

    -- call task function
    local f, err = loadstring("return "..assignment.taskFunction.."("..textutils.serialize(assignment.taskArgumentTable)..")")
    if f then taskResult = f() else coreutils.Error("coreassignment.DoAssignment(): loadstring did not supply a function, error given: "..err) end

    -- call callBack function
    f, err = loadstring(assignment.callbackFunction.."("..textutils.serialize(assignment.callbackArgumentTable)..","..textutils.serialize(taskResult).. ")")
    if f then f() else coreutils.Error("coreassignment.DoAssignment(): loadstring did not supply a function, error given: "..err) end

    -- we have done all for this assignment that we needed to do
    EndAssignment(assignment.assignmentId)
end

function TakeAssignment(assignmentId)
    -- data van de assignment ophalen
    local assignment = coredht.GetData(db.dhtRoot, db.listRoot, assignmentId)

    -- see if this assignment is still open
    if assignment.status == "open" then
        -- mark as staffed
        coredht.SaveData("staffed", db.dhtRoot, db.listRoot, assignmentId, "status")
    end
end

function EndAssignment(assignmentId)
    -- easy
    coredht.SaveData(nil, db.dhtRoot, db.listRoot, assignmentId)
end
