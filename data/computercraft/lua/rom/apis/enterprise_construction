--[[
    The construction enterprise provides services to construct structures in the physical minecraft world.
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function BuildBlueprint_ASrv(buildData, callback, callbackData)
    --[[
        This async public service builds a blueprint as a single assignment/ task.

        Return value:
            nil 

        Async service return value (to callback):
                                        - (table) {success = true} if the pattern was succesfully build

        Parameters:
            buildData                   - (table) data about what to build
                blueprintStartpoint     - (table) top lower left coordinate to start building the blueprint
                blueprint               - (table) blueprint to build
                    layerList           - (table) layer to build
                    escapeSequence      - (table) escapeSequence of blueprint
                materialsHostLocator    - (URL) locating where (i.e. at which ISH) the building materials can be retrieved
            callback                    - (string) name of function to call once the pattern is build
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(buildData) ~= "table" then corelog.Error("enterprise_construction.BuildBlueprint_ASrv: Invalid buildData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local blueprintStartpoint = buildData.blueprintStartpoint
    if type(blueprintStartpoint) ~= "table" then corelog.Error("enterprise_construction.BuildBlueprint_ASrv: Invalid blueprintStartpoint") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local blueprint = buildData.blueprint
    if type(blueprint) ~= "table" then corelog.Error("enterprise_construction.BuildBlueprint_ASrv: Invalid blueprint") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(blueprint.layerList) ~= "table" then corelog.Error("enterprise_construction.BuildBlueprint_ASrv: Invalid layerList") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(buildData.materialsHostLocator) ~= "table" then corelog.Error("enterprise_construction.BuildBlueprint_ASrv: Invalid materialsHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local materialsHostLocator = url.URLClass:new(buildData.materialsHostLocator)
    if type(callback) ~= "string" then corelog.Error("enterprise_construction.BuildBlueprint_ASrv: callback not a string") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- construct assignment metadata
    local taskData = {
        blueprintStartpoint     = blueprintStartpoint,
        blueprint               = blueprint,
    }
    local metaData = role_builder.BuildBlueprint_MetaData(taskData)

    -- check if materials needed
    local materialsNeeded = coreutils.DeepCopy(metaData.itemsNeeded)
    local taskFunctionName = "role_builder.BuildBlueprint_Task"
    if next(materialsNeeded) == nil then
        -- directly add assignment
--        corelog.WriteToLog(">Building (zero materials) blueprint "..textutils.serialise(blueprintStartpoint))
        return coreassignment.AddAssignment(metaData, taskFunctionName, taskData, callback, callbackData)
    end

    -- determine materialsItemsLocator (by update materialsHostLocator with itemsNeeded)
    local materialsItemsLocator = materialsHostLocator
    materialsItemsLocator:setQuery(materialsNeeded)

    -- set local output location
    local materialsLocalHostLocator = enterprise_turtle.GetHostLocator_SSrv({ }).hostLocator

    -- create project service data
    local buildBlueprintProjectDef = {
        steps   = {
            { stepName = "enterprise_isp.ProvideItemsTo_ASrv", async = true, stepDataDef = {
                { keyDef = "itemsLocator"               , valueSource = 0, keyDefSource = "materialsItemsLocator" },
                { keyDef = "storageLocator"             , valueSource = 0, keyDefSource = "materialsLocalHostLocator" },
                { keyDef = "ingredientsSupplierLocator" , valueSource = 0, keyDefSource = "ingredientsSupplierLocator" },
            }},
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"           , valueSource = 0, keyDefSource = "taskFunctionName" },
                { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "metaData" },
                { keyDef = "metaData.needTurtleId"      , valueSource = 1, keyDefSource = "destinationItemsLocator._port" }, -- ToDo: consider if we can avoid accessing url internal _port
                { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "taskData" },
            }},
            { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                { keyDef = "success1"                   , valueSource = 1, keyDefSource = "success" },
                { keyDef = "success2"                   , valueSource = 2, keyDefSource = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                        , valueSource = 3, keyDefSource = "success" },
        }
    }
    local projectData = {
        materialsItemsLocator       = materialsItemsLocator:copy(),
        materialsLocalHostLocator   = materialsLocalHostLocator:copy(),
        ingredientsSupplierLocator  = materialsHostLocator:copy(),

        taskFunctionName            = taskFunctionName,
        metaData                    = metaData,
        taskData                    = taskData,
    }
    local projectServiceData = {
        projectDef  = buildBlueprintProjectDef,
        projectData = projectData,
    }

    -- start project
--    corelog.WriteToLog(">Building blueprint at "..textutils.serialise(blueprintStartpoint))
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function BuildRectangularPattern_ASrv(buildData, callback, callbackData)
    --[[
        This async public service builds a rectangular pattern in the x,y plane as a single assignment/ task.

        Return value:
            nil 

        Async service return value (to callback):
                                        - (table) {success = true} if the pattern was succesfully build

        Parameters:
            buildData                   - (table) data about what to build
                startpoint              - (table) lower left coordinate to start building the pattern
                buildFromAbove          - (boolean) whether build should be done from above (true) or below (false)
                replacePresentObjects   - (boolean) whether objects should be replaced if it is already present in the minecraft world (default = false)
                pattern                 - (table) pattern to build
                    deltaX              - (number) x size of pattern
                    deltaY              - (number) size of pattern
                    objectList          - (table) array of objects to build, with for each object
                        x               - (number) x coordinate within the pattern
                        y               - (number) y coordinate within the pattern
                        block           - (string) minecraft blocktype to build (e.g. "minecraft:torch")
                    clearRemainingSpace - (boolean) whether space not in the objectlist should be cleared
                materialsHostLocator    - (URL) locating where (i.e. at which ISH) the building materials can be retrieved
            callback                    - (string) name of function to call once the pattern is build
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(buildData) ~= "table" then corelog.Error("enterprise_construction.BuildRectangularPattern_ASrv: Invalid buildData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local startpoint = buildData.startpoint
    if type(startpoint) ~= "table" then corelog.Error("enterprise_construction.BuildRectangularPattern_ASrv: Invalid startpoint") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local buildFromAbove = buildData.buildFromAbove
    if type(buildFromAbove) ~= "boolean" then corelog.Error("enterprise_construction.BuildRectangularPattern_ASrv: Invalid buildFromAbove") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local replacePresentObjects = buildData.replacePresentObjects
    local pattern = buildData.pattern
    if type(pattern) ~= "table" then corelog.Error("enterprise_construction.BuildRectangularPattern_ASrv: Invalid pattern") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(buildData.materialsHostLocator) ~= "table" then corelog.Error("enterprise_construction.BuildRectangularPattern_ASrv: Invalid materialsHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local materialsHostLocator = url.URLClass:new(buildData.materialsHostLocator)
    if type(callback) ~= "string" then corelog.Error("enterprise_construction.BuildRectangularPattern_ASrv: Invalid callback") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- get assignment metadata
    local taskData = {
        startpoint              = startpoint,
        buildFromAbove          = buildFromAbove,
        replacePresentObjects   = replacePresentObjects,
        pattern                 = pattern,
    }
    local metaData = role_builder.BuildRectangularPattern_MetaData(taskData)

    -- check if materials needed
    local materialsNeeded = coreutils.DeepCopy(metaData.itemsNeeded)
    local taskFunctionName = "role_builder.BuildRectangularPattern_Task"
    if next(materialsNeeded) == nil then
        -- directly add assignment
--        corelog.WriteToLog(">Building (zero materials) pattern at "..textutils.serialise(startpoint))
        return coreassignment.AddAssignment(metaData, taskFunctionName, taskData, callback, callbackData)
    end

    -- determine materialsItemsLocator (by update materialsHostLocator with itemsNeeded)
    local materialsItemsLocator = materialsHostLocator
    materialsItemsLocator:setQuery(materialsNeeded)

    -- set local output location
    -- note:    Because BuildRectangularPattern_Task requires a turtle to have the goods in it's inventory at this point specify that a turtle 
    --          should pick up the materials. We however do not yet specify which turtle as we leave it up to the (relayed services of) 
    --          the TransferItemsFromTo_ASrv service to find that out. Because of below statement the resulting destinationItemsLocator return value 
    --          of that service should specify which turtle has the items in it's inventory.
    local materialsLocalHostLocator = enterprise_turtle.GetHostLocator_SSrv({ }).hostLocator

    -- create project service data
    local buildRectangularPatternProjectDef = {
        steps   = {
            { stepName = "enterprise_isp.ProvideItemsTo_ASrv", async = true, stepDataDef = {
                { keyDef = "itemsLocator"               , valueSource = 0, keyDefSource = "materialsItemsLocator" },
                { keyDef = "storageLocator"             , valueSource = 0, keyDefSource = "materialsLocalHostLocator" },
                { keyDef = "ingredientsSupplierLocator" , valueSource = 0, keyDefSource = "ingredientsSupplierLocator" },
            }},
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"           , valueSource = 0, keyDefSource = "taskFunctionName" },
                { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "metaData" },
                { keyDef = "metaData.needTurtleId"      , valueSource = 1, keyDefSource = "destinationItemsLocator._port" }, -- ToDo: consider if we can avoid accessing url internal _port
                { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "taskData" },
            }},
            { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                { keyDef = "success1"                   , valueSource = 1, keyDefSource = "success" },
                { keyDef = "success2"                   , valueSource = 2, keyDefSource = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                        , valueSource = 3, keyDefSource = "success" },
        }
    }
    local projectData = {
        materialsItemsLocator       = materialsItemsLocator:copy(),
        materialsLocalHostLocator   = materialsLocalHostLocator:copy(),
        ingredientsSupplierLocator  = materialsHostLocator:copy(),

        taskFunctionName            = taskFunctionName,
        metaData                    = metaData,
        taskData                    = taskData,
    }
    local projectServiceData = {
        projectDef  = buildRectangularPatternProjectDef,
        projectData = projectData,
    }

    -- start project
--    corelog.WriteToLog(">Building pattern at "..textutils.serialise(startpoint))
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

