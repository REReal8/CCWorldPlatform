--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function PlantFirstSapling_MetaData(taskData)
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(taskData.startLocation),
        needTool = false,
        needTurtle = true,
        fuelNeeded = 0,                         --> per definition the settler starts without fuel
        itemsNeeded = {
            ["minecraft:birch_sapling"] = 1,
        }
    }
end

function PlantFirstSapling_Task(taskData)
     --[[
        This Task function does the first settling step: it plants the first sappling.

        Return value:
            task result                 - (table)      
                success                 - (boolean) whether the task was succesfull
                turtleId                - (number) id of turtle that planted the sappling

        Parameters:
            taskData                    - (table) data about the task
                startLocation           - (table) locaton where first steps are to be taken
    ]]

    -- check input
    if type(taskData) ~= "table" or type(taskData.startLocation) ~= "table" then corelog.Error("role_settler.PrimarySettle_Task: taskData not valid") return {success = false} end

    -- coordinaten stelsel goed zetten
    local startLocation = taskData.startLocation
    coremove.SetLocation(startLocation)

    -- plant the sappling
    corelog.WriteToLog(">Planting first sapling")
    coreinventory.SelectItem("minecraft:birch_sapling")
    turtle.place()

    -- end
    local currentTurtleId = os.getComputerID()
    return {success = true, turtleId = currentTurtleId}
end

function WaitFirstTree_MetaData(taskData)
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(taskData.startLocation),
        needTool = true,
        needTurtle = true,
        fuelNeeded = 0,                         --> per definition still no fuel
        itemsNeeded = {
        }
    }
end

function WaitFirstTree_Task(taskData)
    --[[
        This Task function waits for the first tree to complete and chops one block in front.

        Return value:
            task result                 - (table)      
                success                 - (boolean) whether the task was succesfull

        Parameters:
            taskData                    - (table) data about the task
                startLocation           - (table) location where first steps are to be taken
    ]]
    -- equip pickage
    coreinventory.Equip("minecraft:diamond_pickaxe")

    -- wait for a tree
    corelog.WriteToLog(">Waiting for first tree")
    WaitForTree()

    -- blok voor ons omhakken
    corelog.WriteToLog(">Chopping one block of first tree")
    turtle.dig()

    return {success = true}
end

function ChopFirstTree_MetaData(taskData)
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(taskData.startLocation),
        needTool = true,
        needTurtle = true,
        fuelNeeded = 0, --> per definition still no fuel (as the task fuels from first chopped log (already converted to planks))
        itemsNeeded = {},
    }
end

function ChopFirstTree_Task(taskData)
    --[[
        This Task function chops (the remainder of) the first tree.

        Return value:
            task result                 - (table)      
                success                 - (boolean) whether the task was succesfull
                orderForFuel            - (table) items to order for refuel

        Parameters:
            taskData                    - (table) data about the task
    ]]
    -- check input
    if type(taskData) ~= "table" then corelog.Error("role_settler.ChopFirstTree_Task: Invalid taskData") return {success = false} end

    -- rest van de boom omhakken
    corelog.WriteToLog(">Chopping rest of first tree")
    coreinventory.Equip("minecraft:diamond_pickaxe")
    coremove.Up(1)
    role_forester.KapBoom()

    -- rest van de planken als brandstof gebruiken, kisten maken we laten (waarschijnlijk beter om eerst fakkeltje te maken trouwens, wellicht later)
    local logs = coreinventory.CountItem("minecraft:birch_log")
    local orderForFuel = { ["minecraft:birch_planks"] = (logs - 2)*4 }

    -- end
    return {success = true, orderForFuel = orderForFuel}
end

function ReportStatus_MetaData(taskData)
    return {
        startTime = coreutils.UniversalTime(),
        location = nil,
        needTool = false,
        needTurtle = true,
        fuelNeeded = 0,
        itemsNeeded = {
        }
    }
end

function ReportStatus_Task(taskData)
    --[[
        This Task function reports the status of the turtle settling.

        Return value:
            task result                 - (table)      
                success                 - (boolean) whether the task was succesfull

        Parameters:
            taskData                    - (table) data about the task
    ]]

    -- we are ready to do more stuff!
    corelog.WriteToLog("We have "..coreinventory.CountItem("minecraft:birch_sapling").." birch sapling(s)")
    corelog.WriteToLog("We have "..turtle.getFuelLevel().." fuel")

    -- end
    return {success = true}
end

function CollectCobbleStone_MetaData(taskData)
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(taskData.startLocation),
        needTool = true,
        needTurtle = true,
        fuelNeeded = 100, -- ToDo: how much is needed for this step?
        itemsNeeded = {
        }
    }
end

function CollectCobbleStone_Task(taskData)
    -- check input
    local startLocation = taskData.startLocation

    -- get into digging position
    corelog.WriteToLog (">Collecting cobblestone")
    coreinventory.Equip("minecraft:diamond_pickaxe")
    turtle.digDown()
    coremove.Down()

    -- dig a hole, get cobblestone
    local cobblestone = 0
    while cobblestone < 9 do

        -- one layer lower
        turtle.digDown()
        coremove.Down()

        -- go round
        for i=1,4 do turtle.dig() coremove.Right() end

        -- count our cobblestone
        cobblestone = coreinventory.CountItem("minecraft:cobblestone")
    end

    -- restore our crafting spot
    coremove.MoveTo({z = startLocation.z - 1})
    if coreinventory.SelectItem("minecraft:dirt") or coreinventory.SelectItem("minecraft:cobblestone") then turtle.placeDown() end

    -- end
    return {success = true}
end

function CollectLogs_MetaData(taskData)
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(taskData.startLocation),
        needTool = true,
        needTurtle = true,
        fuelNeeded = 100, -- ToDo: how much is needed for this step?
        itemsNeeded = {
            ["minecraft:crafting_table"] = 1,
        }
    }
end

function CollectLogs_Task(taskData)
    -- check input
    local startLocation = taskData.startLocation
    local factoryLocation = taskData.factoryLocation
    local nTrees = taskData.nTrees
    local logsNeeded = taskData.logsNeeded

    -- gather logs
    corelog.WriteToLog(">Collecting " .. logsNeeded .. " logs")
    while coreinventory.CountItem("minecraft:birch_log") < logsNeeded do
        -- Harvest Forest
        local harvestForestData = {
            firstTreeLocation   = startLocation,
            factoryLocation     = factoryLocation,
            nTrees              = nTrees,
        }
        HarvestForest_Task(harvestForestData)
    end

    -- end
    return {success = true}
end

function CollectSaplings_MetaData(taskData)
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(taskData.startLocation),
        needTool = true,
        needTurtle = true,
        fuelNeeded = 100, -- ToDo: how much is needed for this step?
        itemsNeeded = {
            ["minecraft:crafting_table"] = 1,
        }
    }
end

function CollectSaplings_Task(taskData)
    -- check input
    local startLocation = taskData.startLocation
    local factoryLocation = taskData.factoryLocation
    local nTrees = taskData.nTrees
    local saplingsNeeded = taskData.saplingsNeeded

    -- gather saplings
    corelog.WriteToLog(">Collecting " .. saplingsNeeded .. " saplings")
    while coreinventory.CountItem("minecraft:birch_sapling") < saplingsNeeded do
        -- Harvest Forest
        local harvestForestData = {
            firstTreeLocation   = startLocation,
            factoryLocation     = factoryLocation,
            nTrees              = nTrees,
        }
        HarvestForest_Task(harvestForestData)
    end

    -- end
    return {success = true}
end

function HarvestForest_MetaData(taskData)
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(taskData.firstTreeLocation),
        needTool = true,
        needTurtle = true,
        fuelNeeded = 100, -- ToDo: how much is needed for this step?
        itemsNeeded = {
            ["minecraft:crafting_table"] = 1,
        }
    }
end

function HarvestForest_Task(taskData)
    --[[
        This Task function harvests a forest.

        Return value:
            task result                 - (table)      
                success                 - (boolean) whether the task was succesfull

        Parameters:
            taskData                    - (table) data about the task
                firstTreeLocation       - (table) location of first tree of the forest
                factoryLocation         - (table) location of factory
                nTrees                  - (number) the number of trees in (the y direction of) the forest 
    ]]

    -- check input
    local firstTreeLocation = taskData.firstTreeLocation
    local factoryLocation = taskData.factoryLocation
    local nTrees = taskData.nTrees

    corelog.WriteToLog(" Harvesting Forest")

    -- go to first tree position
    coremove.GoTo(firstTreeLocation)

    -- wait for tree
    WaitForTree()

    -- harvest forest
    role_forester.Rondje({
        depth = nTrees,
        width = 2,
        dontCleanup = true,
    })

    -- refuel
    Refuel(factoryLocation)

    -- end
    return {success = true}
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function WaitForTree()
    local has_block, data = turtle.inspect()

    while not has_block or type(data) ~= "table" or data.name ~= "minecraft:birch_log" do
        -- ff wachten
        os.sleep(0.25)

        -- opnieuw kijken
        has_block, data = turtle.inspect()
    end
end

function Refuel(factoryLocation)
    local fuelLevel     = turtle.getFuelLevel()
    local minFuel       = 500
    local refuelLevel   = 1000

    -- do we need to refuel?
    if fuelLevel < minFuel then
        corelog.WriteToLog(" Attempt refueling from " .. fuelLevel .. " to " .. refuelLevel .. ".")
        -- determine present en wanted, process the lowest value of both values
        local logs        = coreinventory.CountItem("minecraft:birch_log")
        local logsNeeded  = math.ceil((refuelLevel - fuelLevel ) / 60)    -- 1 log --> 4 planks, 4 planks have a burn value of 60 (15 each)
        local logsToBurn  = math.min(logs, logsNeeded)

        -- determine crafting location
        local craftingLocation = coremove.GetRelativeLocation(factoryLocation, 3, 3, -4)

        -- logs to planks
        LogToPlanks(craftingLocation, logsToBurn * 4)

        -- burn all the planks just crafted
        local planksPresent   = coreinventory.CountItem("minecraft:birch_planks")
        coreinventory.Refuel({itemName = "minecraft:birch_planks",  itemCount = planksPresent})

        corelog.WriteToLog(" refueled to " .. turtle.getFuelLevel())
    else
        corelog.WriteToLog(" Already above (=" .. fuelLevel .. ") minumum(=" .. minFuel .. ") fuellevel.")
    end
end

function LogToPlanks(craftingLocation, planks)
    -- check input
    local logsNeeded = math.ceil(planks / 4)
    local logs = coreinventory.CountItem("minecraft:birch_log")
    if logs < logsNeeded then corelog.Warning("Not enough logs(=" .. logsNeeded .. ") present(=" .. logs .. ") for planks(=" .. planks .. ")") return false end

    -- craft
    role_alchemist.Craft_Task({
        recipe = {
            [6] = {
                itemName = "minecraft:birch_log",
                itemCount = 1
            },
            yield = 4
        },
        productItemName = "minecraft:birch_planks",
        productItemCount= planks,
        workingLocation = craftingLocation,
    })
end
