local db = {
    forestLocation      = {x= 0, y= 0, z= 1, dx=0, dy=1},
    nTrees = 1,
}

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function PlantFirstSapling_MetaData(settleData)
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(settleData.startLocation),
        needTool = false,
        needTurtle = true,
        fuelNeeded = 0,                         --> per definition the settler starts without fuel
        itemsNeeded = {
            ["minecraft:birch_sapling"] = 1,
        }
    }
end

function PlantFirstSapling_Task(settleData)
     --[[
        This Task function does the first settling step: it plants the first sappling.

        Return value:
            task result                 - (table)      
                success                 - (boolean) whether the task was succesfull

        Parameters:
            settleData                  - (table) data about the task
                startLocation           - (table) locaton where first steps are to be taken
    ]]

    -- check input
    if type(settleData) ~= "table" or type(settleData.startLocation) ~= "table" then corelog.Error("role_settler.PrimarySettle_Task: settleData not valid") return {success = false} end

    -- coordinaten stelsel goed zetten
    local startLocation = settleData.startLocation
    coremove.SetLocation(startLocation)

    -- plant the sappling
    corelog.WriteToLog(">Planting first sapling")
    coreinventory.SelectItem("minecraft:birch_sapling")
    turtle.place()
    db.nTrees = 1

    -- end
    return {success = true}
end

function WaitFirstTree_MetaData(settleData)
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(settleData.startLocation),
        needTool = true,
        needTurtle = true,
        fuelNeeded = 0,                         --> per definition still no fuel
        itemsNeeded = {
        }
    }
end

function WaitFirstTree_Task(settleData)
    --[[
        This Task function waits for the first tree to complete and chops one block in front.

        Return value:
            task result                 - (table)      
                success                 - (boolean) whether the task was succesfull

        Parameters:
            settleData                  - (table) data about the task
                startLocation           - (table) locaton where first steps are to be taken
    ]]
    -- equip pickage
    coreinventory.Equip("minecraft:diamond_pickaxe")

    -- wait for a tree
    corelog.WriteToLog(">Waiting for first tree")
    WaitForTree()

    -- blok voor ons omhakken
    turtle.dig()

    return {success = true}
end

function ChopFirstTree_MetaData(settleData)
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(settleData.startLocation),
        needTool = true,
        needTurtle = true,
        fuelNeeded = 0, --> per definition still no fuel (as the task fuels from first chopped log (already converted to planks))
        itemsNeeded = {
            ["minecraft:birch_planks"] = 4,
        }
    }
end

function ChopFirstTree_Task(settleData)
    --[[
        This Task function chops (the remainder of) the first tree.

        Return value:
            task result                 - (table)      
                success                 - (boolean) whether the task was succesfull
                orderForFuel            - (table) items to order for refuel

        Parameters:
            settleData                  - (table) data about the task
                startLocation           - (table) locaton where first steps are to be taken
    ]]
    -- check input
    if type(settleData) ~= "table" or type(settleData.startLocation) ~= "table" then corelog.Error("role_settler.PrimarySettle_Task: settleData not valid") return {success = false} end
    local startLocation = settleData.startLocation
    corelog.WriteToLog(">Chopping first tree")

    -- nu kunnen we bijtanken
    coreinventory.Refuel({itemName="minecraft:birch_planks", itemCount=4}) -- ToDo: consider splitting off/ making/ using some general fueling mechanism

    -- rest van de boom omhakken
    coreinventory.Equip("minecraft:diamond_pickaxe")
    coremove.Up(1)
    role_forester.KapBoom()

    -- rest van de planken als brandstof gebruiken, kisten maken we laten (waarschijnlijk beter om eerst fakkeltje te maken trouwens, wellicht later)
    local logs      = coreinventory.CountItem("minecraft:birch_log")
    local orderForFuel = { ["minecraft:birch_planks"] = (logs - 2)*4 }

    -- end
    return {success = true, orderForFuel = orderForFuel}
end

function Refuel_MetaData(settleData)
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(settleData.startLocation),
        needTool = false,
        needTurtle = true,
        fuelNeeded = 0,
        itemsNeeded = {
        }
    }
end

function Refuel_Task(settleData)
    --[[
        This Task function uses planks and sticks to fuel the turtle.

        Return value:
            task result                 - (table)      
                success                 - (boolean) whether the task was succesfull

        Parameters:
            settleData                  - (table) data about the task
                startLocation           - (table) locaton where first steps are to be taken
    ]]

    --
    corelog.WriteToLog(">Refueling (2)")
    local planks    = coreinventory.CountItem("minecraft:birch_planks")
    local sticks    = coreinventory.CountItem("minecraft:stick")

    -- burn the planks and the sticks
    coreinventory.Refuel({itemName = "minecraft:birch_planks",  itemCount = planks}) -- last plank might be used als funace fuel
    coreinventory.Refuel({itemName = "minecraft:stick",         itemCount = sticks - 2}) -- crafting torch and furnace fuel

    -- we are ready to do more stuff!
    corelog.WriteToLog("We have "..coreinventory.CountItem("minecraft:birch_sapling").." birch sapling(s)")
    corelog.WriteToLog("We have "..turtle.getFuelLevel().." fuel")

    -- end
    return {success = true}
end

function CollectCobbleStone_MetaData(settleData)
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(settleData.startLocation),
        needTool = true,
        needTurtle = true,
        fuelNeeded = 100, -- ToDo: how much is needed for this step?
        itemsNeeded = {
        }
    }
end

function CollectCobbleStone_Task(settleData)
    -- check input
    local startLocation = settleData.startLocation

    -- get into digging position
    corelog.WriteToLog (">Collecting cobblestone")
    coreinventory.Equip("minecraft:diamond_pickaxe")
    turtle.digDown()
    coremove.Down()

    -- dig a hole, get cobblestone
    local cobblestone = 0
    while cobblestone < 9 do

        -- one layer lower
        turtle.digDown()
        coremove.Down()

        -- go round
        for i=1,4 do turtle.dig() coremove.Right() end

        -- count our cobblestone
        cobblestone = coreinventory.CountItem("minecraft:cobblestone")
    end

    -- restore our crafting spot
    coremove.MoveTo({z = startLocation.z - 1})
    if coreinventory.SelectItem("minecraft:dirt") or coreinventory.SelectItem("minecraft:cobblestone") then turtle.placeDown() end

    -- end
    return {success = true}
end

function ExtendForest_MetaData(settleData)
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(settleData.startLocation),
        needTool = true,
        needTurtle = true,
        fuelNeeded = 100, -- ToDo: how much is needed for this step?
        itemsNeeded = {
            ["minecraft:crafting_table"] = 1,
        }
    }
end

function ExtendForest_Task(settleData)
    -- check input
    local startLocation = settleData.startLocation
    local factoryLocation = settleData.factoryLocation
    local treesNeeded = settleData.treesNeeded
    local craftingLocation = coremove.GetRelativeLocation(factoryLocation, 3, 3, -4)

    -- expand forest to max size
    corelog.WriteToLog(">Extending forest to " .. treesNeeded .. " trees")
    while db.nTrees < treesNeeded do
        -- Harvest Forest
        HarvestForest(craftingLocation, startLocation)

        -- try extend forest
        TryExtendForest(factoryLocation, craftingLocation, treesNeeded)
    end

    -- end
    return {success = true}
end

function CollectLogs_MetaData(settleData)
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(settleData.startLocation),
        needTool = true,
        needTurtle = true,
        fuelNeeded = 100, -- ToDo: how much is needed for this step?
        itemsNeeded = {
            ["minecraft:crafting_table"] = 1,
        }
    }
end

function CollectLogs_Task(settleData)
    -- check input
    local startLocation = settleData.startLocation
    local factoryLocation = settleData.factoryLocation
    local logsNeeded = settleData.logsNeeded

    local craftingLocation = coremove.GetRelativeLocation(factoryLocation, 3, 3, -4)

    -- gather logs
    corelog.WriteToLog(">Collecting " .. logsNeeded .. " logs")
    while coreinventory.CountItem("minecraft:birch_log") < logsNeeded do
        -- Harvest Forest
        HarvestForest(craftingLocation, startLocation)
    end

    -- end
    return {success = true}
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function HarvestForest(craftingLocation, startLocation)
    corelog.WriteToLog(" Harvesting Forest")

    -- go to first tree position
    coremove.GoTo(startLocation)

    -- wait for tree
    WaitForTree()

    -- harvest forest
    role_forester.Rondje({
        depth = db.nTrees,
        width = 2,
        dontCleanup = true,
    })

    -- refuel
    Refuel(craftingLocation)
end

function WaitForTree()
    local has_block, data = turtle.inspect()

    while not has_block or type(data) ~= "table" or data.name ~= "minecraft:birch_log" do
        -- ff wachten
        os.sleep(0.25)

        -- opnieuw kijken
        has_block, data = turtle.inspect()
    end
end

function Refuel(craftingLocation)
    local fuelLevel     = turtle.getFuelLevel()
    local minFuel       = 500
    local refuelLevel   = 1000


    -- do we need to refuel?
    if fuelLevel < minFuel then
        corelog.WriteToLog(" Attempt refueling from " .. fuelLevel .. " to " .. refuelLevel .. ".")
        -- determine present en wanted, process the lowest value of both values
        local logs        = coreinventory.CountItem("minecraft:birch_log")
        local logsNeeded  = math.ceil((refuelLevel - fuelLevel ) / 60)    -- 1 log --> 4 planks, 4 planks have a burn value of 60 (15 each)
        local logsToBurn  = math.min(logs, logsNeeded)

        -- logs to planks
        LogToPlanks(craftingLocation, logsToBurn * 4)

        -- burn all the planks just crafted
        local planksPresent   = coreinventory.CountItem("minecraft:birch_planks")
        coreinventory.Refuel({itemName = "minecraft:birch_planks",  itemCount = planksPresent})

        corelog.WriteToLog(" refueled to " .. turtle.getFuelLevel())
    else
        corelog.WriteToLog(" Already above (=" .. fuelLevel .. ") minumum(=" .. minFuel .. ") fuellevel.")
    end
end

function LogToPlanks(craftingLocation, planks)
    -- check input
    local logsNeeded = math.ceil(planks / 4)
    local logs = coreinventory.CountItem("minecraft:birch_log")
    if logs < logsNeeded then corelog.Warning("Not enough logs(=" .. logsNeeded .. ") present(=" .. logs .. ") for planks(=" .. planks .. ")") return false end

    -- craft
    role_alchemist.Craft_Task({
        recipe = {
            [6] = {
                itemName = "minecraft:birch_log",
                itemCount = 1
            },
            yield = 4
        },
        productItemName = "minecraft:birch_planks",
        productItemCount= planks,
        workingLocation = craftingLocation,
    })
end

function PlanksToStick(craftingLocation, sticks)
    -- check input
    local planksNeeded = math.ceil(sticks / 2)
    local planks = coreinventory.CountItem("minecraft:birch_planks")
    if planks < planksNeeded then corelog.Warning("Not enough planks(=" .. planksNeeded .. ") present(=" .. planks .. ") for sticks(=" .. sticks .. ")") return false end

    -- craft
    role_alchemist.Craft_Task({
        recipe = {
            [6] = {
                itemName = "minecraft:birch_planks",
                itemCount = 1
            },
            [10] = {
                itemName = "minecraft:birch_planks",
                itemCount = 1
            },
            yield = 4
        },
        productItemName = "minecraft:stick",
        productItemCount= sticks,
        workingLocation = craftingLocation,
    })
end

function LogToTorches(factoryLocation, craftingLocation, torches)
    -- check input
    local sticksNeeded = math.ceil(torches / 4)
    local charcoalNeeded = math.ceil(torches / 4)
    local planksNeeded = math.ceil(charcoalNeeded + sticksNeeded / 4);
    local logsNeeded = math.ceil(planksNeeded / 4)
    local logs = coreinventory.CountItem("minecraft:birch_log")
    if logs < logsNeeded then corelog.Warning("Not enough logs(=" .. logsNeeded .. ") present(=" .. logs .. ") for torches(=" .. torches .. ")") return false end

    -- create planks (as fuel)
    LogToPlanks(craftingLocation, planksNeeded)

    -- create sticks
    PlanksToStick(craftingLocation, sticksNeeded)

    -- smelt log into charcoal
    LogToCharcoal(factoryLocation, charcoalNeeded)

    -- craft torches
    CharcoalAndStickToTorch(craftingLocation, torches)
end

function LogToCharcoal(factoryLocation, charcoals)
    --? put this static somewhere?
    local plankName = "minecraft:birch_planks"

    -- check input
    local logsNeeded = charcoals
    local logs = coreinventory.CountItem("minecraft:birch_log")
    if (logs < logsNeeded) then corelog.Warning("Not enough logs(=" .. logsNeeded .. ") present(=" .. logs .. ") for charcoal(=" .. charcoals .. ")") return false end
    local planksNeeded = math.ceil(2 * charcoals / 3)
    local planks = coreinventory.CountItem(plankName)
    if (logs < logsNeeded) then corelog.Warning("Not enough plank(=" .. planksNeeded .. ") fuel present(=" .. planks .. ") for charcoal(=" .. charcoals .. ")") return false end

    role_alchemist.Smelt_Task({
        recipe  = {
            itemName = "minecraft:birch_log",
            yield = 1,
        },
        fuelItemName    = "minecraft:birch_planks",
        fuelItemCount   = charcoals,
        productItemName = "minecraft:charcoal",
        productItemCount= charcoals,
        workingLocation = coremove.GetRelativeLocation(factoryLocation, 3, 3, -3),
    })

    -- wait for the furnace
    os.sleep(10)

    -- get items from the furnace
    role_alchemist.Pickup_Task({
        productItemName = "minecraft:charcoal",
        productItemCount= charcoals,
        workingLocation = coremove.GetRelativeLocation(factoryLocation, 3, 3, -3),
    })
end

function CharcoalAndStickToTorch(craftingLocation, torches)
    role_alchemist.Craft_Task({
        recipe = {
            [6] = {
                itemName = "minecraft:charcoal",
                itemCount = 1
            },
            [10] = {
                itemName = "minecraft:stick",
                itemCount = 1
            },
            yield = 4
        },
        productItemName = "minecraft:torch",
        productItemCount= torches,
        workingLocation = craftingLocation,
    })
end

--    _           _ _     _    __                  _   _
--   | |         (_) |   | |  / _|                | | (_)
--   | |__  _   _ _| | __| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | | |/ _` | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | | | (_| | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_.__/ \__,_|_|_|\__,_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--
--

function TryExtendForest(factoryLocation, craftingLocation, nTrees)
    corelog.WriteToLog(" Try extending forest from " .. db.nTrees .. " to " .. nTrees .. " trees")

    -- craft torches
    LogToTorches(factoryLocation, craftingLocation, 4)

    while db.nTrees < nTrees do
        -- check input (sapling + 2x torch)
        local birchSaplings  = coreinventory.CountItem("minecraft:birch_sapling")
        local torches  = coreinventory.CountItem("minecraft:torch")

        -- stop if we don't meet the needs
        if birchSaplings < 1 or torches < 2 then
            return false
        end

        -- new tree
        BuildForestTreePattern(0, 6 * db.nTrees, 0)
        db.nTrees = db.nTrees + 1
    end

    return true
end

function BuildForestTreePattern(x, y, z)
    local point = coremove.GetRelativeLocation(db.forestLocation, x, y, z)

    role_builder.BuildRectangularPattern_Task({startpoint = point, buildFromAbove = true, replacePresentObjects = false, pattern = enterprise_forest.tree_pattern})
end


