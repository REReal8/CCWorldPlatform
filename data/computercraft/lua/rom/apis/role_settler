--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function PlantFirstSapling_MetaData(taskData)
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(taskData.startLocation),
        needTool = false,
        needTurtle = true,
        fuelNeeded = 0,                         --> per definition the settler starts without fuel
        itemsNeeded = {
            ["minecraft:birch_sapling"] = 1,
        }
    }
end

function PlantFirstSapling_Task(taskData)
     --[[
        This Task function does the first settling step: it plants the first sappling.

        Return value:
            task result                 - (table)      
                success                 - (boolean) whether the task was succesfull
                turtleId                - (number) id of turtle that planted the sappling

        Parameters:
            taskData                    - (table) data about the task
                startLocation           - (table) locaton where first steps are to be taken
    ]]

    -- check input
    if type(taskData) ~= "table" or type(taskData.startLocation) ~= "table" then corelog.Error("role_settler.PrimarySettle_Task: taskData not valid") return {success = false} end

    -- coordinaten stelsel goed zetten
    local startLocation = taskData.startLocation
    coremove.SetLocation(startLocation)

    -- plant the sappling
    corelog.WriteToLog(">Planting first sapling")
    coreinventory.SelectItem("minecraft:birch_sapling")
    turtle.place()

    -- end
    local currentTurtleId = os.getComputerID()
    return {success = true, turtleId = currentTurtleId}
end

function WaitFirstTree_MetaData(taskData)
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(taskData.startLocation),
        needTool = true,
        needTurtle = true,
        fuelNeeded = 0,                         --> per definition still no fuel
        itemsNeeded = {
        }
    }
end

function WaitFirstTree_Task(taskData)
    --[[
        This Task function waits for the first tree to complete and chops one block in front.

        Return value:
            task result                 - (table)      
                success                 - (boolean) whether the task was succesfull

        Parameters:
            taskData                    - (table) data about the task
                startLocation           - (table) location where first steps are to be taken
    ]]
    -- equip pickage
    coreinventory.Equip("minecraft:diamond_pickaxe")

    -- wait for a tree
    corelog.WriteToLog(">Waiting for first tree")
    WaitForTree()

    -- blok voor ons omhakken
    corelog.WriteToLog(">Chopping one block of first tree")
    turtle.dig()

    return {success = true}
end

local fuelNeededPerTree = 35 + 1

function ChopFirstTree_MetaData(taskData)
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(taskData.startLocation),
        needTool = true,
        needTurtle = true,
        fuelNeeded = fuelNeededPerTree,
        itemsNeeded = {},
    }
end

function ChopFirstTree_Task(taskData)
    --[[
        This Task function chops (the remainder of) the first tree.

        Return value:
            task result                 - (table)      
                success                 - (boolean) whether the task was succesfull
                orderForFuel            - (table) items to order for refuel

        Parameters:
            taskData                    - (table) data about the task
    ]]
    -- check input
    if type(taskData) ~= "table" then corelog.Error("role_settler.ChopFirstTree_Task: Invalid taskData") return {success = false} end

    -- rest van de boom omhakken
    corelog.WriteToLog(">Chopping rest of first tree")
    coreinventory.Equip("minecraft:diamond_pickaxe")
    coremove.Up(1)
    role_forester.KapBoom()

    -- rest van de planken als brandstof gebruiken, kisten maken we laten (waarschijnlijk beter om eerst fakkeltje te maken trouwens, wellicht later)
    local logs = coreinventory.CountItem("minecraft:birch_log")
    local orderForFuel = { ["minecraft:birch_planks"] = (logs - 2)*4 }

    -- end
    return {success = true, orderForFuel = orderForFuel}
end

function ReportStatus_MetaData(taskData)
    return {
        startTime = coreutils.UniversalTime(),
        location = nil,
        needTool = false,
        needTurtle = true,
        fuelNeeded = 0,
        itemsNeeded = {
        }
    }
end

function ReportStatus_Task(taskData)
    --[[
        This Task function reports the status of the turtle settling.

        Return value:
            task result                 - (table)      
                success                 - (boolean) whether the task was succesfull

        Parameters:
            taskData                    - (table) data about the task
    ]]

    -- we are ready to do more stuff!
    corelog.WriteToLog("We have "..coreinventory.CountItem("minecraft:birch_sapling").." birch sapling(s)")
    corelog.WriteToLog("We have "..turtle.getFuelLevel().." fuel")

    -- end
    return {success = true}
end

function CollectCobbleStone_MetaData(taskData)
    return {
        startTime = coreutils.UniversalTime(),
        location = coremove.CopyLocation(taskData.startLocation),
        needTool = true,
        needTurtle = true,
        fuelNeeded = 100, -- ToDo: how much is needed for this step?
        itemsNeeded = {
        }
    }
end

function CollectCobbleStone_Task(taskData)
    -- check input
    if type(taskData) ~= "table" then corelog.Error("role_settler.CollectCobbleStone_Task: Invalid taskData") return {success = false} end
    local startLocation = taskData.startLocation
    if type(startLocation) ~= "table" then corelog.Error("role_settler.CollectCobbleStone_Task: Invalid startLocation") return {success = false} end

    -- move to the workingLocation
    coremove.GoTo(startLocation)

    -- get into digging position
    corelog.WriteToLog (">Collecting cobblestone")
    coreinventory.Equip("minecraft:diamond_pickaxe")
    turtle.digDown()
    coremove.Down()

    -- dig a hole, get cobblestone
    local cobblestone = 0
    while cobblestone < 9 do

        -- one layer lower
        turtle.digDown()
        coremove.Down()

        -- go round
        for i=1,4 do turtle.dig() coremove.Right() end

        -- count our cobblestone
        cobblestone = coreinventory.CountItem("minecraft:cobblestone")
    end

    -- restore our crafting spot
    coremove.MoveTo({z = startLocation.z - 1})
    if coreinventory.SelectItem("minecraft:dirt") or coreinventory.SelectItem("minecraft:cobblestone") then turtle.placeDown() end

    -- end
    return {success = true}
end

function FuelNeededPerRound(nTrees)
    local fuelNeededBetweenTrees = 6

    return nTrees*fuelNeededPerTree + 2 * (nTrees - 1) * fuelNeededBetweenTrees
end

function HarvestForest_MetaData(taskData)
    -- check input
    if type(taskData) ~= "table" then corelog.Error("role_settler.HarvestForest_MetaData: Invalid taskData") return {success = false} end
    local firstTreeLocation = taskData.firstTreeLocation
    if type(firstTreeLocation) ~= "table" then corelog.Error("role_settler.HarvestForest_MetaData: Invalid firstTreeLocation") return {success = false} end
    local nTrees = taskData.nTrees
    if type(nTrees) ~= "number" then corelog.Error("role_settler.HarvestForest_MetaData: Invalid nTrees") return {success = false} end
    local priorityKey = taskData.priorityKey
    if priorityKey and type(priorityKey) ~= "string" then corelog.Error("role_settler.HarvestForest_MetaData: Invalid priorityKey") return {success = false} end

    return {
        startTime   = coreutils.UniversalTime(),
        location    = coremove.CopyLocation(firstTreeLocation),
        needTool    = true,
        needTurtle  = true,
        fuelNeeded  = FuelNeededPerRound(nTrees),
        itemsNeeded = {
            ["minecraft:crafting_table"] = 1,
        },

        priorityKey = priorityKey,
    }
end

function HarvestForest_Task(taskData)
    --[[
        This Task function harvests a forest.

        Return value:
            task result                 - (table)      
                success                 - (boolean) whether the task was succesfull

        Parameters:
            taskData                    - (table) data about the task
                firstTreeLocation       - (table) location of first tree of the forest
                nTrees                  - (number) the number of trees in (the y direction of) the forest 
    ]]

    -- check input
    if type(taskData) ~= "table" then corelog.Error("role_settler.HarvestForest_Task: Invalid taskData") return {success = false} end
    local firstTreeLocation = taskData.firstTreeLocation
    if type(firstTreeLocation) ~= "table" then corelog.Error("role_settler.HarvestForest_Task: Invalid firstTreeLocation") return {success = false} end
    local nTrees = taskData.nTrees
    if type(nTrees) ~= "number" then corelog.Error("role_settler.HarvestForest_Task: Invalid nTrees") return {success = false} end

    corelog.WriteToLog(" Harvesting Forest")

    -- go to first tree position
    coremove.GoTo(firstTreeLocation)

    -- wait for tree
    WaitForTree()

    -- harvest forest
    role_forester.Rondje({
        depth = nTrees,
        width = 2,
        dontCleanup = true,
    })

    -- end
    return {success = true}
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function WaitForTree()
    local has_block, data = turtle.inspect()

    while not has_block or type(data) ~= "table" or data.name ~= "minecraft:birch_log" do
        -- ff wachten
        os.sleep(0.25)

        -- opnieuw kijken
        has_block, data = turtle.inspect()
    end
end
