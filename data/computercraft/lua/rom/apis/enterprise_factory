local db = {
    dhtRoot     = "enterprise_factory",
    dhtSites    = "sites",

    -- turtle slots
    -- [ 1] [ 2] [ 3] [ 4]
    -- [ 5] [ 6] [ 7] [ 8]
    -- [ 9] [10] [11] [12]
    -- [13] [14] [15] [16]
    recipes        = {
        ["minecraft:stick"] = {
            crafting  = {
                  [6]    = { itemName = "minecraft:birch_planks",   itemCount = 1 },
                 [10]    = { itemName = "minecraft:birch_planks",   itemCount = 1 },
                yield   = 4
            },
        },
        ["minecraft:charcoal"] = { -- ToDo consider similar format to crafting to simpify code
            smelting  = {
                itemName    = "minecraft:birch_log",
--                itemCount   = 1,
                yield       = 1,
            },
        },
        ["minecraft:torch"] = {
            crafting  = {
                 [6]    = { itemName = "minecraft:charcoal",        itemCount = 1 },
                [10]    = { itemName = "minecraft:stick",           itemCount = 1 },
               yield   = 4
           },
        },
        ["minecraft:birch_planks"] = {
            crafting  = {
                 [6]    = { itemName = "minecraft:birch_log",       itemCount = 1 },
                yield   = 4
            },
        },
        ["minecraft:chest"] = {
            crafting  = {
                 [6]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                 [7]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                 [8]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [10]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [12]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [14]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [15]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [16]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                yield   = 1
            },
        },
        ["minecraft:furnace"] = {
            crafting  = {
                 [6]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                 [7]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                 [8]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [10]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [12]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [14]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [15]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [16]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                yield   = 1
            },
        },
    }
}

--[[
    A factory is an enterprise that offers services to produce items based on recipes. 
    
    There are (currently) two techniques for producing items.
        The crafting technique uses a crafting table to produce an output item from of a set of input items.
        The smelting technique uses a furnace to produce an output item out out of an input item.

    A factory is comprised of one or more factory sites. A site is comprised out of one or more crafting and/ or smelting spots. Furthermore a site should specify
    one or more item input and one or more item output "spots". Technically the later are (should be) URL's locating the input and output of items. The most simple 
    version of these input/ output "spots" are the inventory of a turtle.
--]]


--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

-- enterprise_factory.BuildNewSite({baseLocation={x=12, y= 0, z= 1, dx=0, dy=1}, siteVersion="v1", upgrade=false}, "coreassignment.Dummy_Callback", {})
function BuildNewSite(siteData, callback, callbackData)
    --[[
        This async public service builds a new factory site.

        Return value:
            nil 

        Async service return value (to callback):
                                - (table) {success = true} if the site was succesfully build

        Parameters:
            siteData            - (table) data about this site
                baseLocation    - (table) world location of the base (lower left corner) of this site
                siteVersion     - (string) version string of the site
                upgrade         - (boolean) if site should (only) be updated from previous version
            callback            - (string) name of function to call once the site is build
            callbackData        - (table) data to supply to callback function
    ]]

    -- check input
    if type(siteData) ~= "table" or type(siteData.siteVersion) ~= "string" or type(siteData.baseLocation) ~= "table" then
        corelog.Error('enterprise_factory.BuildNewSite: Invalid siteData input')
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    if type(callback) ~= "string" then 
        corelog.Error('enterprise_factory.BuildNewSite: Invalid callback function')
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    callbackData = callbackData or {}

    -- get site build data
    local siteBuildData = nil
    if siteData.siteVersion == "v0" then
        siteBuildData = GetV0SiteBuildData(siteData)
    elseif siteData.siteVersion == "v1" then
        siteBuildData = GetV1SiteBuildData(siteData)
    elseif siteData.siteVersion == "v2" then
        siteBuildData = GetV2SiteBuildData(siteData)
    else
        corelog.Error("enterprise_factory.BuildNewSite: Don't know how to build a factory site of version "..siteData.siteVersion)
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end

    -- let construction enterprise build the site
    corelog.WriteToLog(">Building factory site version "..siteData.siteVersion.." at "..textutils.serialise(siteBuildData.blueprintStartpoint))
    enterprise_construction.BuildBlueprint(siteBuildData, callback, callbackData)
end

-- enterprise_factory.StartNewSite({baseLocation={x=12, y= 0, z= 1, dx=0, dy=1}, siteVersion="v1"})
function StartNewSite(siteData)
    --[[
        This sync public service ensures a new site is ready for use.

        Return value:
                                - (table) {success = true} if the site is ready for business

        Parameters:
            siteData            - (table) data about this site
                baseLocation    - (table) world location of the base (lower left corner) of this site
                siteVersion     - (string) version string of the site
    --]]

    -- check our input
    if type(siteData) ~= "table" or type(siteData.baseLocation) ~= "table" or type(siteData.siteVersion) ~= "string" then corelog.Error('enterprise_factory.StartNewSite: Invalid input') return {success = false} end

    -- ensure enterprise has a key in the dht
    if coredht.GetData(db.dhtRoot) == nil then
        -- create the entry
        coredht.SaveData({}, db.dhtRoot)
        coredht.SaveData({}, db.dhtRoot, db.dhtSites)
    end

    -- get site start data
    local siteStartData = nil
    if siteData.siteVersion == "v0" then
        siteStartData = GetV0SiteStartData(siteData)
    elseif siteData.siteVersion == "v1" then
        siteStartData = GetV1SiteStartData(siteData)
--    elseif siteData.siteVersion == "v2" then -- ToDo: implement
--        siteStartData = GetV2SiteStartDate(siteData)
    else
        corelog.Error("enterprise_factory.BuildNewSite: Don't know how to start a factory site of version "..siteData.siteVersion)
        return {success = false}
    end

    -- start new site
    local newSiteId = enterprise_factory_site.StartNewSite(siteStartData)
    if type(newSiteId) ~= "string" then corelog.Error('enterprise_factory.StartNewSite: Failed starting site from start data '..textutils.serialize(siteStartData)) return {success = false} end

    -- end
    return {success = true}
end

function RemoveSites()
    --[[
        This function removes all sites from the factory. Currently this is intended for debugging purposes only.

        Return value:
                                - (table) {success = true} if the site is ready for business

        Parameters:
    --]]

    local sites = coredht.GetData(db.dhtRoot, db.dhtSites)
    if not sites or type(sites) ~= "table" then corelog.Warning("coreassignment.RemoveSites: not a lits of sites") return nil end

    -- remove all assignments
    for siteId, site in pairs(sites) do
        RemoveSite(siteId)
    end

    -- end
    return {success = true}
end

function RemoveSite(siteId)
    --[[
        This function removes a site from the factory. Currently this is intended for debugging purposes only.

        Return value:
                                - (table) {success = true} if the site is ready for business

        Parameters:
            siteId              - (string) id of the site
    --]]

    -- check our input
    if type(siteId) ~= "string" then corelog.Error('enterprise_factory.RemoveSite: Invalid siteId') return {success = false} end

    -- remove site
    corelog.Warning('enterprise_factory.RemoveSite: Removing site '..siteId.." without doing anything with the data, structure and items present")
    coredht.SaveData(nil, db.dhtRoot, db.dhtSites, siteId)

    -- end
    return {success = true}
end

--
function ProduceItem(productionData , callback, callbackData)
    --[[
        This async public service produces items in a factory site.

        Return value:
            nil

        Async service return value (to callback):
                                    - (table) {success = true} if the items were succesfully produced

        Parameters:
            productionData          - (table) data about the item to produce, 
                itemName            - (string) name of items to produce
                itemAmount          - (number) amount of items to produce
                ToDo: consider adding requester location (amongst other to be able to select a more optimal (closest) site)
            callback                - (string) name of function to call once the items are made
            callbackData            - (table) data to supply to callback function
    ]]

    -- check input
    if type(productionData) ~= "table" or type(productionData.itemName) ~= "string" or type(productionData.itemAmount) ~= "number" then
        corelog.Error('enterprise_factory.ProduceItem: Invalid productionData input')
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    if type(callback) ~= "string" then corelog.Error('enterprise_factory.ProduceItem: Invalid callback function') return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- select recipe to produce item
    local itemName = productionData.itemName
    if type(db.recipes[ itemName ]) ~= "table" then corelog.Error("enterprise_factory.ProduceItem: No recipe for item "..itemName) return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local craftRecipe = db.recipes[ itemName ].crafting
    local smeltRecipe = db.recipes[ itemName ].smelting

    -- select a suitable site
    local siteId, recipe = FindAvailableSite(craftRecipe, smeltRecipe)
    if type(siteId) ~= "string" or type(recipe) ~="table" then corelog.Error('enterprise_factory.ProduceItem: No site available to produce '..textutils.serialize(productionData))
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end

    -- let site produce item
    if recipe == craftRecipe then
        enterprise_factory_site.CraftItem(siteId, productionData, recipe, callback, callbackData)
    elseif recipe == smeltRecipe then
        enterprise_factory_site.SmeltItemAndPickup(siteId, productionData, recipe, callback, callbackData)
        -- ToDo: consider splitting smelting from pickup in a later version. Possibly by using URL's referencing the pickup location (and time?)
    else
        corelog.Error('enterprise_factory.ProduceItem: Unknown recipe type to produce '..textutils.serialize(productionData))
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

--[[
    A v0 site is comprised of 
    - one crafting spot. Below the crafting spot is a hole in the ground as a temporary storage for items not needed
    - no smelting spot 
--]]

local shaftLayer_pattern = {
    deltaX      = 1,
    deltaY      = 1,
    objectList  = {
    },
    clearRemainingSpace = true,
}

function GetV0SiteBuildData(siteData)
    -- construct layer list
    local layerList = {
        { startpoint = { x= 0, y= 0, z= -1}, buildFromAbove = true, pattern = role_builder.CopyPattern(shaftLayer_pattern)},
    }

    -- construct blueprint
    local blueprint = {
        layerList = layerList,
        escapeSequence = {
        }
    }

    -- construct build data
    local siteBuildData = {
        blueprintStartpoint = coremove.CopyLocation(siteData.baseLocation),
        blueprint = blueprint
    }

    return siteBuildData
end

function GetV0SiteStartData(siteData)
    -- construct start data
    local startData = {
        version = siteData.siteVersion,

        baseLocation = coremove.CopyLocation(siteData.baseLocation),

        craftingSpots = {
            { location = { x= 0, y=0, z=0}}
        },
        smeltingSpots = {},
        -- ToDo add URL's for input and output spots. For now (v0 en v1 of factory site) it is assumed both are the inventory of the current turtle
    }

    return startData
end

--[[
    A v1 site is comprised of 
    - one crafting spot. Below the crafting spot is a hole in the ground as a temporary storage for items not needed.
    - one smelting spot. In front of the smelting spot is a furnace that can be accessed from the front, the top and below. 
--]]

local aboveOrBelowFurnanceLayerL1_pattern = {
    deltaX      = 1,
    deltaY      = 2,
    objectList  = {},
    clearRemainingSpace = true
}

local furnanceLayerL1_pattern = {
    deltaX      = 1,
    deltaY      = 2,
    objectList  = {
        { x = 0, y = 1, block = "minecraft:furnace"},
    },
    clearRemainingSpace = true
}

function GetV1SiteBuildData(siteData)
    -- construct layer list
    local layerList = {
        { startpoint = { x= 3, y= 3, z= -1}, buildFromAbove = true, pattern = role_builder.CopyPattern(shaftLayer_pattern)},
        { startpoint = { x= 3, y= 3, z= -2}, buildFromAbove = false, pattern = role_builder.CopyPattern(aboveOrBelowFurnanceLayerL1_pattern)},
        { startpoint = { x= 3, y= 3, z= -3}, buildFromAbove = false, pattern = role_builder.CopyPattern(furnanceLayerL1_pattern)},
        { startpoint = { x= 3, y= 3, z= -5}, buildFromAbove = true, pattern = role_builder.CopyPattern(shaftLayer_pattern)},
    }

    -- construct blueprint
    local blueprint = {
        layerList = layerList,
        escapeSequence = {
            { x= 3, y= 3, z=  1},
        }
    }

    -- construct build data
    local siteBuildData = {
        blueprintStartpoint = coremove.CopyLocation(siteData.baseLocation),
        blueprint = blueprint
    }

    return siteBuildData
end

function GetV1SiteStartData(siteData)
    -- construct start data
    local startData = {
        version = siteData.siteVersion,

        baseLocation = coremove.CopyLocation(siteData.baseLocation),

        craftingSpots = {
            { location = { x= 3, y=3, z=-4}}
        },
        smeltingSpots = {
            { location = { x= 3, y=3, z=-3}}
        },
        -- ToDo add URL's for input and output spots. For now (v0 en v1 of factory site) it is assumed both are the inventory of the current turtle
    }

    return startData
end

--[[
    A v2 site is comprised of 
    - one crafting spot. Below the crafting spot should is a chest as a temporary storage for items not needed.
    - one smelting spot. In front of the smelting spot is a furnace that can be accessed from the front, the top and below.

    - ToDo and some additional chests of which we need to define what their exact purpose is.
--]]

local storageChestL2_pattern = {
    deltaX      = 1,
    deltaY      = 1,
    objectList  = {
        { x = 0, y = 0, block = "minecraft:chest"},
    },
    clearRemainingSpace = false
}

local topLayerL2_pattern = {
    deltaX      = 6,
    deltaY      = 6,
    objectList  = {
        { x = 0, y = 3, block = "minecraft:torch"},
        { x = 2, y = 5, block = "minecraft:chest"},
        { x = 3, y = 0, block = "minecraft:torch"},
        { x = 4, y = 5, block = "minecraft:chest"},
    },
    clearRemainingSpace = true
}

function GetV2SiteBuildData(siteData)
    local onlyUpgrade = siteData.upgrade

    -- construct layer list
    local layerList = {
        { startpoint = { x= 0, y= 0, z=  0}, buildFromAbove = true, pattern = role_builder.CopyPattern(topLayerL2_pattern)},
    }
    if not onlyUpgrade then
        table.insert(layerList, { startpoint = { x= 3, y= 3, z= -1}, buildFromAbove = true, pattern = role_builder.CopyPattern(shaftLayer_pattern)})
        table.insert(layerList, { startpoint = { x= 3, y= 3, z= -2}, buildFromAbove = false, pattern = role_builder.CopyPattern(aboveOrBelowFurnanceLayerL1_pattern)})
        table.insert(layerList, { startpoint = { x= 3, y= 3, z= -3}, buildFromAbove = false, pattern = role_builder.CopyPattern(furnanceLayerL1_pattern)})
    end
    table.insert(layerList, { startpoint = { x= 3, y= 3, z= -5}, buildFromAbove = true, pattern = role_builder.CopyPattern(storageChestL2_pattern)})

    -- construct blueprint
    local blueprint = {
        layerList = layerList,
        escapeSequence = {
            { x= 3, y= 3, z=  1},
        }
    }

    -- construct build data
    local siteBuildData = {
        blueprintStartpoint = coremove.CopyLocation(siteData.baseLocation),
        blueprint = blueprint
    }

    return siteBuildData
end

function GetV2SiteStartData(siteData)
    -- construct start data
    local startData = {
        version = siteData.siteVersion,

        baseLocation = siteData.baseLocation,

        craftingSpots = {
            { location = { x= 3, y=3, z=-4}}
        },
        smeltingSpots = {
            { location = { x= 3, y=3, z=-3}}
        },
        -- ToDo add URL's for input and output spots.
    }

    return startData
end

function FindAvailableSite(craftRecipe, smeltRecipe)
    -- sites ophalen
    local sites = coredht.GetData(db.dhtRoot, db.dhtSites)

    -- check if we have any site
    if type(sites) ~= "table" then corelog.Warning('enterprise_factory.FindAvailableSite: no sites present') return nil, nil end

    -- find available sites
    local availableSitesInfo = {
    }
    for k, site in pairs(sites) do
        local siteId = site.siteId
        -- check it can craft recipe
        if craftRecipe ~= nil then
            local craftSpot = enterprise_factory_site.GetAvailableCraftSpot(siteId)
            if craftSpot ~= nil then
                table.insert(availableSitesInfo, {
                    siteId = siteId,
                    recipe = craftRecipe
                })
            end
        end

        -- check it can smelt recipe
        if smeltRecipe ~= nil then
            local smeltSpot = enterprise_factory_site.GetAvailableSmeltSpot(siteId)
            if smeltSpot ~= nil then
                table.insert(availableSitesInfo, {
                    siteId = siteId,
                    recipe = smeltRecipe
                })
            end
        end
    end

    -- select best site
    for i, siteInfo in ipairs(availableSitesInfo) do
        -- for now take first
        return siteInfo.siteId, siteInfo.recipe
        -- ToDo: consider finding best site based on some selection criterium 
    end

    corelog.Warning('enterprise_factory.FindAvailableSite: no site available')
    return nil, nil
end

--          _     _                                              _                        _                 _      
--         | |   | |                                            | |                      | |               | |     
--     ___ | | __| |  _ __ ___   ___  ___ ___  __ _  __ _  ___  | |__   __ _ ___  ___  __| |   ___ ___   __| | ___ 
--    / _ \| |/ _` | | '_ ` _ \ / _ \/ __/ __|/ _` |/ _` |/ _ \ | '_ \ / _` / __|/ _ \/ _` |  / __/ _ \ / _` |/ _ \
--   | (_) | | (_| | | | | | | |  __/\__ \__ \ (_| | (_| |  __/ | |_) | (_| \__ \  __/ (_| | | (_| (_) | (_| |  __/
--    \___/|_|\__,_| |_| |_| |_|\___||___/___/\__,_|\__, |\___| |_.__/ \__,_|___/\___|\__,_|  \___\___/ \__,_|\___|
--                                                   __/ |                                                         
--                                                  |___/                                                          

function NewAlchemieSite(data)
    -- data.location = {x=.., y=.., z=.., dx=.., dy=..}
    -- data.type = "simple" | "regular"
    local enterpriseId   = coreutils.NewId()
    local enterpriseName  = "enterprise_factory"


    -- data verrijken
    data.enterpriseId   = enterpriseId
    data.enterpriseName = enterpriseName
    data.topchests      = {}
    data.furnaces       = {}
    data.taskList       = {}
    data.activeTasks    = {}
    data.craftingTable  = "inventory" -- or {location table} if the site has one

    -- onze gegevens opslaan
    coredht.SaveData(data, "enterprises", enterpriseId)

    -- vacature uitzetten voor een turtle die dit voor ons gaat bouwen
    corejob.NewJob({
        enterpriseId    = enterpriseId,
        location        = coremove.CopyLocation(data.location, 0), -- kopie van locatie van het alchemisten centrum, waar het werk (waarschijnlijk) plaats zal vinden
        startTime       = coreutils.UniversalTime(),
        needTool        = true,
        needTurtle      = true
    })
end

function ProcessNextTask(enterpriseId)
    local taskList          = coredht.GetData("enterprises", enterpriseId, "taskList")
    local taskId, taskTable = next(taskList)

    -- did we get a task?
    if not taskId or type(taskTable) ~= "table" then return end

    -- remove from the task list once completed
    coredht.SaveData(nil, "enterprises", enterpriseId, "taskList", taskId)

    -- execute this command using the task queue
        if taskTable.alchemieType == "craft"    then return coretask.AddWork(role_alchemist.Craft_Task,  taskTable)
    elseif taskTable.alchemieType == "smelt"    then return coretask.AddWork(role_alchemist.Smelt_Task,  taskTable)
    elseif taskTable.alchemieType == "pickup"   then return coretask.AddWork(role_alchemist.Pickup_Task, taskTable)
    end
end

function ProcessNextMessage(enterpriseId)
    -- berichten die we accepteren
    --
    -- {subject="item list", itemName="minecraft:charcoal", itemCount=64} --> returns one or more item lists needed to craft this
    -- {subject="claim chest" } --> return chest loaction and claims chest (or returns nil when no chest is available)
    -- {subject="free chest" }  --> marks the chest as free for new use
    -- {subject="make item", itemName="minecraft:charcoal", itemCount=64, resource="inventory"|{location tabel} } --> will make the items and returns message when complete

    -- retreive next message
    local message       = enterprise.GetNextMessage(enterpriseId)
    if type(message) ~= "table" then return false end

    -- what to do?
    if message.subject == "item list"   then ProcessItemListMessage(message)    end
    if message.subject == "claim chest" then ProcessClaimChestMessage(message)  end
    if message.subject == "free chest"  then ProcessFreeChestMessage(message)   end
    if message.subject == "make item"   then ProcessMakeItemMessage(message)    end

    -- we did something, impressive
    return true
end

function TaskComplete(enterpriseId)
    -- get enterprise data
--    local data          = coredht.GetData("enterprises", enterpriseId)

    -- moeten we nog iets doen nu de task is afgerond? nieuwe job aanmaken
    corejob.NewJob({
        enterpriseId    = enterpriseId,
--        location        = data.location,                -- locatie van het alchemisten centrum, waar het werk (waarschijnlijk) plaats zal vinden
        startTime       = coreutils.UniversalTime(),
        needTool        = false,                        -- geen bijzondere turtle nodig
        needTurtle      = true
    })
end

function ProcessItemListMessage(message)
    -- makes item list needed for crafting / smelting this item
    local messageData   = message.data

    -- valid message?
    if type(messageData.itemName) ~= "string" or type(messageData.itemCount) ~= "number" then corelog.Warning("Received message without required fields") return nil end

    -- do we know this item?
    local recipe = db.recipes[ messageData.itemName ]
    if not recipe then corelog.Warning("No recipe found for "..messageData.itemName) return nil end

    -- to store our reaction
    local responseData  = { possibilities = {} }

    -- via crafting te maken?
    if recipe.crafting then
        local crafting  = recipe.crafting
        local data      = { itemList = {}, output = 0 }

        -- how often do we need to perform this recipe?
        local times = math.ceil( messageData.itemCount / crafting.yield )

        -- calculate all the needed items
        for i=1,16 do

            -- this slot needed for this recipe?
            if crafting[ i ] then

                -- add to list
                data.itemList[ crafting[ i ].itemName ] = (data.itemList[ crafting[ i ].itemName ] or 0) + times * crafting[ i ].itemCount

            end
        end

        -- calculate the output
        data.output = times * crafting.yield

        -- add to responseData
        responseData.possibilities[#responseData.possibilities + 1] = data
    end

    -- via smelting te maken?
    if recipe.smelting then
        local smelting  = recipe.smelting
        local data      = { itemList = {}, output = 0 }

        -- how often do we need to perform this recipe?
        local times = math.ceil( messageData.itemCount / smelting.yield )

        -- add to list
        data.itemList[ smelting.itemName ] = times * smelting.itemCount

        -- calculate the output
        data.output = times * smelting.yield

        -- add to responseData
        responseData.possibilities[#responseData.possibilities + 1] = data
    end

    -- send message back
    enterprise.ReplyToMessage(message, "item list response", responseData)
end

function ProcessClaimChestMessage(message)
    -- get enterprise data
    local enterpriseId  = enterprise.GetMessageRecipient(message)
    local data          = coredht.GetData("enterprises", enterpriseId)
    local topchests     = data.topchests
    local responseData  = {}

    -- look for a free chest
    for chestId, chest in pairs(topchests) do

        -- is this one free?
        if chest.status == "free" then

            -- claim chest
            coredht.SaveData("claimed", "enterprises", enterpriseId, "topchests", chestId, "status")

            -- opslaan
            responseData    = {
                chestId         = chestId,
                chestLocation   = chest.location
            }

            -- rest van de loop niet meer nodig
            break
        end
    end

    -- send message back
    enterprise.ReplyToMessage(message, "claim chest response", responseData)
end

function ProcessFreeChestMessage(message)
    -- voor wie zijn we aan het werk?
    local enterpriseId = enterprise.GetMessageRecipient(message)

    -- check parameters
    if type(message) ~= "table" or type(message.data) ~= table then return nil end

    -- controleren of deze chest wel bestaat
    if coredht.GetData("enterprises", enterpriseId, "topchests", message.data.chestId) then

        -- store new status
        coredht.SaveData("free", "enterprises", enterpriseId, "topchests", message.data.chestId, "status")
    end

    -- geen reactie terug
end

function ProcessMakeItemMessage(message)
    -- message.data.itemName            -- mandatory
    -- message.data.itemCount           -- default: 1
    -- message.data.ingredientsLocation -- "inventory"|{location table}

    -- voor wie zijn we aan het werk?
    local enterpriseId = enterprise.GetMessageRecipient(message)

    -- check parameters
    local messageData               = message.data
    if not type(messageData.itemName) == "string" then return nil end                  -- "minecraft:chest"
    messageData.itemCount           = messageData.itemCount or 1                       -- 8
    messageData.ingredientsLocation = messageData.ingredientsLocation  or "inventory"  -- "inventory"|{location tabel}

    -- check if the item is known in our recipes
    if type(db.recipes[ messageData.itemName ]) ~= "table" then corelog.WriteToLog("No recipe for item "..messageData.itemName) return end

    -- make a copy of the locations
    if type(messageData.ingredientsLocation) == "table" then messageData.ingredientsLocation = coremove.CopyLocation(messageData.ingredientsLocation) end
    local workingLocation   = coremove.CopyLocation(coredht.GetData("enterprises", enterpriseId, "location"))

    -- see if it's crafting (no waiting time) or smelting (waiting time)
    local craftingRecipe    = db.recipes[ messageData.itemName ].crafting
    local smeltingRecipe    = db.recipes[ messageData.itemName ].smelting

    -- get us a nice fresh id
    local taskId            = coreutils.NewId()

    -- for now just one way supported, just crafting
    if craftingRecipe ~= nil then
        coredht.SaveData({
            taskId              = taskId,
            messageId           = enterprise.GetMessageId(message),
            created             = coreutils.UniversalTime(),
            alchemieType        = "craft",
            recipe              = textutils.unserialize(textutils.serialize(craftingRecipe)),
            itemName            = messageData.itemName,
            itemCount           = messageData.itemCount,
            ingredientsLocation = messageData.ingredientsLocation,
            workingLocation     = workingLocation,
        }, "enterprises", enterpriseId, "taskList", taskId)

    -- other way around
    elseif smeltingRecipe then



    else
        -- no recipe known for this item!
    end
end
