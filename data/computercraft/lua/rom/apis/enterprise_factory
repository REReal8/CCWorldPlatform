local db = {
    dhtRoot     = "enterprise_factory",
    dhtSites    = "sites",

    -- turtle slots
    -- [ 1] [ 2] [ 3] [ 4]
    -- [ 5] [ 6] [ 7] [ 8]
    -- [ 9] [10] [11] [12]
    -- [13] [14] [15] [16]
    recipes        = {
        ["minecraft:stick"] = {
            crafting  = {
                  [6]    = { itemName = "minecraft:birch_planks",   itemCount = 1 },
                 [10]    = { itemName = "minecraft:birch_planks",   itemCount = 1 },
                yield   = 4
            },
        },
        ["minecraft:charcoal"] = { -- ToDo consider similar format to crafting to simpify code
            smelting  = {
                itemName    = "minecraft:birch_log",
--                itemCount   = 1,
                yield       = 1,
            },
        },
        ["minecraft:torch"] = {
            crafting  = {
                 [6]    = { itemName = "minecraft:charcoal",        itemCount = 1 },
                [10]    = { itemName = "minecraft:stick",           itemCount = 1 },
               yield   = 4
           },
        },
        ["minecraft:birch_planks"] = {
            crafting  = {
                 [6]    = { itemName = "minecraft:birch_log",       itemCount = 1 },
                yield   = 4
            },
        },
        ["minecraft:chest"] = {
            crafting  = {
                 [6]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                 [7]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                 [8]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [10]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [12]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [14]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [15]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [16]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                yield   = 1
            },
        },
        ["minecraft:furnace"] = {
            crafting  = {
                 [6]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                 [7]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                 [8]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [10]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [12]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [14]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [15]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [16]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                yield   = 1
            },
        },
    }
}

--[[
    The Factory is an enterprise that offers services to produce items based on recipes.

    The Factory is a Producer, hence it provides the mandatory services and functions for a Producer (like e.g. ProduceItem_ASrv).

    There are (currently) two recipe types for producing items.
        The crafting recipe uses the crafting production technique to produce an output item from a set of input items (ingredients).
        The smelting recipe uses the smelting production technique to produce an output item from an input item (ingredient).

    The Factory is comprised out of one or more factory sites. It uses the production services of the factory sites to produce the items.
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function ProduceItem_ASrv(serviceData, callback, callbackData)
    --[[
        This async public Producer service produces multiple instances of a specific item in the factory. It does so 
        by first determining a recipe that can produce the item. Subsequently it retrieves the needed production ingredients. 
        After that it produces the requested amount of items with the production method (i.e. crafting or smelting) corresponding to the recipe. 
        Finally it delivers the created items to the requested destination.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed correctly
                destinationItemsLocator - (URL) locating the final Storage and the items that where transferred to it
                                            (upon service succes the "host" component of this URL should be equal to destinationHostLocator, and
                                            the "query" should be equal to orderItems)

        Parameters:
            serviceData                 - (table) data for the service
                productItemName         - (string) name of item to produce
                productItemCount        - (number) amount of items to produce
                ingredientsHostLocator  - (URL) locating where the production ingredients can be retrieved
                destinationHostLocator  - (URL) locating where the produced items need to be delivered to
                assignmentsPriorityKey  - (string) priorityKey that should be set for all assignments triggered by this service
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_factory.ProduceItem_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productItemName = serviceData.productItemName
    if type(productItemName) ~= "string" then corelog.Error("enterprise_factory.ProduceItem_ASrv: Invalid productItemName") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local productItemCount = serviceData.productItemCount
    if type(productItemCount) ~= "number" then corelog.Error("enterprise_factory.ProduceItem_ASrv: Invalid productItemCount") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local ingredientsHostLocator = url.URLClass:new(serviceData.ingredientsHostLocator)
    if type(ingredientsHostLocator) ~= "table" then corelog.Error("enterprise_factory.ProduceItem_ASrv: Invalid ingredientsHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local destinationHostLocator = url.URLClass:new(serviceData.destinationHostLocator)
    if type(destinationHostLocator) ~= "table" then corelog.Error("enterprise_factory.ProduceItem_ASrv: Invalid destinationHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = serviceData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_factory.ProduceItem_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_factory.ProduceItem_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- select recipe to produce item
    local recipe = db.recipes[ productItemName ]
    if type(recipe) ~= "table" then corelog.Error("enterprise_factory.ProduceItem_ASrv: No recipe for item "..productItemName) return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- select a suitable site
    local siteProduceItemData = enterprise_factory_site.GetAvailableSiteData(recipe, productItemCount)
    if type(siteProduceItemData) ~= "table" then corelog.Error("enterprise_factory.ProduceItem_ASrv: No site available to produce "..productItemCount.." "..productItemName.."'s") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- determine ingredientsItemsLocator (by updating ingredientsHostLocator with itemsNeeded)
    local ingredientsItemsLocator = ingredientsHostLocator
    ingredientsItemsLocator:setQuery(coreutils.DeepCopy(siteProduceItemData.itemsNeeded))
 --   corelog.WriteToLog("   ingredientsItemsLocator="..ingredientsItemsLocator:getURI())

    -- retrieve site input & output locator's
    local localInputLocator = url.URLClass:new(siteProduceItemData.localInputLocator)
--    corelog.WriteToLog("   localInputLocator="..localInputLocator:getURI())
    local localOutputLocator = url.URLClass:new(siteProduceItemData.localOutputLocator)
--    corelog.WriteToLog("   localOutputLocator="..localOutputLocator:getURI())

    -- create project service data
    local projectDef = {
        steps = {
            { stepName = "enterprise_isp.TransferItemsFromTo_ASrv", async = true, stepDataDef = {
                { keyDef = "sourceItemsLocator"     , valueSource = 0, keyDefSource = "ingredientsItemsLocator" },
                { keyDef = "destinationHostLocator" , valueSource = 0, keyDefSource = "localInputLocator" },
                { keyDef = "assignmentsPriorityKey" , valueSource = 0, keyDefSource = "assignmentsPriorityKey" },
            }},
            { stepName = "enterprise_factory_site.ProduceItem_ASrv", async = true, stepDataDef = {
                { keyDef = "localInputItemsLocator" , valueSource = 1, keyDefSource = "destinationItemsLocator" },
                { keyDef = "localOutputLocator"     , valueSource = 0, keyDefSource = "localOutputLocator" },
                { keyDef = "productionMethod"       , valueSource = 0, keyDefSource = "productionMethod" },
                { keyDef = "productionSpot"         , valueSource = 0, keyDefSource = "productionSpot" },
                { keyDef = "productItemName"        , valueSource = 0, keyDefSource = "productItemName" },
                { keyDef = "productItemCount"       , valueSource = 0, keyDefSource = "productItemCount" },
                { keyDef = "productionRecipe"       , valueSource = 0, keyDefSource = "productionRecipe" },
                { keyDef = "assignmentsPriorityKey" , valueSource = 0, keyDefSource = "assignmentsPriorityKey" },
            }},
            { stepName = "enterprise_isp.TransferItemsFromTo_ASrv", async = true, stepDataDef = {
                { keyDef = "sourceItemsLocator"     , valueSource = 2, keyDefSource = "localOutputItemsLocator" },
                { keyDef = "destinationHostLocator" , valueSource = 0, keyDefSource = "destinationHostLocator" },
                { keyDef = "assignmentsPriorityKey" , valueSource = 0, keyDefSource = "assignmentsPriorityKey" },
            }},
            -- ToDo: consider storing rest/ waste materials (e.g. those caused by ceil (rounding up) of ingredient items)
            { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                { keyDef = "success1"               , valueSource = 1, keyDefSource = "success" },
                { keyDef = "success2"               , valueSource = 2, keyDefSource = "success" },
                { keyDef = "success3"               , valueSource = 3, keyDefSource = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , valueSource = 4, keyDefSource = "success" },
            { keyDef = "destinationItemsLocator"    , valueSource = 3, keyDefSource = "destinationItemsLocator" },
        }
    }
    local projectData = {
        ingredientsItemsLocator     = ingredientsItemsLocator,
        destinationHostLocator      = destinationHostLocator,

        localInputLocator           = localInputLocator,
        localOutputLocator          = localOutputLocator,

        productionMethod            = siteProduceItemData.productionMethod,
        productionSpot              = siteProduceItemData.productionSpot,
        productItemName             = productItemName,
        productItemCount            = productItemCount,
        productionRecipe            = siteProduceItemData.productionRecipe,

        assignmentsPriorityKey      = assignmentsPriorityKey,
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    corelog.WriteToLog(">Producing "..productItemCount.." "..productItemName.."'s")
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function BuildAndStartNewSite_ASrv(serviceData, callback, callbackData)
    --[[
        This async public service builds a new factory site and ensures it's ready for use.

        Return value:
            nil 

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the site was succesfully build and is ready for use.

        Parameters:
            serviceData                 - (table) data about this site
                baseLocation            - (table) world location of the base (lower left corner) of this site
                siteVersion             - (string) version string of the site
                upgrade                 - (boolean) if site should (only) be updated from a previous version
                materialsHostLocator    - (URL) locating the host of the building materials
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_factory.BuildAndStartNewSite_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local baseLocation = serviceData.baseLocation
    if type(baseLocation) ~= "table" then corelog.Error("enterprise_factory.BuildAndStartNewSite_ASrv: Invalid baseLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local siteVersion = serviceData.siteVersion
    local upgrade = serviceData.upgrade or false
    if type(siteVersion) ~= "string" then corelog.Error("enterprise_factory.BuildAndStartNewSite_ASrv: Invalid siteVersion") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error('enterprise_factory.BuildAndStartNewSite_ASrv: Invalid callback function') return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- determine projectSteps
    local projectSteps = { }
    local iStep = 0
    table.insert(projectSteps,
        { stepName = "enterprise_factory.BuildNewSite_ASrv", async = true, stepDataDef = {
            { keyDef = "baseLocation"           , valueSource = 0, keyDefSource = "baseLocation" },
            { keyDef = "siteVersion"            , valueSource = 0, keyDefSource = "siteVersion" },
            { keyDef = "upgrade"                , valueSource = 0, keyDefSource = "upgrade" },
            { keyDef = "materialsHostLocator"   , valueSource = 0, keyDefSource = "materialsHostLocator" },
        }}
    )
    iStep = iStep + 1
    if upgrade then
        table.insert(projectSteps,
            { stepName = "enterprise_factory.StopSite_ASrv", async = true, stepDataDef = {
                { keyDef = "baseLocation"       , valueSource = 0, keyDefSource = "baseLocation" },
            }}
        )
        iStep = iStep + 1
    end
    table.insert(projectSteps,
        { stepName = "enterprise_factory.StartNewSite_SSrv", async = false, stepDataDef = {
            { keyDef = "baseLocation"           , valueSource = 0, keyDefSource = "baseLocation" },
            { keyDef = "siteVersion"            , valueSource = 0, keyDefSource = "siteVersion" },
            { keyDef = "siteAlreadyBuild"       , valueSource = iStep, keyDefSource = "success" }
        }}
    )
    iStep = iStep + 1

    -- create project definition
    local buildAndStartNewSiteProjectDef = {
        steps = projectSteps,
        returnData  = {
            { keyDef = "success"                , valueSource = iStep, keyDefSource = "success" },
        }
    }
    local projectServiceData = {
        projectDef  = buildAndStartNewSiteProjectDef,
        projectData = serviceData,
    }

    -- start project
--    corelog.WriteToLog(">Building and starting factory site version "..siteVersion.." at "..textutils.serialise(baseLocation))
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function BuildNewSite_ASrv(serviceData, callback, callbackData)
    --[[
        This async public service builds a new factory site.

        Return value:
            nil 

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the site was succesfully build

        Parameters:
            serviceData                 - (table) data about this service
                baseLocation            - (table) world location of the base (lower left corner) of this site
                siteVersion             - (string) version string of the site
                upgrade                 - (boolean) if site should (only) be updated from a previous version
                materialsHostLocator    - (URL) locating the host of the building materials
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_factory.BuildNewSite_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local baseLocation = serviceData.baseLocation
    if type(baseLocation) ~= "table" then corelog.Error("enterprise_factory.BuildNewSite_ASrv: Invalid baseLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local siteVersion = serviceData.siteVersion
    if type(siteVersion) ~= "string" then corelog.Error("enterprise_factory.BuildNewSite_ASrv: Invalid siteVersion") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local upgrade = serviceData.upgrade or false
    if type(serviceData.materialsHostLocator) ~= "table" then corelog.Error("enterprise_factory.BuildNewSite_ASrv: Invalid materialsHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local materialsHostLocator = url.URLClass:new(serviceData.materialsHostLocator)
    if type(upgrade) ~= "boolean" then corelog.Error("enterprise_factory.BuildNewSite_ASrv: Invalid upgrade") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error('enterprise_factory.BuildNewSite_ASrv: Invalid callback function') return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- get site build data
    local siteBuildData = nil
    if siteVersion == "v0" then
        siteBuildData = enterprise_factory_site.GetV0SiteBuildData(serviceData)
    elseif siteVersion == "v1" then
        siteBuildData = enterprise_factory_site.GetV1SiteBuildData(serviceData)
    elseif siteVersion == "v2" then
        siteBuildData = enterprise_factory_site.GetV2SiteBuildData(serviceData)
    else
        corelog.Error("enterprise_factory.BuildNewSite_ASrv: Don't know how to build a factory site of version "..siteVersion)
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    siteBuildData.materialsHostLocator = materialsHostLocator

    -- let construction enterprise build the site    
    if upgrade then
--        corelog.WriteToLog("  >Upgrading factory site at "..textutils.serialise(baseLocation).." to version "..siteVersion)
        corelog.WriteToLog(">Upgrading factory site to version "..siteVersion)
    else
--        corelog.WriteToLog("  >Building factory site version "..siteVersion.." at "..textutils.serialise(baseLocation))
        corelog.WriteToLog(">Building factory site version "..siteVersion)
    end
    enterprise_construction.BuildBlueprint_ASrv(siteBuildData, callback, callbackData)
end

function StartNewSite_SSrv(serviceData)
    --[[
        This sync public service ensures a new site is ready for use.

        Return value:
                                    - (table)
                success             - (boolean) whether the site is ready for business

        Parameters:
            serviceData             - (table) data about this service
                baseLocation        - (table) world location of the base (lower left corner) of this site
                siteVersion         - (string) version string of the site
                siteAlreadyBuild    - (boolean) confirmation that the site was already physically build
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_factory.StartNewSite_SSrv: Invalid serviceData") return {success = false} end
    local baseLocation = serviceData.baseLocation
    if type(baseLocation) ~= "table" then corelog.Error("enterprise_factory.StartNewSite_SSrv: Invalid baseLocation") return {success = false} end
    local siteVersion = serviceData.siteVersion
    if type(siteVersion) ~= "string" then corelog.Error("enterprise_factory.StartNewSite_SSrv: Invalid siteVersion") return {success = false} end
    if type(serviceData.siteAlreadyBuild) ~= "boolean" then corelog.Warning("enterprise_factory.StartNewSite_SSrv: Invalid siteAlreadyBuild") return {success = false} end
    if not serviceData.siteAlreadyBuild then corelog.Warning("enterprise_factory.StartNewSite_SSrv: Site not (yet) succesfully build => we will not start it") return {success = false} end

    -- ensure enterprise has a key in the dht
    if coredht.GetData(db.dhtRoot) == nil then
        -- create the entry
        coredht.SaveData({}, db.dhtRoot)
        coredht.SaveData({}, db.dhtRoot, db.dhtSites)
    end

    -- get site start data
    local siteStartData = nil
    if siteVersion == "v0" then
        siteStartData = enterprise_factory_site.GetV0SiteStartData(serviceData)
    elseif siteVersion == "v1" then
        siteStartData = enterprise_factory_site.GetV1SiteStartData(serviceData)
    elseif siteVersion == "v2" then
        siteStartData = enterprise_factory_site.GetV2SiteStartData(serviceData)
    else
        corelog.Error("enterprise_factory.BuildNewSite_ASrv: Don't know how to start a factory site of version "..siteVersion)
        return {success = false}
    end

    -- start new site
    local newSiteId = enterprise_factory_site.StartNewSite(siteStartData)
    if type(newSiteId) ~= "string" then corelog.Error('enterprise_factory.StartNewSite_SSrv: Failed starting site from start data '..textutils.serialize(siteStartData)) return {success = false} end

    -- end
    return {success = true}
end

function StopAndDismantleSite_ASrv(serviceData, callback, callbackData)
    --[[
        This async public service stops and dismantles a site.

        Return value:
            nil 

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the site was succesfully stopped and dismantled.

        Parameters:
            serviceData                 - (table) data about this service
                baseLocation            - (table) world location of the base (lower left corner) of this site
                siteVersion             - (string) version string of the site
                materialsHostLocator    - (URL) locating the host of the building materials
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_factory.StopAndDismantleSite_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local baseLocation = serviceData.baseLocation
    if type(baseLocation) ~= "table" then corelog.Error("enterprise_factory.StopAndDismantleSite_ASrv: Invalid baseLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local siteVersion = serviceData.siteVersion
    if type(siteVersion) ~= "string" then corelog.Error("enterprise_factory.StopAndDismantleSite_ASrv: Invalid siteVersion") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_factory.StopAndDismantleSite_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- create project definition
    local stopAndDismantleSiteProjectDef = {
        steps = {
            { stepName = "enterprise_factory.StopSite_ASrv", async = true, stepDataDef = {
                { keyDef = "baseLocation"           , valueSource = 0, keyDefSource = "baseLocation" },
            }},
            { stepName = "enterprise_factory.DismantleSite_ASrv", async = true, stepDataDef = {
                { keyDef = "baseLocation"           , valueSource = 0, keyDefSource = "baseLocation" },
                { keyDef = "siteVersion"            , valueSource = 0, keyDefSource = "siteVersion" },
                { keyDef = "siteStopped"            , valueSource = 1, keyDefSource = "success" },
                { keyDef = "materialsHostLocator"   , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , valueSource = 2, keyDefSource = "success" },
        }
    }
    local projectServiceData = {
        projectDef  = stopAndDismantleSiteProjectDef,
        projectData = serviceData,
    }

    -- start project
    corelog.WriteToLog(">Stopping and dismantling factory site version "..siteVersion)
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function DismantleSite_ASrv(serviceData, callback, callbackData)
    --[[
        This async public service dismantles a factory site. Dismantling means the site is physically removed from minecraft world.
        Possibly part of the world is restored to a neutral (e.g. flat) state.

        Return value:
            nil 

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the site was succesfully dismantled

        Parameters:
            serviceData                 - (table) data about this service
                baseLocation            - (table) world location of the base (lower left corner) of the site
                siteVersion             - (string) version string of the site
                siteStopped             - (boolean) confirmation that the site was already stopped
                materialsHostLocator    - (URL) locating the host of the building materials
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_factory.DismantleSite_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local baseLocation = serviceData.baseLocation
    if type(baseLocation) ~= "table" then corelog.Error("enterprise_factory.DismantleSite_ASrv: Invalid baseLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local siteVersion = serviceData.siteVersion
    if type(siteVersion) ~= "string" then corelog.Error("enterprise_factory.DismantleSite_ASrv: Invalid siteVersion") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(serviceData.materialsHostLocator) ~= "table" then corelog.Error("enterprise_factory.DismantleSite_ASrv: Invalid materialsHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local materialsHostLocator = url.URLClass:new(serviceData.materialsHostLocator)
    if type(callback) ~= "string" then corelog.Error('enterprise_factory.DismantleSite_ASrv: Invalid callback function') return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}
    if type(serviceData.siteStopped) ~= "boolean" then corelog.Warning("enterprise_factory.DismantleSite_ASrv: siteStopped not valid") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if not serviceData.siteStopped then corelog.Warning("enterprise_factory.DismantleSite_ASrv: Site not (yet) stopped => we will not dismantle it") return coreutils.DoCallback(callback, callbackData, {success = false}) end

    -- get site dismantal data
    local siteDismantleBuildData = nil
    if siteVersion == "v0" then
        siteDismantleBuildData = enterprise_factory_site.GetV0SiteDismantleBuildData(serviceData)
-- ToDo implement for v1 and v2
--    elseif siteVersion == "v1" then
--        siteDismantleBuildData = enterprise_factory_site.GetV1SiteDismantleBuildData(serviceData)
--    elseif siteVersion == "v2" then
--        siteDismantleBuildData = enterprise_factory_site.GetV2SiteDismantleBuildData(serviceData)
    else
        corelog.Error("enterprise_factory.DismantleSite_ASrv: Don't know how to dismantle a factory site of version "..siteVersion)
        return coreutils.DoCallback(callback, callbackData, {success = false})
    end
    siteDismantleBuildData.materialsHostLocator = materialsHostLocator

    -- let construction enterprise dismantle the site
    enterprise_construction.BuildBlueprint_ASrv(siteDismantleBuildData, callback, callbackData)
end

function StopSite_ASrv(serviceData, callback, callbackData)
    --[[
        This async public service stops a factory site. Stopping implies
          - the site is immediatly no longer available for new business
          - wait for all active work (production) on site to be ended
          - remove the site from the factory 

        Return value:
            nil 

        Async service return value (to callback):
                                - (table)
                success         - (boolean) when the site was succesfully stopped

        Parameters:
            serviceData         - (table) data about this service
                baseLocation    - (table) world location of the base (lower left corner) of the site
            callback            - (string) name of function to call once service is ready
            callbackData        - (table) data to supply to callback function
    ]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_factory.StopSite_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local baseLocation = serviceData.baseLocation
    if type(baseLocation) ~= "table" then corelog.Error("enterprise_factory.StopSite_ASrv: Invalid baseLocation") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_factory.StopSite_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- pass on the request to site file
    enterprise_factory_site.StopSite_ASrv(serviceData, callback, callbackData)
end

function CanProduce_QSrv(serviceData)
    --[[
        This sync public query service answers the question if this Producer can produce specific items.
        
        Return value:
                                    - (table)
                success             - (boolean) wether the answer to the question is true

        Parameters:
            serviceData             - (table) data to the query
                productItemName     - (string) name of item to produce
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_factory.CanProduce_QSrv: Invalid serviceData") return {success = false} end
    local productItemName = serviceData.productItemName
    if type(productItemName) ~= "string" then corelog.Error("enterprise_factory.CanProduce_QSrv: Invalid productItemName") return {success = false} end

    -- check for recipe to produce productItemName
    local recipe = db.recipes[ productItemName ]
    if type(recipe) ~= "table" then
        return {success = false}
    end
    -- end
    return {
        success         = true,
    }
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function DeleteSites()
    --[[
        This function deletes all sites from the factory. Currently this is intended for debugging purposes only.

        Return value:
                                - (table)
                success         - (boolean) whether all the sites were removed

        Parameters:
    --]]

    local sites = coredht.GetData(db.dhtRoot, db.dhtSites)
    if not sites or type(sites) ~= "table" then corelog.Warning("coreassignment.DeleteSites: not a lits of sites") return nil end

    -- remove all assignments
    for siteId, site in pairs(sites) do
        DeleteSite(siteId)
    end

    -- end
    return {success = true}
end

function DeleteSite(siteId)
    --[[
        This function deletes a site from the factory. Currently this is intended for debugging purposes only.

        Return value:
                                - (table)
                success         - (boolean) whether the sites was removed

        Parameters:
            siteId              - (string) id of the site
    --]]

    -- check our input
    if type(siteId) ~= "string" then corelog.Error('enterprise_factory.DeleteSite: Invalid siteId') return {success = false} end

    -- remove site
    corelog.Warning('enterprise_factory.DeleteSite: Removing site '..siteId.." without doing anything with the data, structure and items present")
    coredht.SaveData(nil, db.dhtRoot, db.dhtSites, siteId)

    -- end
    return {success = true}
end

--          _     _                                              _                        _                 _      
--         | |   | |                                            | |                      | |               | |     
--     ___ | | __| |  _ __ ___   ___  ___ ___  __ _  __ _  ___  | |__   __ _ ___  ___  __| |   ___ ___   __| | ___ 
--    / _ \| |/ _` | | '_ ` _ \ / _ \/ __/ __|/ _` |/ _` |/ _ \ | '_ \ / _` / __|/ _ \/ _` |  / __/ _ \ / _` |/ _ \
--   | (_) | | (_| | | | | | | |  __/\__ \__ \ (_| | (_| |  __/ | |_) | (_| \__ \  __/ (_| | | (_| (_) | (_| |  __/
--    \___/|_|\__,_| |_| |_| |_|\___||___/___/\__,_|\__, |\___| |_.__/ \__,_|___/\___|\__,_|  \___\___/ \__,_|\___|
--                                                   __/ |                                                         
--                                                  |___/                                                          

function NewAlchemieSite(data)
    -- data.location = {x=.., y=.., z=.., dx=.., dy=..}
    -- data.type = "simple" | "regular"
    local enterpriseId   = coreutils.NewId()
    local enterpriseName  = "enterprise_factory"


    -- data verrijken
    data.enterpriseId   = enterpriseId
    data.enterpriseName = enterpriseName
    data.topchests      = {}
    data.furnaces       = {}
    data.taskList       = {}
    data.activeTasks    = {}
    data.craftingTable  = "inventory" -- or {location table} if the site has one

    -- onze gegevens opslaan
    coredht.SaveData(data, "enterprises", enterpriseId)

    -- vacature uitzetten voor een turtle die dit voor ons gaat bouwen
    corejob.NewJob({
        enterpriseId    = enterpriseId,
        location        = coremove.CopyLocation(data.location, 0), -- kopie van locatie van het alchemisten centrum, waar het werk (waarschijnlijk) plaats zal vinden
        startTime       = coreutils.UniversalTime(),
        needTool        = true,
        needTurtle      = true
    })
end

function ProcessNextTask(enterpriseId)
    local taskList          = coredht.GetData("enterprises", enterpriseId, "taskList")
    local taskId, taskTable = next(taskList)

    -- did we get a task?
    if not taskId or type(taskTable) ~= "table" then return end

    -- remove from the task list once completed
    coredht.SaveData(nil, "enterprises", enterpriseId, "taskList", taskId)

    -- execute this command using the task queue
        if taskTable.alchemieType == "craft"    then return coretask.AddWork(role_alchemist.Craft_Task,  taskTable)
    elseif taskTable.alchemieType == "smelt"    then return coretask.AddWork(role_alchemist.Smelt_Task,  taskTable)
    elseif taskTable.alchemieType == "pickup"   then return coretask.AddWork(role_alchemist.Pickup_Task, taskTable)
    end
end

function ProcessNextMessage(enterpriseId)
    -- berichten die we accepteren
    --
    -- {subject="item list", itemName="minecraft:charcoal", itemCount=64} --> returns one or more item lists needed to craft this
    -- {subject="claim chest" } --> return chest loaction and claims chest (or returns nil when no chest is available)
    -- {subject="free chest" }  --> marks the chest as free for new use
    -- {subject="make item", itemName="minecraft:charcoal", itemCount=64, resource="inventory"|{location tabel} } --> will make the items and returns message when complete

    -- retreive next message
    local message       = enterprise.GetNextMessage(enterpriseId)
    if type(message) ~= "table" then return false end

    -- what to do?
    if message.subject == "item list"   then ProcessItemListMessage(message)    end
    if message.subject == "claim chest" then ProcessClaimChestMessage(message)  end
    if message.subject == "free chest"  then ProcessFreeChestMessage(message)   end
    if message.subject == "make item"   then ProcessMakeItemMessage(message)    end

    -- we did something, impressive
    return true
end

function TaskComplete(enterpriseId)
    -- get enterprise data
--    local data          = coredht.GetData("enterprises", enterpriseId)

    -- moeten we nog iets doen nu de task is afgerond? nieuwe job aanmaken
    corejob.NewJob({
        enterpriseId    = enterpriseId,
--        location        = data.location,                -- locatie van het alchemisten centrum, waar het werk (waarschijnlijk) plaats zal vinden
        startTime       = coreutils.UniversalTime(),
        needTool        = false,                        -- geen bijzondere turtle nodig
        needTurtle      = true
    })
end

function ProcessItemListMessage(message)
    -- makes item list needed for crafting / smelting this item
    local messageData   = message.data

    -- valid message?
    if type(messageData.itemName) ~= "string" or type(messageData.itemCount) ~= "number" then corelog.Warning("Received message without required fields") return nil end

    -- do we know this item?
    local recipe = db.recipes[ messageData.itemName ]
    if not recipe then corelog.Warning("No recipe found for "..messageData.itemName) return nil end

    -- to store our reaction
    local responseData  = { possibilities = {} }

    -- via crafting te maken?
    if recipe.crafting then
        local crafting  = recipe.crafting
        local data      = { itemList = {}, output = 0 }

        -- how often do we need to perform this recipe?
        local times = math.ceil( messageData.itemCount / crafting.yield )

        -- calculate all the needed items
        for i=1,16 do

            -- this slot needed for this recipe?
            if crafting[ i ] then

                -- add to list
                data.itemList[ crafting[ i ].itemName ] = (data.itemList[ crafting[ i ].itemName ] or 0) + times * crafting[ i ].itemCount

            end
        end

        -- calculate the output
        data.output = times * crafting.yield

        -- add to responseData
        responseData.possibilities[#responseData.possibilities + 1] = data
    end

    -- via smelting te maken?
    if recipe.smelting then
        local smelting  = recipe.smelting
        local data      = { itemList = {}, output = 0 }

        -- how often do we need to perform this recipe?
        local times = math.ceil( messageData.itemCount / smelting.yield )

        -- add to list
        data.itemList[ smelting.itemName ] = times * smelting.itemCount

        -- calculate the output
        data.output = times * smelting.yield

        -- add to responseData
        responseData.possibilities[#responseData.possibilities + 1] = data
    end

    -- send message back
    enterprise.ReplyToMessage(message, "item list response", responseData)
end

function ProcessClaimChestMessage(message)
    -- get enterprise data
    local enterpriseId  = enterprise.GetMessageRecipient(message)
    local data          = coredht.GetData("enterprises", enterpriseId)
    local topchests     = data.topchests
    local responseData  = {}

    -- look for a free chest
    for chestId, chest in pairs(topchests) do

        -- is this one free?
        if chest.status == "free" then

            -- claim chest
            coredht.SaveData("claimed", "enterprises", enterpriseId, "topchests", chestId, "status")

            -- opslaan
            responseData    = {
                chestId         = chestId,
                chestLocation   = chest.location
            }

            -- rest van de loop niet meer nodig
            break
        end
    end

    -- send message back
    enterprise.ReplyToMessage(message, "claim chest response", responseData)
end

function ProcessFreeChestMessage(message)
    -- voor wie zijn we aan het werk?
    local enterpriseId = enterprise.GetMessageRecipient(message)

    -- check parameters
    if type(message) ~= "table" or type(message.data) ~= table then return nil end

    -- controleren of deze chest wel bestaat
    if coredht.GetData("enterprises", enterpriseId, "topchests", message.data.chestId) then

        -- store new status
        coredht.SaveData("free", "enterprises", enterpriseId, "topchests", message.data.chestId, "status")
    end

    -- geen reactie terug
end

function ProcessMakeItemMessage(message)
    -- message.data.itemName            -- mandatory
    -- message.data.itemCount           -- default: 1
    -- message.data.ingredientsLocation -- "inventory"|{location table}

    -- voor wie zijn we aan het werk?
    local enterpriseId = enterprise.GetMessageRecipient(message)

    -- check parameters
    local messageData               = message.data
    if not type(messageData.itemName) == "string" then return nil end                  -- "minecraft:chest"
    messageData.itemCount           = messageData.itemCount or 1                       -- 8
    messageData.ingredientsLocation = messageData.ingredientsLocation  or "inventory"  -- "inventory"|{location tabel}

    -- check if the item is known in our recipes
    if type(db.recipes[ messageData.itemName ]) ~= "table" then corelog.WriteToLog("No recipe for item "..messageData.itemName) return end

    -- make a copy of the locations
    if type(messageData.ingredientsLocation) == "table" then messageData.ingredientsLocation = coremove.CopyLocation(messageData.ingredientsLocation) end
    local workingLocation   = coremove.CopyLocation(coredht.GetData("enterprises", enterpriseId, "location"))

    -- see if it's crafting (no waiting time) or smelting (waiting time)
    local craftingRecipe    = db.recipes[ messageData.itemName ].crafting
    local smeltingRecipe    = db.recipes[ messageData.itemName ].smelting

    -- get us a nice fresh id
    local taskId            = coreutils.NewId()

    -- for now just one way supported, just crafting
    if craftingRecipe ~= nil then
        coredht.SaveData({
            taskId              = taskId,
            messageId           = enterprise.GetMessageId(message),
            created             = coreutils.UniversalTime(),
            alchemieType        = "craft",
            recipe              = textutils.unserialize(textutils.serialize(craftingRecipe)),
            itemName            = messageData.itemName,
            itemCount           = messageData.itemCount,
            ingredientsLocation = messageData.ingredientsLocation,
            workingLocation     = workingLocation,
        }, "enterprises", enterpriseId, "taskList", taskId)

    -- other way around
    elseif smeltingRecipe then



    else
        -- no recipe known for this item!
    end
end
