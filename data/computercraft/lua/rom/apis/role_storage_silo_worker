local db = {
    dhtRoot     = "enterprise_storage",
    dhtSites    = "sites",
}

--[[
                _                                  _
               (_)                                | |
   __ _ ___ ___ _  __ _ _ __  _ __ ___   ___ _ __ | |_ ___
  / _` / __/ __| |/ _` | '_ \| '_ ` _ \ / _ \ '_ \| __/ __|
 | (_| \__ \__ \ | (_| | | | | | | | | |  __/ | | | |_\__ \
  \__,_|___/___/_|\__, |_| |_|_| |_| |_|\___|_| |_|\__|___/
                   __/ |
                  |___/
--]]

function ItemsDelivered_Task(data)

    -- variables from the assignment data
    local site      = coredht.GetData(db.dhtRoot, db.dhtSites, data.sitesIndex)
    local topChest  = site.topChests[ data.topChestIndex ]

    -- go to the pickup point
    coremove.MoveTo(coremove.GetRelativeLocationUp(topChest.location, 1))

    -- get all items from the chest
    turtle.select(1)
    coreinventory.GetAllItems("down")

    -- asume it's empty and mark it as free
    coredht.SaveData("free", db.dhtRoot, db.dhtSites, data.sitesIndex, "topChests", data.topChestIndex, "status")

    -- make list of items in inventory
    local inventory = coreinventory.GetInventoryDetail()

    -- loop all storage chests and see which we need
    for i, storageChest in ipairs(site.storageChests) do

        -- unused chest?
        if storageChest.status == "free" then

            -- anything left to store?
            local itemName, itemCount = next(inventory.items, nil)

            -- we will use this chest for this item, if any item still present in our inventory
            if itemName ~= nil then

                -- make a reservation for this item
                storageChest.status     = "used"
                storageChest.itemName   = itemName
                storageChest.stackSize  = coreinventory.GetStackSize( itemName )
                storageChest.actual     = 0
                storageChest.virtual    = 0

                -- save info
            else
                -- seems there is nothing left to store
                break
            end
        end

        -- see if this chest matches any of our
        if inventory.items[ storageChest.itemName ] ~= nil then

            -- nice, we have a match, let's store! for now ignore that the chest might be full
            -- move to the chest
            coremove.GoTo(storageChest.location)

            -- dump the stuff
            for slot=1,16 do

                -- anything present in this slot, with the right name?
                if type(inventory.slots[ slot ]) == "table" and inventory.slots[ slot ].itemName == storageChest.itemName then

                    -- select this slot, since it will be used!
                    turtle.select(slot)

                    -- for some math
                    local beforeCount   = turtle.getItemCount()

                    -- transfer!
                    turtle.drop()

                    -- more math
                    local afterCount    = turtle.getItemCount()

                    -- update storage information
                    storageChest.actual     = storageChest.actual   + (beforeCount - afterCount)
                    storageChest.virtual    = storageChest.virtual  + (beforeCount - afterCount)
                    coredht.SaveData(storageChest, db.dhtRoot, db.dhtSites, site.sitesIndex, "storageChests", storageChest.chestIndex)

                    -- this slot is empty now
                    if afterCount == 0 then inventory.slots[ slot ] = nil end

                    -- adjust total present in inventory
                    inventory.items[ storageChest.itemName ] = inventory.items[ storageChest.itemName ] - (beforeCount - afterCount)
                end
            end

            -- all gone?
            if inventory.items[ storageChest.itemName ] <= 0 then inventory.items[ storageChest.itemName ] = nil end

        end
    end

    -- store all the items & update site information
    -- ? done ?
end

function RetrieveItems_Task(data)
    -- variables
    local site          = coredht.GetData(db.dhtRoot, db.dhtSites, data.sitesIndex)
    local itemList      = data.itemList
    local dropLocation  = data.dropLocation

    coreutils.WriteToLog("data")
    coreutils.WriteToLog(data)

    -- get to work
    turtle.select(1)
    coremove.MoveTo(site.entryLocation)

    -- loop the storage chests to see if there is anything we need
    for chestIndex, storageChest in ipairs(site.storageChests) do

        -- unused chest?
        local itemName  = storageChest.itemName

        if storageChest.status == "used" and storageChest.actual > 0 and itemList[ itemName ] ~= nil and itemList[ itemName ] > 0 then

            -- nice, we have a match, let's get what we need!
            -- move to the chest
            coremove.GoTo(storageChest.location)

            -- how much can we grab?
            local toSuck    = math.min(storageChest.actual, itemList[ itemName ], storageChest.stackSize)

            -- keep working while usefull
            while toSuck > 0 do

                -- suck this amount
                turtle.suck( toSuck )

                -- update values
                storageChest.actual     = storageChest.actual               - toSuck
                storageChest.virtual    = storageChest.virtual              - toSuck
                itemList[ itemName ]    = itemList[ itemName ]              - toSuck

                -- storage cheset updated, write to dht
                coredht.SaveData(storageChest, db.dhtRoot, db.dhtSites, site.sitesIndex, "storageChests", chestIndex)

                -- recalculate
                toSuck    = math.min(storageChest.actual, itemList[ storageChest.itemName ], storageChest.stackSize)
            end
        end
    end

    -- time to drop our stuff
    coremove.MoveTo(coremove.GetRelativeLocationUp(dropLocation, 1))
    local cargoList = coreinventory.DropAllItems("down")

    -- done
    return cargoList
end

-- needs some improvements to support more then 16 stacks in a box
function CheckIntegrity_Task(data)
    -- variables
    local site          = coredht.GetData(db.dhtRoot, db.dhtSites, data.sitesIndex)

    -- get into position!
    coremove.MoveTo(site.entryLocation)

    -- loop the storage chests to see if there is anything we need
    for chestIndex, storageChest in ipairs(site.storageChests) do

        -- variables
        local changed = false

        -- move to the chest
        coremove.GoTo(storageChest.location)

        -- get all items from the chest
        turtle.select(1)
        coreinventory.GetAllItems("front")

        -- what do we have?
        local inventory = coreinventory.GetInventoryDetail()

        -- asume items in inventory slot 1 is what this chest is for
        local itemName  = nil
        if type(inventory) == "table" and type(inventory.slots) == "table" and type(inventory.slots[1]) == "table" then itemName = inventory.slots[1].itemName end

        -- set the name and status if we have items
        if type(itemName) == "string" and (storageChest.status ~= "used" or storageChest.itemName ~= itemName) then

            -- this one is used
            storageChest.status     = "used"
            storageChest.itemName   = itemName

            -- so we changed
            changed = true
        end

        -- how many?
        local itemCount = 0
        if type(inventory) == "table" and type(inventory.items) == "table" and type(inventory.items[ itemName ]) == "number" then itemCount = inventory.items[ itemName ] end

        -- set the actual value, ignore virtual for now
        if storageChest.actual ~= itemCount then

            -- set the correct value
            storageChest.actual = itemCount

            -- we changed this!
            changed = true
        end

        -- do we need to store this? then we must safe!
        if changed then coredht.SaveData(storageChest, db.dhtRoot, db.dhtSites, site.sitesIndex, "storageChests", storageChest.chestIndex) end

        -- put the stuff back if we have any
        coreinventory.DropAllItems("front")
    end

    -- done, move out of the silo
    coremove.MoveTo(site.entryLocation)
end
