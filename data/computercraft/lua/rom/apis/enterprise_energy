local db = {
    dhtRoot         = "enterprise_energy",
    dhtParameters   = "fuelParameters",
}

--[[
    The Energy enterprise offers services for handling energy (fuel).
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function FuelTurtleToLevelIfNeeded_ASrv(serviceData, callback, callbackData)
    --[[
        This public async service ensures a turtle gets fuelled (if needed) to satisfy to current minimum fuel level.

        Return value:
            nil

        Async service return value (to callback):
                                            - (table)
                success                     - (boolean) whether the service executed successfully

        Parameters:
            serviceData                     - (table) data about this service
                turtleId                    - (number) id of the turtle
                turtleFuelLevel             - (number) (current) fuel level of turtle
                ingredientsSupplierLocator  - (URL) locating where the fuel ingredients can be retrieved
                assignmentsPriorityKey      - (string) priorityKey that should be set for all assignments triggered by this service
            callback                        - (string) name of function to call once service is ready
            callbackData                    - (table) data to supply to callback function
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_energy.FuelTurtleToLevelIfNeeded_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local turtleId = serviceData.turtleId
    if type(turtleId) ~= "number" then corelog.Error("enterprise_energy.FuelTurtleToLevelIfNeeded_ASrv: Invalid turtleId") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local turtleFuelLevel = serviceData.turtleFuelLevel
    if type(turtleFuelLevel) ~= "number" then corelog.Error("enterprise_energy.FuelTurtleToLevelIfNeeded_ASrv: Invalid turtleFuelLevel") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local ingredientsSupplierLocator = url.URLClass:new(serviceData.ingredientsSupplierLocator)
    if type(ingredientsSupplierLocator) ~= "table" then corelog.Error("enterprise_energy.FuelTurtleToLevelIfNeeded_ASrv: Invalid ingredientsSupplierLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = serviceData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_energy.FuelTurtleToLevelIfNeeded_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_energy.FuelTurtleToLevelIfNeeded_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- ensure enterprise has a key in the dht
    if coredht.GetData(db.dhtRoot) == nil then
        -- create the entry
        coredht.SaveData({}, db.dhtRoot)

        -- reset parameters
        ResetParameters()
    end

    -- get parameters
    local parameters = coredht.GetData(db.dhtRoot, db.dhtParameters)

    -- ToDo: (somehow) detect if already a request was made to fuel this turtle (i.e. to provent floading of fuel attempts)

    -- is fueling necessary?
    local minFuelLevel = parameters.minFuelLevel
    if turtleFuelLevel < minFuelLevel then
        -- determine targetFuelNeed
        local targetFuelLevel = parameters.targetFuelLevel
        local targetFuelNeed = targetFuelLevel - turtleFuelLevel

        -- determine fuelItemsNeed
        local fuelItemsNeed = FuelItemsForFuel(targetFuelNeed)

        -- (re)fuel turtle
        local refuelServiceData = {
            turtleId                    = turtleId,
            fuelItems                   = fuelItemsNeed,
            ingredientsSupplierLocator  = ingredientsSupplierLocator,
            assignmentsPriorityKey      = assignmentsPriorityKey,
        }
        corelog.WriteToLog("* Refuelling turtle(id="..turtleId..") from "..turtleFuelLevel.." to "..targetFuelLevel.." fuel *")
        return Refuel_ASrv(refuelServiceData, callback, callbackData)
    else
--        corelog.WriteToLog("* Current fuellevel(="..turtleFuelLevel..") of turtle(id="..turtleId..") already above minimum(="..minFuelLevel.. ") level. *")
        return coreutils.DoCallback(callback, callbackData, {success = true})
    end
end

function TakeNoticeOfAssignmentFuelNeeded_SSrv(serviceData)
    --[[
        This public sync service takes notice of fuel that is expected to be needed (soon) by a turtle for an assignment.

        The enterprise uses it to possibly update it's parameters. For example it checks if the minimum and target fuel level should be changed to
        accomodate for the possibly needed fuel.
                
            Note: that (? I think) it is best this service is still a sync service although the steps triggered by it might be async.
            The reason to do this is that I think it's best coreassignment (which calls this service) should continue irrespective
            of if the levels need to be changed.
        
        Return value:
                                        - (table)
                success                 - (boolean) whether the service executed successfully

        Parameters:
            serviceData                 - (table) data about this service
                assignmentFuelNeed      - (number) fuel expected to be needed for an assignment
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_energy.TakeNoticeOfFuelNeeded_SSrv: Invalid serviceData") return {success = false} end
    local assignmentFuelNeed = serviceData.assignmentFuelNeed
    if type(assignmentFuelNeed) ~= "number" then corelog.Error("enterprise_energy.TakeNoticeOfFuelNeeded_SSrv: Invalid assignmentFuelNeed") return {success = false} end

    -- get parameters
    local parameters = coredht.GetData(db.dhtRoot, db.dhtParameters)

    -- determine if new highestFuelNeed_Assignment
    local fuelNeedIncreased = false
    if assignmentFuelNeed > parameters.highestFuelNeed_Assignment then
        corelog.WriteToLog("* Updating highestFuelNeed_Assignment from "..parameters.highestFuelNeed_Assignment.." to "..assignmentFuelNeed.." *")
        parameters.highestFuelNeed_Assignment = assignmentFuelNeed
        fuelNeedIncreased = true
    end

    -- determine if new highestFuelNeed_ProduceFuel
    local fuelNeed_ProduceFuel = FuelNeedTo_ProduceFuel(parameters.highestFuelNeed_Assignment)
    if not fuelNeed_ProduceFuel then corelog.Error("enterprise_energy.TakeNoticeOfFuelNeeded_SSrv: Failed obtaining fuelNeed_ProduceFuel") return {success = false} end
    if fuelNeed_ProduceFuel > parameters.highestFuelNeed_ProduceFuel then
        corelog.WriteToLog("* Updating highestFuelNeed_ProduceFuel from "..parameters.highestFuelNeed_ProduceFuel.." to "..fuelNeed_ProduceFuel.." *")
        parameters.highestFuelNeed_ProduceFuel = fuelNeed_ProduceFuel
        fuelNeedIncreased = true
    end

    -- check fuel need is the highest so far
    if fuelNeedIncreased then
        -- determine new levels
        local minFuelLevel             = parameters.highestFuelNeed_Assignment + parameters.highestFuelNeed_ProduceFuel
        corelog.WriteToLog("* Updating minFuelLevel from "..parameters.minFuelLevel.." to "..minFuelLevel.." *")
        parameters.minFuelLevel        = minFuelLevel

        local targetFuelLevel          = parameters.targetMultiplier * minFuelLevel
        corelog.WriteToLog("* Updating targetFuelLevel from "..parameters.targetFuelLevel.." to "..targetFuelLevel.." *")
        parameters.targetFuelLevel     = targetFuelLevel

        -- set levels
        parameters.targetMultiplier    = 2 -- note: this statment should be after first wood chop => hence we can increase this value now (for ever)

        -- save db data
        coredht.SaveData(parameters, db.dhtRoot, db.dhtParameters)

        -- ToDo: implement actions to handle changed levels (e.g. ensuring more fuel is available)
    end

    -- end
    return {success = true}
end

function Refuel_ASrv(serviceData, callback, callbackData)
    --[[
        This public async service (re)fuels a turtle from fuelItems.

        Return value:
            nil

        Async service return value (to callback):
                                            - (table)
                success                     - (boolean) whether the service executed successfully

        Parameters:
            serviceData                     - (table) data about this service
                turtleId                    - (number) id of the turtle to fuel
                fuelItems                   - (table) with one or more items (formatted as an array of [itemName] = itemCount key-value pairs) to fuel with
                ingredientsSupplierLocator  - (URL) locating where ingredients can be retrieved
                assignmentsPriorityKey      - (string) priorityKey that should be set for all assignments triggered by this service
            callback                        - (string) name of function to call once service is ready
            callbackData                    - (table) data to supply to callback function
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_energy.Refuel_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local turtleId = serviceData.turtleId
    if type(turtleId) ~= "number" then corelog.Error("enterprise_energy.Refuel_ASrv: Invalid turtleId") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local fuelItems = serviceData.fuelItems
    if type(fuelItems) ~= "table" then corelog.Error("enterprise_energy.Refuel_ASrv: Invalid fuelItems") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local ingredientsSupplierLocator = url.URLClass:new(serviceData.ingredientsSupplierLocator)
    if type(ingredientsSupplierLocator) ~= "table" then corelog.Error("enterprise_energy.Refuel_ASrv: Invalid ingredientsSupplierLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = serviceData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_energy.Refuel_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_energy.Refuel_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- create project service data
    local turtleToRefuelLocator = enterprise_turtle.GetTurtleLocator_SSrv({turtleId = turtleId}).turtleLocator
    local fuelItemsLocator = ingredientsSupplierLocator:copy()
    fuelItemsLocator:setQuery(coreutils.DeepCopy(fuelItems))
    corelog.WriteToLog("    fuelItemsLocator="..fuelItemsLocator:getURI()..".")
    local refuelTaskData = {
        turtleId    = turtleId,
        fuelItems   = coreutils.DeepCopy(fuelItems),

        priorityKey = assignmentsPriorityKey,
    }
    local buildBlueprintProjectDef = {
        steps   = {
            { stepName = "enterprise_isp.ProvideItemsTo_ASrv", async = true, stepDataDef = {
                { keyDef = "itemsLocator"               , valueSource = 0, keyDefSource = "fuelItemsLocator" },
                { keyDef = "storageLocator"             , valueSource = 0, keyDefSource = "turtleToRefuelLocator" },
                { keyDef = "ingredientsSupplierLocator" , valueSource = 0, keyDefSource = "ingredientsSupplierLocator" },
                { keyDef = "assignmentsPriorityKey"     , valueSource = 0, keyDefSource = "assignmentsPriorityKey" },
            }},
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"           , valueSource = 0, keyDefSource = "refuel_Task" },
                { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "refuelMetaData" },
                { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "refuelTaskData" },
            }},
            { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                { keyDef = "success1"                   , valueSource = 1, keyDefSource = "success" },
                { keyDef = "success2"                   , valueSource = 2, keyDefSource = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , valueSource = 3, keyDefSource = "success" },
        }
    }
    local projectData = {
        fuelItems                   = coreutils.DeepCopy(fuelItems),

        fuelItemsLocator            = fuelItemsLocator,
        turtleToRefuelLocator       = turtleToRefuelLocator,
        ingredientsSupplierLocator  = ingredientsSupplierLocator,

        refuel_Task                 = "role_fuel_worker.Refuel_Task",
        refuelMetaData              = role_fuel_worker.Refuel_MetaData(refuelTaskData),
        refuelTaskData              = refuelTaskData,

        assignmentsPriorityKey      = assignmentsPriorityKey,
    }
    local projectServiceData = {
        projectDef  = buildBlueprintProjectDef,
        projectData = projectData,
    }

    -- start project
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function ResetParameters()
--    corelog.WriteToLog("enterprise_energy: resetting parameters")
    coredht.SaveData({
        highestFuelNeed_Assignment  = 0,
        highestFuelNeed_ProduceFuel = 4,

        minFuelLevel                = 0,

        targetMultiplier            = 1, -- initial value as first wood chop requires (35+1=36 => minFuelLevel = 36+36, and that is the energy we get from first log = 4 planks)
        targetFuelLevel             = 0,

        fuelItemName                = "minecraft:birch_planks",
        fuelItemGain                = 15,
    }, db.dhtRoot, db.dhtParameters)
end

function FuelNeedTo_ProduceFuel(fuelToProduce)
    --[[
        This private sync function determines the minimum fuel needed to produce a certain amount of fuel (with the current default fuel item).

        Return value:
            fuelNeed                - (number) the amount of fuel needed to procure the fuel

        Parameters:
            fuelToProduce           - (number) fuel to produce
    --]]

    -- check input
    if type(fuelToProduce) ~= "number" then corelog.Error("enterprise_energy.FuelNeedTo_ProduceFuel: Invalid fuelToProduce") return 99999 end

    -- check there is fuelToProduce
    if fuelToProduce == 0 then
--        corelog.Warning("enterprise_energy.FuelNeedTo_ProduceFuel: fuelToProduce == 0") 
        return 0
    end

    -- determine fuelItemsLocator
    local fuelItemsNeed = FuelItemsForFuel(fuelToProduce)
    local ingredientsSupplierLocator = GetIngredientsSupplierLocator()
    local fuelItemsLocator = ingredientsSupplierLocator:copy()
    fuelItemsLocator:setQuery(fuelItemsNeed)

    -- determine fuelNeed to produce fuel
    local storageLocator = enterprise_turtle.GetHostLocator_SSrv({ }).hostLocator -- ToDo: consider fuel Storage at some fuel site
    local fuelSupplyServiceData = {
        itemsLocator                = fuelItemsLocator,
        storageLocator              = storageLocator,
        ingredientsSupplierLocator  = ingredientsSupplierLocator,
    }
    local serviceResults = enterprise_isp.NeedsTo_ProvideItemsTo_SSrv(fuelSupplyServiceData)
    if not serviceResults.success then corelog.Error("enterprise_energy.FuelNeedTo_ProduceFuel: Failed obtaining needs for "..fuelItemsLocator:getURI()) return nil end
    local fuelNeedTo_ProduceFuel = serviceResults.fuelNeed

    -- estimate of fuelNeed to move turtle from forest to factory
    local fuelNeedTo_Travel = 0 -- 2*12 -- ToDo: improve (calculate distance between forest and factory)
    -- ToDo: consider changing to travelling to fuel Storage

    -- end
    local fuelNeed = fuelNeedTo_ProduceFuel + fuelNeedTo_Travel
    corelog.WriteToLog("E  fuelNeed="..fuelNeed.." (produce="..fuelNeedTo_ProduceFuel..", travel="..fuelNeedTo_Travel..")")
    return fuelNeed
end

function GetIngredientsSupplierLocator()
     local supplierHostLocator = enterprise_shop.GetHostLocator_SSrv({ }).hostLocator -- ToDo: remove hardcoding enterprise_shop

    return supplierHostLocator
end

function FuelItemsForFuel(fuel)
    -- get parameters
    local parameters = coredht.GetData(db.dhtRoot, db.dhtParameters)

    -- determine fuelItems
    local fuelItemGain = parameters.fuelItemGain
    local fuelItemCount = math.ceil(fuel / fuelItemGain)
    local fuelItemName = parameters.fuelItemName
    local fuelItems = { [fuelItemName] = fuelItemCount }

    -- end
--    corelog.WriteToLog("   fuelItems="..textutils.serialise(fuelItems)..")")
    return fuelItems
end
