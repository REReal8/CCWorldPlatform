local db = {
    dhtRoot         = "enterprise_energy",
    dhtParameters   = "fuelParameters",
}

--[[
    The Energy enterprise offers services for handling energy (fuel).
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function ProvideFuelTo_ASrv(serviceData, callback, callbackData)
    --[[
        This public async service provides fuel to a turtle.

        Return value:
            nil

        Async service return value (to callback):
                                            - (table)
                success                     - (boolean) whether the service executed successfully

        Parameters:
            serviceData                     - (table) data about this service
                turtleId                    - (number) id of the turtle
                fuelAmount                  - (number) fuel amount to provide to turtle
                ingredientsSupplierLocator  - (URL) locating where the fuel ingredients can be retrieved
                assignmentsPriorityKey      - (string) priorityKey that should be set for all assignments triggered by this service
            callback                        - (string) name of function to call once service is ready
            callbackData                    - (table) data to supply to callback function
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_energy.ProvideFuelTo_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local turtleId = serviceData.turtleId
    if type(turtleId) ~= "number" then corelog.Error("enterprise_energy.ProvideFuelTo_ASrv: Invalid turtleId") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local fuelAmount = serviceData.fuelAmount
    if type(fuelAmount) ~= "number" then corelog.Error("enterprise_energy.ProvideFuelTo_ASrv: Invalid fuelAmount") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local ingredientsSupplierLocator = url.URLClass:new(serviceData.ingredientsSupplierLocator)
    if type(ingredientsSupplierLocator) ~= "table" then corelog.Error("enterprise_energy.ProvideFuelTo_ASrv: Invalid ingredientsSupplierLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = serviceData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_energy.ProvideFuelTo_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_energy.ProvideFuelTo_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- ToDo: remove?
    -- ensure enterprise has a key in the dht
    if coredht.GetData(db.dhtRoot) == nil then
        -- create the entry
        coredht.SaveData({}, db.dhtRoot)

        -- reset parameters
        ResetParameters()
    end

    -- determine fuelItemsNeed
    local fuelItemsNeed = FuelItemsForFuel(fuelAmount)

    -- (re)fuel turtle
    local refuelServiceData = {
        turtleId                    = turtleId,
        fuelItems                   = fuelItemsNeed,
        ingredientsSupplierLocator  = ingredientsSupplierLocator,
        assignmentsPriorityKey      = assignmentsPriorityKey,
    }
    corelog.WriteToLog("* Refuelling turtle(id="..turtleId..") with "..fuelAmount.." fuel *")
    Refuel_ASrv(refuelServiceData, callback, callbackData)
end

function TakeNoticeOfAssignmentFuelNeeded_SSrv(serviceData)
    --[[
        This public sync service takes notice of fuel that is expected to be needed (soon) by a turtle for an assignment.

        The enterprise uses it to possibly update it's parameters. For example it checks if the minimum and target fuel level should be changed to
        accomodate for the possibly needed fuel.

            Note: that (? I think) it is best this service is still a sync service although the steps triggered by it might be async.
            The reason to do this is that I think it's best coreassignment (which calls this service) should continue irrespective
            of if the levels need to be changed.

        Return value:
                                        - (table)
                success                 - (boolean) whether the service executed successfully

        Parameters:
            serviceData                 - (table) data about this service
                assignmentFuelNeed      - (number) fuel expected to be needed for an assignment
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_energy.TakeNoticeOfFuelNeeded_SSrv: Invalid serviceData") return {success = false} end
    local assignmentFuelNeed = serviceData.assignmentFuelNeed
    if type(assignmentFuelNeed) ~= "number" then corelog.Error("enterprise_energy.TakeNoticeOfFuelNeeded_SSrv: Invalid assignmentFuelNeed") return {success = false} end

    -- get parameters
    local parameters = coredht.GetData(db.dhtRoot, db.dhtParameters)

    -- determine if new highestFuelNeed_Assignment
    local fuelNeedIncreased = false
    if assignmentFuelNeed > parameters.highestFuelNeed_Assignment then
--        corelog.WriteToLog("* Updating highestFuelNeed_Assignment from "..parameters.highestFuelNeed_Assignment.." to "..assignmentFuelNeed.." *")
        parameters.highestFuelNeed_Assignment = assignmentFuelNeed
        fuelNeedIncreased = true
    end

    -- determine if new highestFuelNeed_ProduceFuel
    local fuelNeed_ProduceFuel = FuelNeedTo_ProduceFuel(parameters.highestFuelNeed_Assignment)
    if not fuelNeed_ProduceFuel then corelog.Error("enterprise_energy.TakeNoticeOfFuelNeeded_SSrv: Failed obtaining fuelNeed_ProduceFuel") return {success = false} end
    if fuelNeed_ProduceFuel > parameters.highestFuelNeed_ProduceFuel then
--        corelog.WriteToLog("* Updating highestFuelNeed_ProduceFuel from "..parameters.highestFuelNeed_ProduceFuel.." to "..fuelNeed_ProduceFuel.." *")
        parameters.highestFuelNeed_ProduceFuel = fuelNeed_ProduceFuel
        fuelNeedIncreased = true
    end

    -- check fuel need is the highest so far
    if fuelNeedIncreased then
        -- update levels
        UpdateFuelLevels()
    end

    -- end
    return {success = true}
end

function FuelNeed_Refuel_Att()
    --[[
        enterprise_energy attribute with the current fuelNeed for refueling.
    --]]

    -- get parameters
    local parameters = coredht.GetData(db.dhtRoot, db.dhtParameters)

    -- determine fuelNeed
    local fuelNeed = 0

    -- determine fuelNeed by current forest
    local forest = enterprise_colonization.GetForest()
    local forestLocation = forest.location
    local fuelNeed_Harvest = enterprise_colonization.FuelNeed_Harvest_Att()
    fuelNeed = fuelNeed + fuelNeed_Harvest

    -- determine fuelNeed for 1 extra tree (to anticipate for fuelNeed in case the forest gets upgraded)
    if parameters.enterpriseLevel > 0 then
        local fuelNeed_ExtraTree = enterprise_colonization.FuelNeedExtraTree_Att()
        fuelNeed = fuelNeed + fuelNeed_ExtraTree
    end

    -- check there is (already) a factory
    local aFactoryExists = enterprise_factory.NumberOfSites_Att() > 0
    if aFactoryExists then
        -- determine fuelNeed by factory
        local items = FuelItemsForFuel(1)
        local fuelNeed_Production = enterprise_factory.FuelNeed_Production_Att(items)
        fuelNeed = fuelNeed + fuelNeed_Production

        -- determine fuelNeed for traveling
        local factoryLocation = enterprise_factory.SiteLocation_Att(items)
        local fuelNeed_ForestFactoryTravel = role_fuel_worker.NeededFuelToFrom(factoryLocation, forestLocation)
        fuelNeed = fuelNeed + fuelNeed_ForestFactoryTravel
    end

    -- end
    return fuelNeed
end

function RefuelAmount_Att()
    --[[
        enterprise_energy attribute with the current refuel amount.
    --]]

    -- get parameters
    local parameters = coredht.GetData(db.dhtRoot, db.dhtParameters)
    local enterpriseLevel = parameters.enterpriseLevel
    if enterpriseLevel == 0 then
        return 60 -- 1 log = 4 planks = 60 fuel
    elseif enterpriseLevel == 1 then
        return 300 -- 1 tree = min 5 logs = 20 planks = 300 fuel
    else
        corelog.Warning("enterprise_energy.RefuelAmount_Att: not (yet) implemented for enterpriseLevel="..enterpriseLevel)
        return 999999
    end
end

function Refuel_ASrv(serviceData, callback, callbackData)
    --[[
        This public async service (re)fuels a turtle from fuelItems.

        Return value:
            nil

        Async service return value (to callback):
                                            - (table)
                success                     - (boolean) whether the service executed successfully

        Parameters:
            serviceData                     - (table) data about this service
                turtleId                    - (number) id of the turtle to fuel
                fuelItems                   - (table) with one or more items (formatted as an array of [itemName] = itemCount key-value pairs) to fuel with
                ingredientsSupplierLocator  - (URL) locating where ingredients can be retrieved
                assignmentsPriorityKey      - (string) priorityKey that should be set for all assignments triggered by this service
            callback                        - (string) name of function to call once service is ready
            callbackData                    - (table) data to supply to callback function
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_energy.Refuel_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local turtleId = serviceData.turtleId
    if type(turtleId) ~= "number" then corelog.Error("enterprise_energy.Refuel_ASrv: Invalid turtleId") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local fuelItems = serviceData.fuelItems
    if type(fuelItems) ~= "table" then corelog.Error("enterprise_energy.Refuel_ASrv: Invalid fuelItems") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local ingredientsSupplierLocator = url.URLClass:new(serviceData.ingredientsSupplierLocator)
    if type(ingredientsSupplierLocator) ~= "table" then corelog.Error("enterprise_energy.Refuel_ASrv: Invalid ingredientsSupplierLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = serviceData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_energy.Refuel_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_energy.Refuel_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- create project service data
    local turtleToRefuelLocator = enterprise_turtle.GetTurtleLocator_SSrv({turtleId = turtleId}).turtleLocator
    local fuelItemsLocator = ingredientsSupplierLocator:copy()
    fuelItemsLocator:setQuery(coreutils.DeepCopy(fuelItems))
--    corelog.WriteToLog("    fuelItemsLocator="..fuelItemsLocator:getURI()..".")
    local refuelTaskData = {
        turtleId    = turtleId,
        fuelItems   = coreutils.DeepCopy(fuelItems),

        priorityKey = assignmentsPriorityKey,
    }
    local buildBlueprintProjectDef = {
        steps   = {
            { stepName = "enterprise_isp.ProvideItemsTo_ASrv", async = true, stepDataDef = {
                { keyDef = "itemsLocator"               , valueSource = 0, keyDefSource = "fuelItemsLocator" },
                { keyDef = "storageLocator"             , valueSource = 0, keyDefSource = "turtleToRefuelLocator" },
                { keyDef = "ingredientsSupplierLocator" , valueSource = 0, keyDefSource = "ingredientsSupplierLocator" },
                { keyDef = "assignmentsPriorityKey"     , valueSource = 0, keyDefSource = "assignmentsPriorityKey" },
            }},
            { stepName = "enterprise_assignmentboard.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "task"                       , valueSource = 0, keyDefSource = "refuel_Task" },
                { keyDef = "metaData"                   , valueSource = 0, keyDefSource = "refuelMetaData" },
                { keyDef = "taskData"                   , valueSource = 0, keyDefSource = "refuelTaskData" },
            }},
            { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                { keyDef = "success1"                   , valueSource = 1, keyDefSource = "success" },
                { keyDef = "success2"                   , valueSource = 2, keyDefSource = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , valueSource = 3, keyDefSource = "success" },
        }
    }
    local projectData = {
        fuelItems                   = coreutils.DeepCopy(fuelItems),

        fuelItemsLocator            = fuelItemsLocator,
        turtleToRefuelLocator       = turtleToRefuelLocator,
        ingredientsSupplierLocator  = ingredientsSupplierLocator,

        refuel_Task                 = "role_fuel_worker.Refuel_Task",
        refuelMetaData              = role_fuel_worker.Refuel_MetaData(refuelTaskData),
        refuelTaskData              = refuelTaskData,

        assignmentsPriorityKey      = assignmentsPriorityKey,
    }
    local projectServiceData = {
        projectDef  = buildBlueprintProjectDef,
        projectData = projectData,
    }

    -- start project
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function ResetParameters()
--    corelog.WriteToLog("enterprise_energy: resetting parameters")
    coredht.SaveData({
        enterpriseLevel             = 0,

        highestFuelNeed_Assignment  = 0,
        highestFuelNeed_ProduceFuel = 4,

        minFuelLevel                = 0,

        targetMultiplier            = 1, -- initial value as first wood chop requires (35+1=36 => minFuelLevel = 36+36, and that is the energy we get from first log = 4 planks)
        targetFuelLevel             = 0,

        fuelItemName                = "minecraft:birch_planks",
        fuelItemGain                = 15,
    }, db.dhtRoot, db.dhtParameters)
end

function UpdateFuelLevels()
    -- get parameters
    local parameters = coredht.GetData(db.dhtRoot, db.dhtParameters)

    -- update minFuelLevel
    local minFuelLevel             = parameters.highestFuelNeed_Assignment + parameters.highestFuelNeed_ProduceFuel
    corelog.WriteToLog("* Updating minFuelLevel from "..parameters.minFuelLevel.." to "..minFuelLevel.." *")
    parameters.minFuelLevel        = minFuelLevel

    -- update targetFuelLevel
    local targetFuelLevel          = parameters.targetMultiplier * minFuelLevel
--        corelog.WriteToLog("* Updating targetFuelLevel from "..parameters.targetFuelLevel.." to "..targetFuelLevel.." *")
    parameters.targetFuelLevel     = targetFuelLevel

    -- update targetMultiplier
    parameters.targetMultiplier    = 2 -- note: this statment should be after first wood chop => hence we can increase this value now (for ever)
    parameters.enterpriseLevel     = 1

    -- save parameters
    coredht.SaveData(parameters, db.dhtRoot, db.dhtParameters)

    -- ToDo: implement actions to handle changed levels (e.g. ensuring more fuel is available)
end

function FuelNeedTo_ProduceFuel(fuelToProduce)
    --[[
        This private sync function determines the minimum fuel needed to produce a certain amount of fuel (with the current default fuel item).

        Return value:
            fuelNeed                - (number) the amount of fuel needed to procure the fuel

        Parameters:
            fuelToProduce           - (number) fuel to produce
    --]]

    -- check input
    if type(fuelToProduce) ~= "number" then corelog.Error("enterprise_energy.FuelNeedTo_ProduceFuel: Invalid fuelToProduce") return 99999 end

    -- check there is fuelToProduce
    if fuelToProduce == 0 then
--        corelog.Warning("enterprise_energy.FuelNeedTo_ProduceFuel: fuelToProduce == 0")
        return 0
    end

    -- determine fuelItemsLocator
    local fuelItemsNeed = FuelItemsForFuel(fuelToProduce)
    local ingredientsSupplierLocator = GetIngredientsSupplierLocator()
    local fuelItemsLocator = ingredientsSupplierLocator:copy()
    fuelItemsLocator:setQuery(fuelItemsNeed)

    -- determine fuelNeed to produce fuel
    local storageLocator = enterprise_turtle.GetHostLocator_SSrv({ }).hostLocator -- ToDo: consider fuel Storage at some fuel site
    local fuelSupplyServiceData = {
        itemsLocator                = fuelItemsLocator,
        storageLocator              = storageLocator,
        ingredientsSupplierLocator  = ingredientsSupplierLocator,
    }
    local serviceResults = enterprise_isp.NeedsTo_ProvideItemsTo_SSrv(fuelSupplyServiceData)
    if not serviceResults.success then corelog.Error("enterprise_energy.FuelNeedTo_ProduceFuel: Failed obtaining needs for "..fuelItemsLocator:getURI()) return nil end
    local fuelNeed_ToProduceFuel = serviceResults.fuelNeed

    -- estimate of fuelNeed to move turtle from forest to factory
    local fuelNeed_ToTravel = 0 -- 2*12 -- ToDo: improve (calculate distance between forest and factory)
    -- ToDo: consider changing to travelling to fuel Storage

    -- end
    local fuelNeed = fuelNeed_ToProduceFuel + fuelNeed_ToTravel
--    corelog.WriteToLog("E  fuelNeed="..fuelNeed.." (produce="..fuelNeed_ToProduceFuel..", travel="..fuelNeed_ToTravel..")")
    return fuelNeed
end

function GetIngredientsSupplierLocator()
     local supplierHostLocator = enterprise_shop.GetHostLocator_SSrv({ }).hostLocator -- ToDo: remove hardcoding enterprise_shop

    return supplierHostLocator
end

function FuelItemsForFuel(fuel)
    -- get parameters
    local parameters = coredht.GetData(db.dhtRoot, db.dhtParameters)

    -- determine fuelItems
    local fuelItemGain = parameters.fuelItemGain
    local fuelItemCount = math.ceil(fuel / fuelItemGain)
    local fuelItemName = parameters.fuelItemName
    local fuelItems = { [fuelItemName] = fuelItemCount }

    -- end
--    corelog.WriteToLog("   fuelItems="..textutils.serialise(fuelItems)..")")
    return fuelItems
end
