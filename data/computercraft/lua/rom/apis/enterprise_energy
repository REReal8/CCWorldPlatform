local db = {
    dhtRoot         = "enterprise_energy",
    dhtParameters   = "fuelParameters",
}

--[[
    The Energy enterprise offers services for handling energy (fuel).
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function FuelTurtleToLevelIfNeeded_ASrv(serviceData, callback, callbackData)
    --[[
        This public async service ensures a turtle gets fuelled (if needed) to satisfy to current minimum fuel level.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully

        Parameters:
            serviceData                 - (table) data about this service
                turtleId                - (number) id of the turtle
                turtleFuelLevel         - (number) (current) fuel level of turtle
                ingredientsHostLocator  - (URL) locating where the fuel ingredients can be retrieved
                assignmentsPriorityKey  - (string) priorityKey that should be set for all assignments triggered by this service
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_energy.FuelTurtleToLevelIfNeeded_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local turtleId = serviceData.turtleId
    if type(turtleId) ~= "number" then corelog.Error("enterprise_energy.FuelTurtleToLevelIfNeeded_ASrv: Invalid turtleId") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local turtleFuelLevel = serviceData.turtleFuelLevel
    if type(turtleFuelLevel) ~= "number" then corelog.Error("enterprise_energy.FuelTurtleToLevelIfNeeded_ASrv: Invalid turtleFuelLevel") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local ingredientsHostLocator = url.URLClass:new(serviceData.ingredientsHostLocator)
    if type(ingredientsHostLocator) ~= "table" then corelog.Error("enterprise_energy.FuelTurtleToLevelIfNeeded_ASrv: Invalid ingredientsHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = serviceData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_energy.FuelTurtleToLevelIfNeeded_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_energy.FuelTurtleToLevelIfNeeded_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- get parameters
    local parameters = coredht.GetData(db.dhtRoot, db.dhtParameters)

    -- ToDo: (somehow) detect if already a request was made to fuel this turtle (i.e. to provent floading of fuel attempts)

    -- is fueling necessary?
    local minFuelLevel = parameters.minTurtleFuelLevel
    if turtleFuelLevel < minFuelLevel then
        -- determine targetFuelNeeded
        local targetFuelLevel = parameters.targetTurtleFuelLevel
        local targetFuelNeeded = targetFuelLevel - turtleFuelLevel

        -- determine fuelItemsNeeded
        local fuelItemGain = parameters.fuelItemGain
        local fuelItemNeeded = math.ceil(targetFuelNeeded / fuelItemGain)
        local fuelItemName = parameters.fuelItemName
        local fuelItemsNeeded = { [fuelItemName] = fuelItemNeeded }

        -- (re)fuel turtle
        local refuelServiceData = {
            turtleId                = turtleId,
            fuelItems               = coreutils.DeepCopy(fuelItemsNeeded),
            ingredientsHostLocator  = ingredientsHostLocator,
            assignmentsPriorityKey  = assignmentsPriorityKey,
        }
        corelog.WriteToLog("* Refuelling turtle(id="..turtleId..") from "..turtleFuelLevel.." to "..targetFuelLevel.." fuel *")
        return Refuel_ASrv(refuelServiceData, callback, callbackData)
    else
--        corelog.WriteToLog("* Current fuellevel(="..turtleFuelLevel..") of turtle(id="..turtleId..") already above minimum(="..minFuelLevel.. ") level. *")
        return coreutils.DoCallback(callback, callbackData, {success = true})
    end
end

function TakeNoticeOfFuelNeeded_SSrv(serviceData)
    --[[
        This public sync service takes notice of fuel that is expected to be needed (soon) by a turtle.

        The enterprise uses it to possibly update it's parameters. For example it checks if the minimum and target fuel level should be changed to
        accomodate for the possibly needed fuel.
                
            Note: that (? I think) it is best this service is still a sync service although the steps triggered by it might be async.
            The reason to do this is that I think it's best coreassignment (which calls this service) should continue irrespective
            of if the levels need to be changed.
        
        Return value:
                                        - (table)
                success                 - (boolean) whether the service executed successfully

        Parameters:
            serviceData                 - (table) data about this service
                fuelNeeded              - (number) fuel expected to be needed
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_energy.TakeNoticeOfFuelNeeded_SSrv: Invalid serviceData") return {success = false} end
    local fuelNeeded = serviceData.fuelNeeded
    if type(fuelNeeded) ~= "number" then corelog.Error("enterprise_energy.TakeNoticeOfFuelNeeded_SSrv: Invalid fuelNeeded") return {success = false} end

    -- ensure enterprise has a key in the dht
    if coredht.GetData(db.dhtRoot) == nil then
        -- create the entry
        coredht.SaveData({}, db.dhtRoot)

        -- reset parameters
        ResetParameters()
    end

    -- get parameters
    local parameters = coredht.GetData(db.dhtRoot, db.dhtParameters)

    -- check fuel needed is the highest so far
    if fuelNeeded > parameters.highestFuelNeed then
        -- determine new levels
        local minFuelLevel = fuelNeeded + parameters.bufferForProcuringFuel
        local targetFuelLevel = parameters.targetMultiplier * minFuelLevel

        -- set levels
        corelog.WriteToLog("* Updating minTurtleFuelLevel(="..minFuelLevel..") and targetTurtleFuelLevel(id="..targetFuelLevel..") because new(="..fuelNeeded..") highestFuelNeed(="..parameters.highestFuelNeed.. ") level. *")
        parameters.highestFuelNeed          = fuelNeeded
        parameters.minTurtleFuelLevel       = minFuelLevel
        parameters.targetTurtleFuelLevel    = targetFuelLevel

        -- save db data
        coredht.SaveData(parameters, db.dhtRoot, db.dhtParameters)

        -- ToDo: implement actions to handle changed levels (e.g. ensuring more fuel is available)
    end

    -- end
    return {success = true}
end

function Refuel_ASrv(serviceData, callback, callbackData)
    --[[
        This public async service (re)fuels a turtle from fuelItems.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully

        Parameters:
            serviceData                 - (table) data about this service
                turtleId                - (number) id of the turtle to fuel
                fuelItems               - (table) with one or more items (formatted as an array of [itemName] = itemCount key-value pairs) to fuel with
                ingredientsHostLocator  - (URL) locating where the fuel ingredients can be retrieved
                assignmentsPriorityKey  - (string) priorityKey that should be set for all assignments triggered by this service
            callback                    - (string) name of function to call once service is ready
            callbackData                - (table) data to supply to callback function
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_energy.Refuel_ASrv: Invalid serviceData") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local turtleId = serviceData.turtleId
    if type(turtleId) ~= "number" then corelog.Error("enterprise_energy.Refuel_ASrv: Invalid turtleId") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local fuelItems = serviceData.fuelItems
    if type(fuelItems) ~= "table" then corelog.Error("enterprise_energy.Refuel_ASrv: Invalid fuelItems") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local ingredientsHostLocator = url.URLClass:new(serviceData.ingredientsHostLocator)
    if type(ingredientsHostLocator) ~= "table" then corelog.Error("enterprise_energy.Refuel_ASrv: Invalid ingredientsHostLocator") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    local assignmentsPriorityKey = serviceData.assignmentsPriorityKey
    if assignmentsPriorityKey and type(assignmentsPriorityKey) ~= "string" then corelog.Error("enterprise_energy.Refuel_ASrv: Invalid assignmentsPriorityKey") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    if type(callback) ~= "string" then corelog.Error("enterprise_energy.Refuel_ASrv: Invalid callback function") return coreutils.DoCallback(callback, callbackData, {success = false}) end
    callbackData = callbackData or {}

    -- create project service data
    local turtleToRefuelLocator = enterprise_turtle.GetTurtleLocator_SSrv({turtleId = turtleId}).turtleLocator
    local ingredientsItemsLocator = ingredientsHostLocator:copy()
    ingredientsItemsLocator:setQuery(coreutils.DeepCopy(fuelItems))
    local refuelTaskData = {
        turtleId    = turtleId,
        fuelItems   = coreutils.DeepCopy(fuelItems),

        priorityKey = assignmentsPriorityKey,
    }
    local buildBlueprintProjectDef = {
        steps   = {
            { stepName = "enterprise_isp.TransferItemsFromTo_ASrv", async = true, stepDataDef = {
                { keyDef = "sourceItemsLocator"     , valueSource = 0, keyDefSource = "ingredientsItemsLocator" },
                { keyDef = "destinationHostLocator" , valueSource = 0, keyDefSource = "turtleToRefuelLocator" },
                { keyDef = "assignmentsPriorityKey" , valueSource = 0, keyDefSource = "assignmentsPriorityKey" },
            }},
            { stepName = "enterprise_turtle.DoAssignment_ASrv", async = true, stepDataDef = {
                { keyDef = "taskFunctionName"       , valueSource = 0, keyDefSource = "refuel_Task" },
                { keyDef = "metaData"               , valueSource = 0, keyDefSource = "refuelMetaData" },
                { keyDef = "taskData"               , valueSource = 0, keyDefSource = "refuelTaskData" },
            }},
            { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                { keyDef = "success1"               , valueSource = 1, keyDefSource = "success" },
                { keyDef = "success2"               , valueSource = 2, keyDefSource = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , valueSource = 3, keyDefSource = "success" },
        }
    }
    local projectData = {
        fuelItems                   = coreutils.DeepCopy(fuelItems),

        ingredientsItemsLocator     = ingredientsItemsLocator,
        turtleToRefuelLocator       = turtleToRefuelLocator,

        refuel_Task                 = "role_fuel_worker.Refuel_Task",
        refuelMetaData              = role_fuel_worker.Refuel_MetaData(refuelTaskData),
        refuelTaskData              = refuelTaskData,

        assignmentsPriorityKey      = assignmentsPriorityKey,
    }
    local projectServiceData = {
        projectDef  = buildBlueprintProjectDef,
        projectData = projectData,
    }

    -- start project
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function ResetParameters()
    coredht.SaveData({
        highestFuelNeed         = 0,
        minTurtleFuelLevel      = 0,
        targetTurtleFuelLevel   = 0,
        bufferForProcuringFuel  = 5, -- ToDo: consider changing to 4
        targetMultiplier        = 2, -- consider changing to 1.5 *, as first wood chop requires (35+1+4=40, * 1.5 = 60, and that is the energy we get from first log = 4 planks)

        fuelItemName            = "minecraft:birch_planks",
        fuelItemGain            = 15,
    }, db.dhtRoot, db.dhtParameters)
end
