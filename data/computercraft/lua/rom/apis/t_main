local db = {}

-- short hand for current test to run
function T_()
    corelog.WriteToLog("Running T_()")
    print("!")

--    T_enterprise_storage_buildAndStartNewSite()
--    T_enterprise_projects()
--    T_role_builder_MetaDatas()
--    T_enterpise_colonization()
--    role_settler.BuildSiloL0()
--    T_enterprise_construction1()
--    T_enterprise_construction2()
--    T_role_builder()
--    T_enterprise_test()
--    T_MetaDataConditionsMet()
end

function T_enterprise_storage_buildAndStartNewSite()
    enterprise_storage.BuildAndStartNewSite({location={x=12, y=12, z= 1, dx=0, dy=1}, type="silo", siloType="basic", topChests=2, layers=2}, "coreassignment.Dummy_Callback", {})
end

function T_enterpise_colonization()
    -- test CreateNewWorld
    corelog.WriteToLog("# Test CreateNewWorld")
    local callbackFunction = "t_main.GoHomeCallBack"
    local callbackData = {}

    corelog.WriteToLog("T_enterpise_colonization calling CreateNewWorld("..callbackFunction..", "..textutils.serialize(callbackData)..")")
    enterprise_colonization.CreateNewWorld(callbackFunction, callbackData)
end

function End(assignmentId)
    coreassignment.EndAssignment(assignmentId)
end

local testStartLocation  = {x= 0, y= 0, z= 1, dx=0, dy=1}

local testBuildPattern1 = {
    deltaX      = 4,
    deltaY      = 6,
    objectList  = {
        { x = 0, y = 3,                 block = "minecraft:torch"},
        { x = 2, y = 5, dx = 0, dy = 1, block = "minecraft:chest"},
        { x = 3, y = 0,                 block = "minecraft:torch"},
    },
    clearRemainingSpace = true,
}

local testBuildPattern2 = {
    deltaX      = 3,
    deltaY      = 3,
    objectList  = {
        { x = 0, y = 0, dx =-1, dy = 0, block = "minecraft:chest"},
        { x = 0, y = 1, dx =-1, dy = 0, block = "minecraft:chest"},

        { x = 0, y = 2, dx = 0, dy = 1, block = "minecraft:chest"},
        { x = 1, y = 2, dx = 0, dy = 1, block = "minecraft:chest"},

        { x = 1, y = 0, dx = 0, dy =-1, block = "minecraft:chest"},
        { x = 2, y = 0, dx = 0, dy =-1, block = "minecraft:chest"},

        { x = 2, y = 1, dx = 1, dy = 0, block = "minecraft:chest"},
        { x = 2, y = 2, dx = 1, dy = 0, block = "minecraft:chest"},
    },
    clearRemainingSpace = true,
}

local testBuildPattern3 = {
    deltaX      = 6,
    deltaY      = 6,
    objectList  = {
        { x = 0, y = 3,                 block = "minecraft:torch"},
        { x = 2, y = 5, dx = 0, dy = 1, block = "minecraft:chest"},
        { x = 3, y = 0,                 block = "minecraft:torch"},
        { x = 4, y = 5, dx = 0, dy = 1, block = "minecraft:chest"},
    },
    clearRemainingSpace = true,
}

local testBuildPattern4 = {
    deltaX      = 1,
    deltaY      = 1,
    objectList  = {
    },
    clearRemainingSpace = true,
}

local testBlueprint1 = {
    layerList = {
        { startpoint = { x= 0, y= 0, z=  0}, buildFromAbove  = true, pattern = testBuildPattern3},
        { startpoint = { x= 3, y= 3, z= -1}, buildFromAbove  = false, pattern = testBuildPattern4},
        { startpoint = { x= 2, y= 2, z= -2}, buildFromAbove  = false, pattern = testBuildPattern2},
        { startpoint = { x= 2, y= 2, z= -3}, buildFromAbove  = false, pattern = role_builder.CopyPattern(testBuildPattern2)}
    },
    escapeSequence = {
        { x= 3, y= 3, z=  1},
    }
}

local testBlueprint2 = {
    layerList = {
        { startpoint = { x= 0, y= 0, z=  0}, buildFromAbove  = true, pattern = testBuildPattern1},
        { startpoint = { x= 3, y= 3, z= -1}, buildFromAbove  = false, pattern = testBuildPattern2},
    },
    escapeSequence = {
        { x= 3, y= 3, z=  1},
    }
}

function T_enterprise_construction1()
    -- test service 1
    corelog.WriteToLog("# Test 1")
    local buildData = {startpoint = testStartLocation, buildFromAbove = true, pattern = testBuildPattern1}
    local callbackFunction = "t_main.Func1_Callback"

    corelog.WriteToLog("T_enterprise_construction calling BuildRectangularPattern("..textutils.serialise(buildData)..", "..callbackFunction..")")
    enterprise_construction.BuildRectangularPattern(buildData, callbackFunction)
end

function T_enterprise_construction2()
    -- test service 2
    corelog.WriteToLog("# Test 2")
    local blueprintBuildData = {blueprintStartpoint = coremove.GetRelativeLocation(testStartLocation, 6, 0, 0), blueprint = testBlueprint1}
    local callbackFunction = "t_main.Func1_Callback"
    local callbackArgumentTable = {}
    corelog.WriteToLog("T_enterprise_construction calling BuildBlueprint("..textutils.serialise(blueprintBuildData)..", "..callbackFunction..")")
    enterprise_construction.BuildBlueprint(blueprintBuildData, callbackFunction, callbackArgumentTable)
end

function T_role_builder_MetaDatas()
    local buildData = {startpoint = testStartLocation, buildFromAbove = true, pattern = testBuildPattern1}
    local blueprintBuildData = {blueprintStartpoint = coremove.GetRelativeLocation(testStartLocation, 6, 0, 0), blueprint = testBlueprint2}

    corelog.WriteToLog("BuildRectangularPattern_MetaData => "..textutils.serialize(role_builder.BuildRectangularPattern_MetaData(buildData)))
    corelog.WriteToLog("BuildBlueprint_MetaData => "..textutils.serialize(role_builder.BuildBlueprint_MetaData(blueprintBuildData)))
end

function T_role_builder()
    local buildData = {startpoint = testStartLocation, buildFromAbove = true, pattern = testBuildPattern1}

    role_builder.BuildRectangularPattern_Task(buildData)
end

function T_MetaDataConditionsMet()
    local now = coreutils.UniversalTime()
    local metaData = {
        startTime = now + 1000,
        needTurtle = true,
        needTool = true,
        fuelNeeded = 500,
--        fuelNeeded = 50000,
        location = nil,
        itemsNeeded = {
            {itemName = "minecraft:torch", itemCount = 2},
            {itemName = "minecraft:chest", itemCount = 2},
        }
    }

    -- test startTime
    corelog.WriteToLog("# Test StartTime condition")
    if coreassignment.MetaDataConditionsMet(metaData) then
        corelog.Error("t_main.T_MetaDataConditionsMet: Assignment in the future (="..metaData.startTime..") (now = "..now..") not skipped!")
    end
    metaData.startTime = now

    -- test other conditions
    corelog.WriteToLog("# Test Other conditions")
    if not coreassignment.MetaDataConditionsMet(metaData) then
       corelog.WriteToLog("t_main.T_MetaDataConditionsMet: Not all conditions met!")
    end
end

function T_enterprise_test()
    -- init
    local testArg = 20

    -- test service 1
    corelog.WriteToLog("# Test 1")
    local testResult = enterprise_test.TestPureLogicService(testArg)
    corelog.WriteToLog("  TestPureLogicService("..testArg..") => " .. testResult .. ".")

    -- test service 2
    corelog.WriteToLog("# Test 2")
    enterprise_test.TestServiceWithAssignment(testArg)

    -- test service 3
    corelog.WriteToLog("# Test 3")
    local callbackFunction = "t_main.Func1_Callback"
    enterprise_test.TestServiceWithAssignmentAndCallback(testArg, callbackFunction)

    -- test service 4
    corelog.WriteToLog("# Test 4")
    local callbackArgumentTable = {"calbackArg1"}
    enterprise_test.TestServiceWithAssignmentAndCallbackAndArguments(testArg, callbackFunction, callbackArgumentTable)
end

function T_enterprise_projects()
    -- init
    local testArgValue = 20
    local projectDefinition = {
        services    = {
            { serviceName = "enterprise_test.TestPureLogicService", async = false, input = {
                { keyName = "testArg1", valueSource = 0, sourceKey = "testArgSource" },
            }},
            { serviceName = "enterprise_test.TestServiceWithAssignmentAndCallbackAndArguments", async = true, input = {
                { keyName = "testArg2", valueSource = 0, sourceKey = "testArgSource" },
            }},
            { serviceName = "enterprise_test.TestPureLogicService", async = false, input = {
                { keyName = "testArg3", valueSource = 0, sourceKey = "testArgSource" },
            }},
        },
        returnData  = {
            { keyName = "testBArg0", valueSource = 0, sourceKey = "testArgSource" },
            { keyName = "testBArg1", valueSource = 1, sourceKey = "testArg1" },
            { keyName = "testBArg2", valueSource = 2, sourceKey = "testArg2" },
            { keyName = "testBArg3", valueSource = 3, sourceKey = "testArg3" },
        }
    }
    local projectData = { testArgSource = testArgValue }
    local callbackFunction = "t_main.Func1_Callback"
    local callbackData = { "rootCallBackData" }

    enterprise_projects.StartProject(projectDefinition, projectData, callbackFunction, callbackData)
end

function Func1_Callback(callbackArgumentTable, taskResult)
    corelog.WriteToLog("t_main.Func1_Callback("..textutils.serialise(callbackArgumentTable)..", "..textutils.serialise(taskResult)..") called")
end

function GoHomeCallBack(callbackArgumentTable, taskResult)
    corelog.WriteToLog("t_main.GoHomeCallBack("..textutils.serialise(callbackArgumentTable)..", "..textutils.serialise(taskResult)..") called")

    GoHome()
end

function BirchGrow()
    -- zorg dat er een kist onder de turtle staat met een paar saplings. De turtle moet een modem (links) en een diamond axe (rechts of inventory) hebben

    local saplings
    local logs
    local sticks

    local growTime
    local fuelUsage
    local harvestTime

    -- quip the axe / hatchet
    coreinventory.Equip("minecraft:diamond_axe")

    -- remove the ground under us, usefull for crafting later
    --turtle.digDown()

    -- plant the sappling
    turtle.suckDown(1)
    coreinventory.SelectItem("minecraft:birch_sapling")
    turtle.place()

    -- endless
    while true do
        -- sepling just planted, record the time
        growTime = coreutils.UniversalTime()

        -- wait for a tree
        local has_block, data
        while not has_block or type(data) ~= "table" or data.name ~= "minecraft:birch_log" do
            -- ff wachten
            os.sleep(0.25)

            -- opnieuw kijken
            has_block, data = turtle.inspect()
        end

        -- grown!
        growTime = coreutils.UniversalTime() - growTime

        -- move into position (don't count this step as harvesting)
        coremove.Up()
        fuelUsage   = turtle.getFuelLevel()
        harvestTime = coreutils.UniversalTime()

        -- boom omhakken
        role_forester.KapBoom()

        -- klaar met omhakken, wat hebben we geleerd?
        fuelUsage   = fuelUsage                 - turtle.getFuelLevel()
        harvestTime = coreutils.UniversalTime() - harvestTime

        -- terug naar onze plek
        coremove.Backward()
        coremove.Down()

        -- inventory tellen
        saplings    = coreinventory.CountItem("minecraft:birch_sapling") - 1
        logs        = coreinventory.CountItem("minecraft:birch_log")
        sticks      = coreinventory.CountItem("minecraft:stick")

        -- sapling in the chest
        coreinventory.DropAll("minecraft:birch_sapling", "down")

        -- use as fuel what we can
        for slot=1,16 do turtle.select(slot) turtle.refuel() end

        -- clean inventory
        coreinventory.DropAllItems("down")

        -- save the data
        coredht.SaveData({
            saplings    = saplings,
            logs        = logs,
            sticks      = sticks,
            fuelUsage   = fuelUsage,
            growTime    = growTime,
            harvestTime = harvestTime,
        }, "test", "BirchGrow", coreutils.NewId())

        -- info
        print("Fuel level: "..turtle.getFuelLevel().."units")

        -- get one new sapling
        turtle.suckDown(1)
    end
end

function BirchGrowToFile()
    -- get the data
    local filename  = '/log/birchgrow.csv'
    local data = coredht.GetData("test", "BirchGrow")

    corelog.WriteToLog("data:")
    corelog.WriteToLog(data)

    -- new file
    coreutils.WriteToFile(filename, "saplings;logs;sticks;fuelUsage;growTime;harvestTime", "overwrite")

    -- loop entries
    for k, v in pairs(data) do
        coreutils.WriteToFile(filename, v.saplings..";"..v.logs..";"..v.sticks..";"..v.fuelUsage..";"..string.format("%.3f", v.growTime)..";"..string.format("%.3f", v.harvestTime), "append")
    end
end

function Excavate()
    role_excavator.Excavate({
        startLocation       = {y = 0, x = 0, z = 0, dx = 0, dy = 1 },
        dimensions          = {dx = 6, dy = 3, dz = 1 },
        outputLocation      = "inventory",
        backToStartLocation = true
    })
end

