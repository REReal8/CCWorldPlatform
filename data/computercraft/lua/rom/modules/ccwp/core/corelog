local corelog = {}
local coreevent = require "coreevent"
local coreassignment
local coreutils = require "coreutils"

local db	= {
	logfile			    = "/log/log.txt",
	assignmentLogFile   = "/log/coreassignment.log",
	projectsLogFile     = "/log/enterprise_projects.log",
	protocol		    = "corelog",
	loggerChannel	    = 65534,
	lastStack           = 0,
	status				= {},
}

local monitorLeft	= nil
local monitorRight	= nil

function corelog.Init()
	-- place markers in the logfile
	corelog.WriteToLog("--- starting up ---", "overwrite")
	corelog.WriteToAssignmentLog("--- starting up assignments ---", nil, "overwrite")
	corelog.WriteToProjectsLog("--- starting up projects ---", nil, "overwrite")
end

function corelog.Setup()
	-- start sending messages when we are ready to receive them too
	coreevent.EventReadyFunction(EventReadySetup)

	-- let others check our pulse
	coreevent.AddEventListener(DoEventPulseRequest,	db.protocol, "pulse request")

	-- check if we have monitors on our side (and we are not a turtle / pocket / command, se we are a computer)
	if peripheral.getType("left") == "monitor" and peripheral.getType("right") == "monitor" and not turtle and not pocket and not commands then
		-- get monitor handles
		monitorLeft		= peripheral.wrap("left")
		monitorRight	= peripheral.wrap("right")

		-- fresh start
		monitorLeft.clear()
		monitorRight.clear()

		-- no blinking!
		monitorLeft.setCursorBlink(false)
		monitorRight.setCursorBlink(false)

		-- start the left one at the bottom
		local w, h = monitorLeft.getSize()
		monitorLeft.setCursorPos(1,h)

		-- right monitor has bigger text size
		monitorRight.setTextScale(2)

		-- we will be the logger of this system
		coreassignment = coreassignment or require "coreassignment"
		coreassignment.RejectAllAssignments()

		-- listen to the logger port
		coreevent.OpenChannel(db.loggerChannel, db.protocol)

		-- listen to our events
		coreevent.AddEventListener(DoEventWriteToLog, db.protocol, "write to log")
		coreevent.AddEventListener(DoEventStatusUpdate, db.protocol, "status update")

		-- show who's boss!
		corelog.WriteToLog("--- starting up monitor ---")
		corelog.SetStatus("assignment", "I am the logger", "Just ignore me", "Thank you for reading this")
	end
end

function EventReadySetup()
	-- no need to do anything?
end

function corelog.WriteToLog(message, writeMode)
	-- set the default
	writeMode = writeMode or "append"

	-- write to the logfile
	coreutils.WriteToFile(db.logfile, message, writeMode)

	-- might be a table
	if type(message) == "table" then message = textutils.serialize(message) end

	-- send message
	if monitorLeft then
		-- we are the logging station, don't send message
		corelog.WriteToMonitor("me: "..message)
	else

		-- send message two whoever is loggin our stuff
		coreevent.SendMessage({
			channel		= db.loggerChannel,
			protocol	= db.protocol,
			subject		= "write to log",
			message		= {text = message} })
	end
end

local function MonitorWriteLine(message, monitor)
	local onderaan	= true
	local x, y		= monitor.getCursorPos()
	local w, h		= monitor.getSize()


	if not onderaan and y < h then
		-- where do we start?

		-- write the line
		monitor.write(message)

		-- ready for the next line
		monitor.setCursorPos(1, y + 1)

	else
		-- scroll the existing stuff up
		monitor.scroll(1)

		-- set the cursus back at the start of the line
		monitor.setCursorPos(1,h)

		-- write the message
		monitor.write(message)
	end
end

local function UpdateStatus(statusData, monitor)
	-- which do we use?
	monitor = monitor or monitorRight

	-- make sure the status data is valid
	if type(statusData) ~= "table"				then return end
	if not statusData.me						then return end
	if type(statusData.fuelLevel) ~= "number"	then statusData.fuelLevel	= 0 end
	if type(statusData.group)	  ~= "string"	then statusData.group		= "assignment" end
	if type(statusData.message)	  ~= "string"	then statusData.message		= nil end
	if type(statusData.subline)	  ~= "string"	then statusData.subline		= nil end
	if type(statusData.details)	  ~= "string"	then statusData.details		= nil end

	-- nicer
	if statusData.fuelLevel == 0				then statusData.fuelLevel	= "empty" end

	-- first, remember the status (and forget the previous status)
	if type(db.status[statusData.me]) ~= "table" then db.status[statusData.me] = {} end
	db.status[statusData.me].fuelLevel			= statusData.fuelLevel
	db.status[statusData.me][statusData.group]	= statusData

	-- now, show this to the monitor
	monitor.clear()

	-- maybe set cursor to be sure
	monitor.setCursorPos(1, 1)

	-- here we go
	for id, data in pairs(db.status) do

		local projectStatus		= data.project or {}
		local assignmentStatus	= data.assignment or {}

		-- write!
		MonitorWriteLine("", monitor)
		MonitorWriteLine("id: "..id.." (fuel: "..data.fuelLevel..")", monitor)
		MonitorWriteLine(string.format("%-20.20s %-20.20s", projectStatus.message or "", assignmentStatus.message or ""), monitor)
		MonitorWriteLine(string.format("%-20.20s %-20.20s", projectStatus.subline or "", assignmentStatus.subline or ""), monitor)
		MonitorWriteLine(string.format("%-20.20s %-20.20s", projectStatus.details or "", assignmentStatus.details or ""), monitor)
	end
end

function corelog.SetStatus(group, message, subline, details)
	-- get us and our fuel level
	local fuelLevel = 0
	if turtle then fuelLevel = turtle.getFuelLevel() end

	-- all relevant information for the status update together
	local statusUpdate = {
		me			= os.getComputerID(),
		fuelLevel	= fuelLevel,
		group		= group,
		message		= message,
		subline		= subline,
		details		= details
	}

	-- send to the logger (unless that's us)
	if monitorRight then

		-- update the status
		UpdateStatus(statusUpdate)
	else

		-- not us, send the info
		coreevent.SendMessage({
			channel		= db.loggerChannel,
			protocol	= db.protocol,
			subject		= "status update",
			message		= statusUpdate})
	end
end



function corelog.WriteToMonitor(message, monitor)
	-- default monitor
	monitor = monitor or monitorLeft

	-- write to an attached monitor if available (usefull for a status monitor screen)
	if monitor then
		local w, h = monitor.getSize()

		-- scroll the existing stuff up
		monitor.scroll(1)

		-- write the message
		monitor.write(message)

		-- set the cursus back at the start of the line
		monitor.setCursorPos(1,h)
	end
end

function corelog.Warning(message)
	-- write to the logfile
	coreutils.WriteToFile(db.logfile, "WARNING:", "append") -- ToDo: consider calling WriteToLog
	coreutils.WriteToFile(db.logfile, message, "append") -- ToDo: consider calling WriteToLog
end

function corelog.Error(message)
	-- write to the logfile
	coreutils.WriteToFile(db.logfile, "ERROR:", "append") -- ToDo: consider calling WriteToLog

	-- calling stack, just max once per tick
	if db.lastStack < os.clock() then

		-- reset
		db.lastStack = os.clock()

		-- write the callstack to the logfile
		coreutils.WriteToFile(db.logfile, debug.traceback())
	end

	-- requested messaage
	coreutils.WriteToFile(db.logfile, message, "append") -- ToDo: consider calling WriteToLog
end

function WriteToFormattedLog(message, id, logType, writeMode)
	-- set the default
	writeMode = writeMode or "append"

	-- write message to the logfile	in formatted log format
    local now = coreutils.UniversalTime()
    local computerId = os.getComputerID()
	local idStr = "assignment"
	local logFile = db.assignmentLogFile
	if logType == "projects" then
		idStr = "project"
		logFile = db.projectsLogFile
	end
	if id then
		idStr = idStr.." "..id.." | "
	else
		idStr = ""
	end
	coreutils.WriteToFile(logFile, "| time "..now.." | computer "..computerId.." | "..idStr..message.." |", writeMode)
end

function corelog.WriteToAssignmentLog(message, assignmentId, writeMode)
	WriteToFormattedLog(message, assignmentId, "assignment", writeMode)
end

function corelog.WriteToProjectsLog(message, projectId, writeMode)
	WriteToFormattedLog(message, projectId, "projects", writeMode)
end

function corelog.FindCaller(...) -- give ignore string as parameters. corelog.FindCaller("enterprise_projects", "enterprise_storage")
	local ignore = {method_executor = true}

	-- add all other keys to ignore
	for index, toIgnore in ipairs(arg) do ignore[ toIgnore ] = true end

	-- we don't need ourself (0) and the one calling this function (1), start witth 2
	local level = 2

	-- endless until we are at the end or found something
	while true do

		-- get the debug info
		local info = debug.getinfo(level, "Sl")

		-- at the end of the stack?
		if not info then return nil end

		-- just to be sure, skip C functions
		if info.what ~= "C" and ignore[info.short_src] == nil then -- not a C function and not in the ignore list

			-- Yahoo!
			return string.format("[%s]:%d", info.short_src, info.currentline)

		end

		-- still here, try the next level
		level = level + 1
	end
end

--                         _
--                        | |
--     _____   _____ _ __ | |_ ___
--    / _ \ \ / / _ \ '_ \| __/ __|
--   |  __/\ V /  __/ | | | |_\__ \
--    \___| \_/ \___|_| |_|\__|___/
--
--

function DoEventPulseRequest(subject, envelope)
	local fuelLevel

	-- computers don't have a fuel level
	if turtle	then fuelLevel = turtle.getFuelLevel()
				else fuelLevel = 0
	end

	-- send some information about us back
    coreevent.ReplyToMessage(envelope, "pulse response", {fuelLevel=fuelLevel})
end

function DoEventWriteToLog(subject, envelope)
	-- write the message on the monitor
	corelog.WriteToMonitor(envelope.from ..":".. envelope.message.text)
end

function DoEventStatusUpdate(subject, envelope)
	-- do the status update
	UpdateStatus(envelope.message)
end

return corelog
