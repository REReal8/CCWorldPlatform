local enterprise_forestry = {}
local coreutils = require "coreutils"
local corelog = require "corelog"
local coredht = require "coredht"
local coremove = require "coremove"

local MethodExecutor = require "method_executor"
local InputChecker = require "input_checker"
local URL = require "obj_url"

local role_forester = require "role_forester"

local BirchForest = require "mobj_birchforest"

local enterprise_projects = require "enterprise_projects"
local enterprise_turtle
local enterprise_construction = require "enterprise_construction"

local db = {
    hostName    = "enterprise_forestry",
    psForests   = "forests",
    psBirches   = "birch",
}

--[[
    The woods enterprise provides services for building and using wood production sites (i.e. forests).
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function enterprise_forestry.AddNewSite_ASrv(...)
    -- get & check input from description
    local checkSuccess, baseLocation, forestLevel, nTrees, materialsHostLocator, callback, callbackData = InputChecker.Check([[
        This async public service builds a new forest site and ensures it's ready for use.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                forestLocator           - (URL) locating the site

        Parameters:
            serviceData                 - (table) data about this site
                baseLocation            + (table) world location of the base (lower left corner) of this site
                forestLevel             + (number) level of the site
                nTrees                  + (number) number of initial trees
                materialsHostLocator    + (URL) locating the host of the building materials
            callback                    + (string) name of function to call once service is ready
            callbackData                + (table, {}) data to supply to callback function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_forestry.BuildAndStartNewSite_ASrv: Invalid input") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- check nTrees == 1  -- ToDo: remove this restriction
    if nTrees ~=1 then corelog.Warning("enterprise_forestry.BuildAndStartNewSite_ASrv: not yet implemented for nTrees="..nTrees) return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- create new forest
    enterprise_turtle = enterprise_turtle or require "enterprise_turtle"
    local forest = BirchForest:new({
        _id                     = coreutils.NewId(),
        _level                  = forestLevel,

        _location               = coremove.CopyLocation(baseLocation),
        _nTrees                 = 0,

        _localLogsLocator       = enterprise_turtle.GetHostLocator_Att(),
        _localSaplingsLocator   = enterprise_turtle.GetHostLocator_Att(),
    })

    -- save the forest
    corelog.WriteToLog(">Adding forest "..forest:getId()..".")
    local forestLocator = enterprise_forestry.SaveForest(forest)

    -- create projectDef and projectData
    local projectData = {
        forestLocator               = forestLocator,
        forestLevel                 = forestLevel,
        nTrees                      = nTrees,
    }

    local projectSteps = { }
    if forestLevel == -1 then
        -- add build tree step
        table.insert(projectSteps,
            { stepType = "ASrv", stepTypeDef = { module = "enterprise_assignmentboard", service = "DoAssignment_ASrv" }, stepDataDef = {
                { keyDef = "task"                       , sourceStep = 0, sourceKeyDef = "plantFirstSapling_Task" },
                { keyDef = "metaData"                   , sourceStep = 0, sourceKeyDef = "plantFirstSaplingMetaData" },
                { keyDef = "taskData"                   , sourceStep = 0, sourceKeyDef = "plantFirstSaplingTaskData" },
            }}
        )

        -- add step data
        local firstTreeLocation         = coremove.GetRelativeLocation(baseLocation, 3, 2, 0)
        local plantFirstSaplingTaskData =  {
            startLocation               = coremove.CopyLocation(firstTreeLocation),
        }
        projectData.plantFirstSaplingTaskData   = plantFirstSaplingTaskData
        projectData.plantFirstSaplingMetaData   = role_forester.PlantFirstSapling_MetaData(plantFirstSaplingTaskData)
        projectData.plantFirstSapling_Task      = "role_forester.PlantFirstSapling_Task"
    else
        -- add build tree step
        table.insert(projectSteps,
            { stepType = "ASrv", stepTypeDef = { module = "enterprise_forestry", service = "BuildForestTree_ASrv" }, stepDataDef = {
                { keyDef = "treeBaseLocation"       , sourceStep = 0, sourceKeyDef = "treeBaseLocation" },
                { keyDef = "treeLayer"              , sourceStep = 0, sourceKeyDef = "treeLayer" },
                { keyDef = "materialsHostLocator"   , sourceStep = 0, sourceKeyDef = "materialsHostLocator" },
            }}
        )

        -- add step data
        local treeBaseLocation  = coremove.CopyLocation(baseLocation)
        local targetBaseLayer = forest:getBaseLayer(forestLevel)
        projectData.materialsHostLocator        = materialsHostLocator
        projectData.treeBaseLocation            = treeBaseLocation
        projectData.treeLayer                   = targetBaseLayer
    end

    table.insert(projectSteps,
        { stepType = "SSrv", stepTypeDef = { module = "enterprise_forestry", service = "UpdateForest_SSrv" }, stepDataDef = {
            { keyDef = "forestLocator"              , sourceStep = 0, sourceKeyDef = "forestLocator" },
            { keyDef = "forestLevel"                , sourceStep = 0, sourceKeyDef = "forestLevel" },
            { keyDef = "nTrees"                     , sourceStep = 0, sourceKeyDef = "nTrees" },
        }}
    )
    table.insert(projectSteps,
        { stepType = "SSrv", stepTypeDef = { module = "enterprise_projects", service = "AreAllTrue_QSrv" }, stepDataDef = {
            { keyDef = "success1"                   , sourceStep = 1, sourceKeyDef = "success" },
            { keyDef = "success2"                   , sourceStep = 2, sourceKeyDef = "success" },
        }}
    )

    local projectDef = {
        steps = projectSteps,
        returnData  = {
            { keyDef = "success"                        , sourceStep = 3, sourceKeyDef = "success" },
            { keyDef = "forestLocator"                  , sourceStep = 2, sourceKeyDef = "forestLocator" },
        }
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function enterprise_forestry.UpgradeSite_ASrv(...)
    -- get & check input from description
    local checkSuccess, forestLocator, targetLevel, targetNTrees, materialsHostLocator, callback, callbackData = InputChecker.Check([[
        This private async service upgrades a forest site from the current configuration (i.e. level, # trees, ...) to a new configuration.

        Note: downgrading a forest is not supported.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully

        Parameters:
            serviceData                 - (table) data about the service
                forestLocator           + (URL) locating the forest
                targetLevel             + (number) with forest level to upgrade to
                targetNTrees            + (number) number of trees to upgrade forest to
                materialsHostLocator    + (URL) locating the host of the building materials
            callback                    + (string) name of function to call once service is ready
            callbackData                + (table) data to supply to callback function
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_forestry.UpgradeSite_ASrv: Invalid input") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- get forest
    local forest = enterprise_forestry.GetForest(forestLocator)
    if type(forest) ~="table" then corelog.Error("enterprise_forestry.UpgradeSite_ASrv: Failed retrieving forest = "..forestLocator:getURI()) return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- check not downgrading
    local startingLevel = forest:getLevel()
    if startingLevel > targetLevel then corelog.Error("enterprise_forestry.UpgradeSite_ASrv: Downgrading forest level (from "..startingLevel.." to "..targetLevel..") not supported") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- determine projectSteps and projectData
    local projectSteps = { }
    local areAllTrueStepDataDef = {}
    local targetTreeLayer = forest:getTreeLayer(targetLevel)
    local projectData = {
        forestLocator           = forestLocator,
        targetLevel             = targetLevel,
        treeLayer               = targetTreeLayer,
        materialsHostLocator    = materialsHostLocator,
    }

    -- add project steps for upgrading level
    local iStep = 0
    local startingTreeLayer = forest:getTreeLayer(startingLevel)
    local startingNTrees = forest:getNTrees()
    if startingLevel < targetLevel and startingNTrees > 0 then
        -- upgrade level data
        local targetBaseLayer = forest:getBaseLayer(targetLevel)
        local startingBaseLayer = forest:getBaseLayer(startingLevel)
        local transformLayer = startingBaseLayer:transformToLayer(targetBaseLayer)
        if not transformLayer then corelog.Error("enterprise_forestry.UpgradeSite_ASrv: No base transformLayer") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end
        local baseColOffset, baseRowOffset, baseBuildLayer = transformLayer:buildData()
        projectData.baseBuildLayer = baseBuildLayer

        transformLayer = startingTreeLayer:transformToLayer(targetTreeLayer)
        if not transformLayer then corelog.Error("enterprise_forestry.UpgradeSite_ASrv: No tree transformLayer") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end
        local treeColOffset, treeRowOffset, treeBuildLayer = transformLayer:buildData()
        projectData.treeBuildLayer = treeBuildLayer

        projectData.startingNTrees  = startingNTrees

        -- loop on current trees
        for iTree = 1, startingNTrees do
            -- get layer
            local buildLayer = treeBuildLayer
            local layerStr = "treeBuildLayer"
            local colOffset = treeColOffset
            local rowOffset = treeRowOffset
            if iTree == 1 then
                buildLayer = baseBuildLayer
                layerStr = "baseBuildLayer"
                colOffset = baseColOffset
                rowOffset = baseRowOffset
            end

            -- check layer needs update
            if buildLayer:getNRows() > 0 then
                    -- add build tree step
                iStep = iStep + 1
                local iStepStr = tostring(iStep)
                local treeBaseLocation = coremove.GetRelativeLocation(forest:getLocation(), colOffset + 0, rowOffset + 6 * (iTree - 1), 0)
                local treeBaseLocationStr = "treeBaseLocation"..iStepStr
                table.insert(projectSteps,
                    { stepType = "ASrv", stepTypeDef = { module = "enterprise_forestry", service = "BuildForestTree_ASrv" }, stepDataDef = {
                        { keyDef = "treeBaseLocation"       , sourceStep = 0, sourceKeyDef = treeBaseLocationStr },
                        { keyDef = "treeLayer"              , sourceStep = 0, sourceKeyDef = layerStr },
                        { keyDef = "materialsHostLocator"   , sourceStep = 0, sourceKeyDef = "materialsHostLocator" },
                    }}
                )

                -- add step data
                projectData[treeBaseLocationStr] = treeBaseLocation

                -- add success stepDataDef
                table.insert(areAllTrueStepDataDef, { keyDef = "success"..iStepStr, sourceStep = iStep, sourceKeyDef = "success" })
            end
        end

        -- update forest info
        iStep = iStep + 1
        local iStepStr = tostring(iStep)
        table.insert(projectSteps,
            { stepType = "SSrv", stepTypeDef = { module = "enterprise_forestry", service = "UpdateForest_SSrv" }, stepDataDef = {
                { keyDef = "forestLocator"          , sourceStep = 0, sourceKeyDef = "forestLocator" },
                { keyDef = "forestLevel"            , sourceStep = 0, sourceKeyDef = "targetLevel" },
                { keyDef = "nTrees"                 , sourceStep = 0, sourceKeyDef = "startingNTrees" },
            }}
        )

        -- add success stepDataDef
        table.insert(areAllTrueStepDataDef, { keyDef = "success"..iStepStr, sourceStep = iStep, sourceKeyDef = "success" })
    end

    -- add project step for trees to add
    if startingNTrees < targetNTrees then
        -- loop on trees to add
        for iTree = startingNTrees + 1, targetNTrees do
            -- add build tree step
            iStep = iStep + 1
            local iStepStr = tostring(iStep)
            local treeBaseLocation = coremove.GetRelativeLocation(forest:getLocation(), 0, 6 * (iTree - 1), 0)
            local treeBaseLocationStr = "treeBaseLocation"..iStepStr
            table.insert(projectSteps,
                { stepType = "ASrv", stepTypeDef = { module = "enterprise_forestry", service = "BuildForestTree_ASrv" }, stepDataDef = {
                    { keyDef = "treeBaseLocation"       , sourceStep = 0, sourceKeyDef = treeBaseLocationStr },
                    { keyDef = "treeLayer"              , sourceStep = 0, sourceKeyDef = "treeLayer" },
                    { keyDef = "materialsHostLocator"   , sourceStep = 0, sourceKeyDef = "materialsHostLocator" },
                }}
            )

            -- add step data
            projectData[treeBaseLocationStr] = treeBaseLocation

            -- add success stepDataDef
            table.insert(areAllTrueStepDataDef, { keyDef = "success"..iStepStr, sourceStep = iStep, sourceKeyDef = "success" })

            -- update forest info
            iStep = iStep + 1
            iStepStr = tostring(iStep)
            local newNTreesStr = "newNTreeStep"..iStepStr
            table.insert(projectSteps,
                { stepType = "SSrv", stepTypeDef = { module = "enterprise_forestry", service = "UpdateForest_SSrv" }, stepDataDef = {
                    { keyDef = "forestLocator"          , sourceStep = 0, sourceKeyDef = "forestLocator" },
                    { keyDef = "forestLevel"            , sourceStep = 0, sourceKeyDef = "targetLevel" },
                    { keyDef = "nTrees"                 , sourceStep = 0, sourceKeyDef = newNTreesStr },
                }}
            )

            -- add step data
            projectData[newNTreesStr] = iTree

            -- add success stepDataDef
            table.insert(areAllTrueStepDataDef, { keyDef = "success"..iStepStr, sourceStep = iStep, sourceKeyDef = "success" })
        end
    end

    -- add check for all a success
    iStep = iStep + 1
    table.insert(projectSteps,
        { stepType = "SSrv", stepTypeDef = { module = "enterprise_projects", service = "AreAllTrue_QSrv" }, stepDataDef = areAllTrueStepDataDef}
    )
    local iAreAllTrueStep = iStep

    -- create project service data
    local projectDef = {
        steps = projectSteps,
        returnData  = {
            { keyDef = "success"    , sourceStep = iAreAllTrueStep, sourceKeyDef = "success" },
        }
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    corelog.WriteToLog(">Upgrading forest "..forestLocator:getURI().." from level "..startingLevel.." to "..targetLevel.." and from "..startingNTrees.." to "..targetNTrees.." trees")
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function enterprise_forestry.ProvideItemsTo_ASrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, storageLocator, ingredientsSupplierLocator, assignmentsPriorityKey, callback, callbackData = InputChecker.Check([[
        This async public Supplier service provides specific items to a Storage.

        Return value:
            nil

        Async service return value (to callback):
                                            - (table)
                success                     - (boolean) whether the service executed correctly
                destinationItemsLocator     - (URL) locating the final Storage and the items that where transferred to it
                                                (upon service succes the "host" component of this URL should be equal to storageLocator, and
                                                the "query" should be equal to orderItems)

        Parameters:
            serviceData                     - (table) data for the service
                itemsLocator                + (URL) locating the items to provide
                                                (the "base" component of the URL specifies the Supplier that provides the items)
                                                (the "query" component of the URL specifies the items)
                storageLocator              + (URL) locating the Storage where the items need to be provided to
                ingredientsSupplierLocator  + (URL) locating where the production ingredients can be retrieved
                assignmentsPriorityKey      + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                        + (string) name of function to call once service is ready
            callbackData                    + (table) data to supply to callback function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_forestry.ProvideItemsTo_ASrv: Invalid input") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- get forest
    local forest = enterprise_forestry.GetForest(itemsLocator)
    if type(forest) ~="table" then corelog.Error("enterprise_forestry.ProvideItemsTo_ASrv: Failed retrieving forest = "..itemsLocator:getURI()) return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- have forest provide items
    local provideItems = itemsLocator:getQuery()
    forest:provideItemsTo_ASrv({
        provideItems                = provideItems,
        storageLocator              = storageLocator,
        ingredientsSupplierLocator  = ingredientsSupplierLocator,
        assignmentsPriorityKey      = assignmentsPriorityKey,
    }, callback, callbackData)
end

function enterprise_forestry.Can_ProvideItems_QSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator = InputChecker.Check([[
        This sync public query service answers the question whether the Supplier can provide specific items.

        Return value:
                                    - (table)
                success             - (boolean) whether the answer to the question is true

        Parameters:
            serviceData             - (table) data to the query
                itemsLocator        + (URL) locating the items that need to be queried for providability
                                        (the "base" component of the URL specifies the Supplier that provides the items)
                                        (the "query" component of the URL specifies the items to query for)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_forestry.Can_ProvideItems_QSrv: Invalid input") return {success = false} end

    -- get forest
    local forest = enterprise_forestry.GetForest(itemsLocator)
    if type(forest) ~="table" then corelog.Error("enterprise_forestry.Can_ProvideItems_QSrv: Failed retrieving forest = "..itemsLocator:getURI()) return {success = false} end

    -- check forest can provide items
    local provideItems = itemsLocator:getQuery()
    local canProvide = forest:can_ProvideItems_QSrv({
        provideItems    = provideItems,
    })

    -- end
    return canProvide
end

function enterprise_forestry.NeedsTo_ProvideItemsTo_SSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, storageLocator = InputChecker.Check([[
        This sync public service returns the needs for the Supplier to provide specific items to a Storage.

        Return value:
                                            - (table)
                success                     - (boolean) whether the service executed correctly
                fuelNeed                    - (number) amount of fuel needed to provide items
                ingredientsNeed             - (table) ingredients needed to provide items

        Parameters:
            serviceData                     - (table) data to the query
                itemsLocator                + (URL) locating the items to provide
                                                (the "base" component of the URL specifies the Supplier that provides the items)
                                                (the "query" component of the URL specifies the items)
                storageLocator              + (URL) locating the Storage where the items need to be provided to
                ingredientsSupplierLocator  - (URL) locating where ingredients can be retrieved
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_forestry.NeedsTo_ProvideItemsTo_SSrv: Invalid input") return {success = false} end

    -- get forest
    local forest = enterprise_forestry.GetForest(itemsLocator)
    if type(forest) ~="table" then corelog.Error("enterprise_forestry.NeedsTo_ProvideItemsTo_SSrv: Failed retrieving forest = "..itemsLocator:getURI()) return {success = false} end

    -- determine needs
    local provideItems = itemsLocator:getQuery()
    local needs = forest:needsTo_ProvideItemsTo_SSrv({
        provideItems    = provideItems,
        storageLocator  = storageLocator,
    })

    -- end
    return needs
end

function enterprise_forestry.GetForest(...)
    -- get & check input from description
    local checkSuccess, forestLocator = InputChecker.Check([[
        This private function gets a forest based on a forestLocator.

        Return value:
            forest              - (table) the forest object

        Parameters:
            forestLocator       + (URL) locating the forest
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_forestry.GetForest: Invalid input") return nil end

    -- check forestLocator is for this enterprise
    local serviceResults = enterprise_forestry.IsForestURL_QSrv({ aURL = forestLocator})
    if not serviceResults.success then corelog.Error("enterprise_forestry.GetForest: Invalid forestLocator (="..forestLocator:getURI()..").") return nil end

    -- object ophalen
    local forest = coredht.GetResource(forestLocator)
    if type(forest) ~= "table" then corelog.Warning("enterprise_forestry.GetForest: forest "..forestLocator:getURI().." not found") return nil end
    forest = BirchForest:new(forest)

    -- end
    return forest
end

local function ResetForests()
    return coredht.SaveData({}, db.hostName, db.psForests, db.psBirches)
end

local function GetForests()
    -- get forests
    local forests = coredht.GetData(db.hostName, db.psForests, db.psBirches)
    if not forests then forests = ResetForests() end

    -- end
    return forests
end

function enterprise_forestry.GetNumberOfForests_Att()
    --[[
        enterprise attribute: number of forests administered by the enterprise.
    --]]

    -- get forests
    local forests = GetForests()

    -- loop on forests
    local count = 0
    for k, forest in pairs(forests) do
        count = count + 1
    end

    return count
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function enterprise_forestry.BuildForestTree_ASrv(...)
    -- get & check input from description
    local checkSuccess, treeBaseLocation, treeLayer, materialsHostLocator, callback, callbackData = InputChecker.Check([[
        This private async service extends the forest with 1 tree

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully

        Parameters:
            serviceData                 - (table) data about this service
                treeBaseLocation        + (table) location of the base (lower left corner) of a forest tree (layer)
                treeLayer               + (LayerRectangle) tree layer to build
                materialsHostLocator    + (URL) locating the host of the building materials
            callback                    + (string) name of function to call once service is ready
            callbackData                + (table) data to supply to callback function
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_forestry.BuildForestTree_ASrv: Invalid input") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- let construction enterprise build the tree
    local buildData = {
        startpoint = coremove.CopyLocation(treeBaseLocation),
        buildFromAbove = true,
        replacePresentObjects = false,
        layer = treeLayer,
        materialsHostLocator = materialsHostLocator,
    }
    corelog.WriteToLog(">Building tree (forest layer) at "..textutils.serialise(buildData.startpoint, { compact = true }))
    enterprise_construction.BuildLayer_ASrv(buildData, callback, callbackData)
end

function enterprise_forestry.UpdateForest_SSrv(...)
    -- get & check input from description
    local checkSuccess, forestLocator, forestLevel, nTrees = InputChecker.Check([[
        This private sync service updates the forest information.

        Return value:
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                forestLocator           - (URL) locating the forest

        Parameters:
            serviceData                 - (table) data about the service
                forestLocator           + (URL) locating the forest
                forestLevel             + (number) with forest level
                nTrees                  + (number) number of trees in the forest
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_forestry.UpdateForest_SSrv: Invalid input") return {success = false} end

    -- get forest
    local forest = enterprise_forestry.GetForest(forestLocator)
    if type(forest) ~="table" then corelog.Error("enterprise_forestry.UpdateForest_SSrv: Failed retrieving forest = "..forestLocator:getURI()) return {success = false} end

    -- set forest information
    forest:setLevel(forestLevel)
    forest:setNTrees(nTrees)

    -- save forest data
    forestLocator = enterprise_forestry.SaveForest(forest)

    -- end
    corelog.WriteToLog(">Updated forest (level="..forestLevel..", nTrees="..nTrees..")")
    return {
        success         = true,
        forestLocator   = forestLocator,
    }
end

function enterprise_forestry.SaveForest(...)
    -- get & check input from description
    local checkSuccess, forest = InputChecker.Check([[
        This private function saves a forest to the dht.

        Return value:
            forestLocator       - (URL) locating the forest

        Parameters:
            forest              + (BirchForest) the forest object
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_forestry.SaveForest: Invalid input") return nil end

    -- get locator
    local forestLocator = enterprise_forestry.GetForestLocator(forest:getId())

    -- save record
    coredht.SaveResource(forest, forestLocator)

    -- end
    return forestLocator
end

function enterprise_forestry.DeleteForests()
    -- get forests
    local forests = GetForests()

    -- remove all
--    corelog.Warning("All forests are being deleted!")
    for id, forest in pairs(forests) do
        -- get locator
        local forestLocator = enterprise_forestry.GetForestLocator(forest._id)

        -- remove
        enterprise_forestry.RemoveForest(forestLocator)
    end
end

function enterprise_forestry.RemoveForest(...)
    -- get & check input from description
    local checkSuccess, forestLocator = InputChecker.Check([[
        This private function removes a forest from the dht.

        Return value:
            nil

        Parameters:
            forestLocator       + (URL) locating the forest
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_forestry.RemoveForest: Invalid input") return nil end

    -- remove record
    corelog.WriteToLog(">removing forest "..forestLocator:getURI())
    coredht.RemoveResource(forestLocator)
end

local function GetHostLocator_Att()
    --[[
        Attribute locating this enterprise.

        Return value:
            hostLocator             - (URL) locating this enterprise

        Parameters:
            nil
    --]]

    local hostURL = URL:new()
    hostURL:setHost(db.hostName)

    return hostURL
end

function enterprise_forestry.IsForestURL_QSrv(...)
    -- get & check input from description
    local checkSuccess, aURL = InputChecker.Check([[
        This sync public service answers the question if a URL is that of a Forest.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully

        Parameters:
            queryData               - (table) data about the query
                aURL                + (URL) that needs to be queried
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_forestry.IsForestURL_QSrv: Invalid input") return {success = false} end

    -- check if of this Supplier
    local host = aURL:getHost()
    if type(host) ~= "string" then corelog.Error("enterprise_forestry.IsForestURL_QSrv: Invalid host input in URL (="..aURL:getURI()..").") return {success = false} end
    if host == db.hostName then
        return {success = true}
    else
        return {success = false}
    end
end

function enterprise_forestry.GetForestLocator(...)
    -- get & check input from description
    local checkSuccess, id = InputChecker.Check([[
        This private function provides the URL of a forest based on it's (internal) id.

        Return value:
            forestLocator           - (URL) locating the forest

        Parameters:
            id                      + (string) with the id of the forest
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_forestry.GetForestLocator: Invalid input") return nil end

    -- construct URL
    local forestLocator = GetHostLocator_Att()
    local path = "/"..db.psForests.."/"..db.psBirches.."/id="..id
    forestLocator:setPath(path)

    -- end
    return forestLocator
end

return enterprise_forestry
