local enterprise_construction = {}
local coreutils = require "coreutils"
local corelog = require "corelog"

local Callback = require "obj_callback"
local InputChecker = require "input_checker"

local role_builder = require "role_builder"

local enterprise_projects = require "enterprise_projects"
local enterprise_assignmentboard = require "enterprise_assignmentboard"
local enterprise_turtle

--[[
    The construction enterprise provides services to construct structures in the physical minecraft world.
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function enterprise_construction.BuildBlueprint_ASrv(...)
    -- get & check input from description
    local checkSuccess, blueprintStartpoint, blueprint, materialsHostLocator, callback = InputChecker.Check([[
        This async public service builds a blueprint as a single assignment/ task.

        Return value:
            nil

        Async service return value (to Callback):
                                        - (table) {success = true} if the blueprint was successfully build

        Parameters:
            buildData                   - (table) data about what to build
                blueprintStartpoint     + (table) top lower left coordinate to start building the blueprint
                blueprint               + (table) blueprint to build
                    layerList           - (table) layer to build
                    escapeSequence      - (table) escapeSequence of blueprint
                materialsHostLocator    + (URL) locating the host of the building materials
            callback                    + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_construction.BuildBlueprint_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- construct assignment metadata
    local taskData = {
        blueprintStartpoint     = blueprintStartpoint,
        blueprint               = blueprint,
    }
    local metaData = role_builder.BuildBlueprint_MetaData(taskData)

    -- check if materials needed
    local materialsNeeded = coreutils.DeepCopy(metaData.itemsNeeded)
    local taskFunctionName = "role_builder.BuildBlueprint_Task"
    if next(materialsNeeded) == nil then
        -- directly do assignment
--        corelog.WriteToLog(">Building (zero materials) blueprint "..textutils.serialise(blueprintStartpoint))
        local assignmentServiceData = {
            metaData    = metaData,
            task        = taskFunctionName,
            taskData    = taskData,
        }
        return enterprise_assignmentboard.DoAssignment_ASrv(assignmentServiceData, callback)
    end

    -- determine materialsItemsLocator (by update materialsHostLocator with itemsNeeded)
    local materialsItemsLocator = materialsHostLocator
    materialsItemsLocator:setQuery(materialsNeeded)

    -- set local output location
    enterprise_turtle = enterprise_turtle or require "enterprise_turtle"
    local materialsLocalHostLocator = enterprise_turtle.GetHostLocator_Att()

    -- create project service data
    local buildBlueprintProjectDef = {
        steps   = {
            { stepType = "ASrv", stepTypeDef = { moduleName = "enterprise_isp", serviceName = "ProvideItemsTo_ASrv" }, stepDataDef = {
                { keyDef = "itemsLocator"               , sourceStep = 0, sourceKeyDef = "materialsItemsLocator" },
                { keyDef = "storageLocator"             , sourceStep = 0, sourceKeyDef = "materialsLocalHostLocator" },
                { keyDef = "ingredientsSupplierLocator" , sourceStep = 0, sourceKeyDef = "ingredientsSupplierLocator" },
            }},
            { stepType = "ASrv", stepTypeDef = { moduleName = "enterprise_assignmentboard", serviceName = "DoAssignment_ASrv" }, stepDataDef = {
                { keyDef = "task"                       , sourceStep = 0, sourceKeyDef = "taskFunctionName" },
                { keyDef = "metaData"                   , sourceStep = 0, sourceKeyDef = "metaData" },
                { keyDef = "metaData.needTurtleId"      , sourceStep = 1, sourceKeyDef = "destinationItemsLocator._port" }, -- ToDo: consider if we can avoid accessing URL internal _port
                { keyDef = "taskData"                   , sourceStep = 0, sourceKeyDef = "taskData" },
            }},
            { stepType = "SSrv", stepTypeDef = { moduleName = "enterprise_projects", serviceName = "AreAllTrue_QSrv" }, stepDataDef = {
                { keyDef = "success1"                   , sourceStep = 1, sourceKeyDef = "success" },
                { keyDef = "success2"                   , sourceStep = 2, sourceKeyDef = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                        , sourceStep = 3, sourceKeyDef = "success" },
        }
    }
    local projectData = {
        materialsItemsLocator       = materialsItemsLocator:copy(),
        materialsLocalHostLocator   = materialsLocalHostLocator:copy(),
        ingredientsSupplierLocator  = materialsHostLocator:copy(),

        taskFunctionName            = taskFunctionName,
        metaData                    = metaData,
        taskData                    = taskData,
    }
    local projectServiceData = {
        projectDef  = buildBlueprintProjectDef,
        projectData = projectData,
    }

    -- start project
--    corelog.WriteToLog(">Building blueprint at "..textutils.serialise(blueprintStartpoint))
    enterprise_projects.StartProject_ASrv(projectServiceData, callback)
end

function enterprise_construction.BuildLayer_ASrv(...)
    -- get & check input from description
    local checkSuccess, startpoint, buildFromAbove, replacePresentObjects, layer, materialsHostLocator, callback = InputChecker.Check([[
        This async public service builds a rectangular layer in the x,y plane as a single assignment/ task.

        Return value:
            nil

        Async service return value (to Callback):
                                        - (table) {success = true} if the layer was successfully build

        Parameters:
            buildData                   - (table) data about what to build
                startpoint              + (table) lower left coordinate to start building the layer
                buildFromAbove          + (boolean) whether build should be done from above (true) or below (false)
                replacePresentObjects   + (boolean, false) whether objects should be replaced if it is already present in the minecraft world (default = false)
                layer                   + (LayerRectangle) layer to build
                materialsHostLocator    + (URL) locating the host of the building materials
            callback                    + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_construction.BuildLayer_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- get assignment metadata
    local taskData = {
        startpoint              = startpoint,
        buildFromAbove          = buildFromAbove,
        replacePresentObjects   = replacePresentObjects,
        layer                   = layer,
    }
    local metaData = role_builder.BuildLayer_MetaData(taskData)

    -- check if materials needed
    local materialsNeeded = coreutils.DeepCopy(metaData.itemsNeeded)
    local taskFunctionName = "role_builder.BuildLayer_Task"
    if next(materialsNeeded) == nil then
        -- directly do assignment
--        corelog.WriteToLog(">Building (zero materials) layer at "..textutils.serialise(startpoint))
        local assignmentServiceData = {
            metaData    = metaData,
            task        = taskFunctionName,
            taskData    = taskData,
        }
        return enterprise_assignmentboard.DoAssignment_ASrv(assignmentServiceData, callback)
    end

    -- determine materialsItemsLocator (by update materialsHostLocator with itemsNeeded)
    local materialsItemsLocator = materialsHostLocator
    materialsItemsLocator:setQuery(materialsNeeded)

    -- set local output location
    -- note:    Because BuildLayer_Task requires a turtle to have the goods in it's inventory at this point specify that a turtle
    --          should pick up the materials. We however do not yet specify which turtle as we leave it up to the (relayed services of)
    --          the TransferItemsFromTo_ASrv service to find that out. Because of below statement the resulting destinationItemsLocator return value
    --          of that service should specify which turtle has the items in it's inventory.
    enterprise_turtle = enterprise_turtle or require "enterprise_turtle"
    local materialsLocalHostLocator = enterprise_turtle.GetHostLocator_Att()

    -- create project service data
    local buildRectangularPatternProjectDef = {
        steps   = {
            { stepType = "ASrv", stepTypeDef = { moduleName = "enterprise_isp", serviceName = "ProvideItemsTo_ASrv" }, stepDataDef = {
                { keyDef = "itemsLocator"               , sourceStep = 0, sourceKeyDef = "materialsItemsLocator" },
                { keyDef = "storageLocator"             , sourceStep = 0, sourceKeyDef = "materialsLocalHostLocator" },
                { keyDef = "ingredientsSupplierLocator" , sourceStep = 0, sourceKeyDef = "ingredientsSupplierLocator" },
            }},
            { stepType = "ASrv", stepTypeDef = { moduleName = "enterprise_assignmentboard", serviceName = "DoAssignment_ASrv" }, stepDataDef = {
                { keyDef = "task"                       , sourceStep = 0, sourceKeyDef = "taskFunctionName" },
                { keyDef = "metaData"                   , sourceStep = 0, sourceKeyDef = "metaData" },
                { keyDef = "metaData.needTurtleId"      , sourceStep = 1, sourceKeyDef = "destinationItemsLocator._port" }, -- ToDo: consider if we can avoid accessing URL internal _port
                { keyDef = "taskData"                   , sourceStep = 0, sourceKeyDef = "taskData" },
            }},
            { stepType = "SSrv", stepTypeDef = { moduleName = "enterprise_projects", serviceName = "AreAllTrue_QSrv" }, stepDataDef = {
                { keyDef = "success1"                   , sourceStep = 1, sourceKeyDef = "success" },
                { keyDef = "success2"                   , sourceStep = 2, sourceKeyDef = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                        , sourceStep = 3, sourceKeyDef = "success" },
        }
    }
    local projectData = {
        materialsItemsLocator       = materialsItemsLocator:copy(),
        materialsLocalHostLocator   = materialsLocalHostLocator:copy(),
        ingredientsSupplierLocator  = materialsHostLocator:copy(),

        taskFunctionName            = taskFunctionName,
        metaData                    = metaData,
        taskData                    = taskData,
    }
    local projectServiceData = {
        projectDef  = buildRectangularPatternProjectDef,
        projectData = projectData,
    }

    -- start project
--    corelog.WriteToLog(">Building layer at "..textutils.serialise(startpoint))
    enterprise_projects.StartProject_ASrv(projectServiceData, callback)
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

return enterprise_construction
