local enterprise_factory = {}
local coreutils = require "coreutils"
local corelog = require "corelog"
local coredht = require "coredht"
local coremove = require "coremove"
local corejob = require "corejob" -- ToDo: remove dependency on old code
local coretask = require "coretask" -- ToDo: remove dependency on old code

local InputChecker = require "input_checker"
local MethodExecutor = require "method_executor"
local URL = require "obj_url"

local role_alchemist = require "role_alchemist" -- ToDo: remove dependency on old code

local enterprise = require "enterprise" -- ToDo: remove dependency on old code
local enterprise_projects = require "enterprise_projects"
local enterprise_isp = require "enterprise_isp"
local enterprise_turtle
local enterprise_energy = require "enterprise_energy"
local enterprise_factory_site = require "enterprise_factory_site"
local enterprise_construction = require "enterprise_construction"

local db = {
    hostName    = "enterprise_factory",
    psSites     = "sites",

    -- turtle slots
    -- [ 1] [ 2] [ 3] [ 4]
    -- [ 5] [ 6] [ 7] [ 8]
    -- [ 9] [10] [11] [12]
    -- [13] [14] [15] [16]
    recipes        = {
        ["minecraft:stick"] = {
            crafting  = {
                  [6]    = { itemName = "minecraft:birch_planks",   itemCount = 1 },
                 [10]    = { itemName = "minecraft:birch_planks",   itemCount = 1 },
                yield   = 4
            },
        },
        ["minecraft:charcoal"] = { -- ToDo consider similar format to crafting to simpify code
            smelting  = {
                itemName    = "minecraft:birch_log",
--                itemCount   = 1,
                yield       = 1,
            },
        },
        ["minecraft:torch"] = {
            crafting  = {
                 [6]    = { itemName = "minecraft:charcoal",        itemCount = 1 },
                [10]    = { itemName = "minecraft:stick",           itemCount = 1 },
               yield   = 4
           },
        },
        ["minecraft:birch_planks"] = {
            crafting  = {
                 [6]    = { itemName = "minecraft:birch_log",       itemCount = 1 },
                yield   = 4
            },
        },
        ["minecraft:chest"] = {
            crafting  = {
                 [6]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                 [7]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                 [8]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [10]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [12]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [14]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [15]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [16]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                yield   = 1
            },
        },
        ["minecraft:furnace"] = {
            crafting  = {
                 [6]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                 [7]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                 [8]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [10]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [12]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [14]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [15]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [16]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                yield   = 1
            },
        },
    }
}

-- ToDo: consider renaming to enterprise_factories

--[[
    The Factory is an enterprise that offers services to produce items based on recipes.

    The Factory is a Producer, hence it provides the mandatory services and functions for a Producer (like e.g. ProvideItemsTo_ASrv).

    There are (currently) two recipe types for producing items.
        The crafting recipe uses the crafting production technique to produce an output item from a set of input items (ingredients).
        The smelting recipe uses the smelting production technique to produce an output item from an input item (ingredient).

    It also provides the following attributes
        GetHostLocator_Att     - locating this enterprise

    The Factory is comprised out of one or more factory sites. It uses the production services of the factory sites to produce the items.
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function enterprise_factory.ProvideItemsTo_ASrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, storageLocator, ingredientsSupplierLocator, assignmentsPriorityKey, callback, callbackData = InputChecker.Check([[
        This async public Supplier service provides specific items to a Storage.

        It does so by first determining recipes that can produce the items. Subsequently it retrieves the needed production ingredients.
        After that it produces the requested amount of items with the production method (i.e. crafting or smelting) corresponding to the recipes.
        Finally it delivers the created items to the requested Storage.

        Return value:
            nil

        Async service return value (to callback):
                                            - (table)
                success                     - (boolean) whether the service executed correctly
                destinationItemsLocator     - (URL) locating the final Storage and the items that where transferred to it
                                                (upon service succes the "host" component of this URL should be equal to storageLocator, and
                                                the "query" should be equal to orderItems)

        Parameters:
            serviceData                     - (table) data for the service
                itemsLocator                + (URL) locating the items to provide
                                                (the "base" component of the URL specifies the Supplier that provides the items)
                                                (the "query" component of the URL specifies the items)
                storageLocator              + (URL) locating the Storage where the items need to be provided to
                ingredientsSupplierLocator  + (URL) locating where the production ingredients can be retrieved
                assignmentsPriorityKey      + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                        + (string) name of function to call once service is ready
            callbackData                    + (table, {}) data to supply to callback function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_factory.ProvideItemsTo_ASrv: Invalid input") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- check itemsLocator is for this enterprise
    local serviceResults = IsFactoryURL_QSrv({ aURL = itemsLocator})
    if not serviceResults.success then corelog.Error("enterprise_factory.ProvideItemsTo_ASrv: Invalid itemsLocator (="..itemsLocator:getURI()..").") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- loop on items
    local provideItems = itemsLocator:getQuery()
    for itemName, itemCount in pairs(provideItems) do
        -- check
        if type(itemName) ~= "string" then corelog.Error("enterprise_factory.ProvideItemsTo_ASrv: Invalid itemName (type="..type(itemName)..")") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end
        if type(itemCount) ~= "number" then corelog.Error("enterprise_factory.ProvideItemsTo_ASrv: Invalid itemCount (type="..type(itemCount)..")") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

        -- select recipe to produce item
        local recipe = db.recipes[ itemName ]
        if type(recipe) ~= "table" then corelog.Error("enterprise_factory.ProvideItemsTo_ASrv: No recipe for item "..itemName) return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

        -- select a suitable site
        local siteProduceItemData = enterprise_factory_site.GetAvailableSiteData(recipe, itemCount)
        if type(siteProduceItemData) ~= "table" then corelog.Error("enterprise_factory.ProvideItemsTo_ASrv: No site available to produce "..itemCount.." "..itemName.."'s") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

        -- determine ingredientsItemsLocator (by updating ingredientsSupplierLocator with itemsNeeded)
        local ingredientsItemsLocator = ingredientsSupplierLocator:copy()
        ingredientsItemsLocator:setQuery(coreutils.DeepCopy(siteProduceItemData.itemsNeeded))

        -- retrieve site input & output locator's
        local localInputLocator = URL:new(siteProduceItemData.localInputLocator)
        local localOutputLocator = URL:new(siteProduceItemData.localOutputLocator)

        -- create project service data
        local projectDef = {
            steps = {
                { stepName = "enterprise_isp.ProvideItemsTo_ASrv", async = true, stepDataDef = {
                    { keyDef = "itemsLocator"               , valueSource = 0, keyDefSource = "ingredientsItemsLocator" },
                    { keyDef = "storageLocator"             , valueSource = 0, keyDefSource = "localInputLocator" },
                    { keyDef = "ingredientsSupplierLocator" , valueSource = 0, keyDefSource = "ingredientsSupplierLocator" },
                    { keyDef = "assignmentsPriorityKey"     , valueSource = 0, keyDefSource = "assignmentsPriorityKey" },
                }},
                { stepName = "enterprise_factory_site.ProduceItem_ASrv", async = true, stepDataDef = {
                    { keyDef = "localInputItemsLocator"     , valueSource = 1, keyDefSource = "destinationItemsLocator" },
                    { keyDef = "localOutputLocator"         , valueSource = 0, keyDefSource = "localOutputLocator" },
                    { keyDef = "productionMethod"           , valueSource = 0, keyDefSource = "productionMethod" },
                    { keyDef = "productionSpot"             , valueSource = 0, keyDefSource = "productionSpot" },
                    { keyDef = "productItemName"            , valueSource = 0, keyDefSource = "itemName" },
                    { keyDef = "productItemCount"           , valueSource = 0, keyDefSource = "itemCount" },
                    { keyDef = "productionRecipe"           , valueSource = 0, keyDefSource = "productionRecipe" },
                    { keyDef = "assignmentsPriorityKey"     , valueSource = 0, keyDefSource = "assignmentsPriorityKey" },
                }},
                { stepName = "enterprise_isp.TransferItemsFromTo_ASrv", async = true, stepDataDef = {
                    { keyDef = "sourceItemsLocator"         , valueSource = 2, keyDefSource = "localOutputItemsLocator" },
                    { keyDef = "destinationStorageLocator"  , valueSource = 0, keyDefSource = "storageLocator" },
                    { keyDef = "assignmentsPriorityKey"     , valueSource = 0, keyDefSource = "assignmentsPriorityKey" },
                }},
                -- ToDo: consider storing rest/ waste materials (e.g. those caused by ceil (rounding up) of ingredient items)
                { stepName = "enterprise_projects.AreAllTrue_QSrv", async = false, stepDataDef = {
                    { keyDef = "success1"               , valueSource = 1, keyDefSource = "success" },
                    { keyDef = "success2"               , valueSource = 2, keyDefSource = "success" },
                    { keyDef = "success3"               , valueSource = 3, keyDefSource = "success" },
                }},
            },
            returnData  = {
                { keyDef = "success"                    , valueSource = 4, keyDefSource = "success" },
                { keyDef = "destinationItemsLocator"    , valueSource = 3, keyDefSource = "destinationItemsLocator" },
            }
        }
        local projectData = {
            ingredientsSupplierLocator  = ingredientsSupplierLocator:copy(),

            ingredientsItemsLocator     = ingredientsItemsLocator,
            storageLocator              = storageLocator,

            localInputLocator           = localInputLocator,
            localOutputLocator          = localOutputLocator,

            productionMethod            = siteProduceItemData.productionMethod,
            productionSpot              = siteProduceItemData.productionSpot,
            itemName                    = itemName,
            itemCount                   = itemCount,
            productionRecipe            = siteProduceItemData.productionRecipe,

            assignmentsPriorityKey      = assignmentsPriorityKey,
        }
        local projectServiceData = {
            projectDef  = projectDef,
            projectData = projectData,
        }

        -- start project
--        corelog.WriteToLog(">Producing "..itemCount.." "..itemName.."'s in Factory")
        enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
    end
end

function enterprise_factory.Can_ProvideItems_QSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator = InputChecker.Check([[
        This sync public query service answers the question whether the Supplier can provide specific items.

        Return value:
                                    - (table)
                success             - (boolean) whether the answer to the question is true

        Parameters:
            serviceData             - (table) data to the query
                itemsLocator        + (URL) locating the items that need to be queried for providability
                                        (the "base" component of the URL specifies the Supplier that provides the items)
                                        (the "query" component of the URL specifies the items to query for)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_factory.Can_ProvideItems_QSrv: Invalid input") return {success = false} end

    -- check itemsLocator is for this enterprise
    local serviceResults = IsFactoryURL_QSrv({ aURL = itemsLocator})
    if not serviceResults.success then corelog.Error("enterprise_factory.Can_ProvideItems_QSrv: Invalid itemsLocator (="..itemsLocator:getURI()..").") return {success = false} end

    -- loop on items
    local items = itemsLocator:getQuery()
    for itemName, itemCount in pairs(items) do
        -- check
        if type(itemName) ~= "string" then corelog.Error("enterprise_factory.Can_ProvideItems_QSrv: itemName of wrong type = "..type(itemName)..".") return {success = false} end

        -- check for recipe to produce itemName
        local recipe = db.recipes[ itemName ]
        if type(recipe) ~= "table" then
            return {success = false}
        end
    end

    -- end
    return {
        success = true,
    }
end

function enterprise_factory.GetNumberOfSites_Att()
    --[[
        Factory attribute: number of factory sites administered by the enterprise.
    --]]

    -- get sites
    local sites = GetSites()

    -- loop on sites
    local count = 0
    for k, site in pairs(sites) do
        count = count + 1
    end

    return count
end

function enterprise_factory.GetFuelNeed_Production_Att(...)
    -- get & check input from description
    local checkSuccess, items = InputChecker.Check([[
        Factory attribute for the current fuelNeed for producing items. (i.e. it returns the fuelNeed for producing the items
        assuming the ingredients are available in a turtle and the results are to be delivered to the turtle)

        Parameters:
            items   + (table) items to produce
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_factory.GetFuelNeed_Production_Att: Invalid input") return enterprise_energy.GetLargeFuelAmount_Att() end

    -- check there are sites
    if enterprise_factory.GetNumberOfSites_Att() < 1 then corelog.Warning("enterprise_factory.GetFuelNeed_Production_Att: Not sites administered by Factory") return 0 end

    -- create locators
    local itemsLocator = enterprise_factory.GetHostLocator_Att()
    itemsLocator:setQuery(items)
    enterprise_turtle = enterprise_turtle or require "enterprise_turtle"
    local turtleLocator = enterprise_turtle.GetHostLocator_Att()

    -- determine fuelNeed
    local serviceData = {
        itemsLocator                = itemsLocator,
        storageLocator              = turtleLocator:copy(),
        ingredientsSupplierLocator  = turtleLocator:copy(),
    }
    local serviceResults = enterprise_factory.NeedsTo_ProvideItemsTo_SSrv(serviceData)
    if not serviceResults.success then corelog.Error("enterprise_factory.GetFuelNeed_Production_Att: failed obtaining fuel need for production.") return enterprise_energy.GetLargeFuelAmount_Att() end
    local fuelNeed = serviceResults.fuelNeed

    -- end
    return fuelNeed
end

function enterprise_factory.GetSiteLocation_Att(...)
    -- get & check input from description
    local checkSuccess, items = InputChecker.Check([[
        Factory attribute for the location of the current available site for producing items.

        Parameters:
            items   + (table) items to produce
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_factory.GetSiteLocation_Att: Invalid input") return {x=9999, y=9999, z= 9999, dx=0, dy=1} end

    -- check there are sites
    if enterprise_factory.GetNumberOfSites_Att() < 1 then corelog.Warning("enterprise_factory.GetSiteLocation_Att: Not sites administered by Factory") return {x=0, y=0, z= 0, dx=0, dy=1}  end

    -- check for recipe to provide items
    local itemName, itemCount = next(items, nil)
    local recipe = db.recipes[ itemName ]
    if type(recipe) ~= "table" then corelog.Error("enterprise_factory.GetSiteLocation_Att: Provider does not provide "..itemName.."'s") return {x=9999, y=9999, z= 9999, dx=0, dy=1} end

    -- select a suitable site
    local siteProduceItemData = enterprise_factory_site.GetAvailableSiteData(recipe, itemCount)
    if type(siteProduceItemData) ~= "table" then corelog.Error("enterprise_factory.GetSiteLocation_Att: No site available to produce "..itemCount.." "..itemName.."'s") return {x=9999, y=9999, z= 9999, dx=0, dy=1} end
    local location = siteProduceItemData.productionSpot.location

    return location
end

function enterprise_factory.NeedsTo_ProvideItemsTo_SSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, storageLocator, ingredientsSupplierLocator = InputChecker.Check([[
        This sync public service returns the needs for the Supplier to provide specific items to a Storage.

        Return value:
                                            - (table)
                success                     - (boolean) whether the service executed correctly
                fuelNeed                    - (number) amount of fuel needed to provide items
                ingredientsNeed             - (table) ingredients needed to provide items

        Parameters:
            serviceData                     - (table) data to the query
                itemsLocator                + (URL) locating the items to provide
                                                (the "base" component of the URL specifies the Supplier that provides the items)
                                                (the "query" component of the URL specifies the items)
                storageLocator              + (URL) locating the Storage where the items need to be provided to

                ingredientsSupplierLocator  + (URL) locating where ingredients can be retrieved
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_factory.NeedsTo_ProvideItemsTo_SSrv: Invalid input") return {success = false} end

    -- check itemsLocator is for this enterprise
    local serviceResults = IsFactoryURL_QSrv({ aURL = itemsLocator})
    if not serviceResults.success then corelog.Error("enterprise_factory.NeedsTo_ProvideItemsTo_SSrv: Invalid itemsLocator (="..itemsLocator:getURI()..").") return {success = false} end

    -- loop on items
    local fuelNeed = 0
    local ingredientsNeed = {}
    local supplyItems = itemsLocator:getQuery()
    for itemName, itemCount in pairs(supplyItems) do
        -- check
        if type(itemName) ~= "string" then corelog.Error("enterprise_factory.NeedsTo_ProvideItemsTo_SSrv: Invalid itemName (type="..type(itemName)..")") return {success = false} end
        if type(itemCount) ~= "number" then corelog.Error("enterprise_factory.NeedsTo_ProvideItemsTo_SSrv: Invalid itemCount (type="..type(itemCount)..")") return {success = false} end

        -- check for recipe to provide itemName
        local recipe = db.recipes[ itemName ]
        if type(recipe) ~= "table" then corelog.Error("enterprise_factory.NeedsTo_ProvideItemsTo_SSrv: Provider does not provide "..itemName.."'s") return {success = false} end

        -- select a suitable site
        local siteProduceItemData = enterprise_factory_site.GetAvailableSiteData(recipe, itemCount)
        if type(siteProduceItemData) ~= "table" then corelog.Error("enterprise_factory.NeedsTo_ProvideItemsTo_SSrv: No site available to produce "..itemCount.." "..itemName.."'s") return {success = false} end

        -- add ingredientsNeed
        local itemIngredientsNeed = siteProduceItemData.itemsNeeded
        if not enterprise_isp.AddItemsTo(ingredientsNeed, itemIngredientsNeed).success then corelog.Error("enterprise_factory.NeedsTo_ProvideItemsTo_SSrv: Failed adding items "..textutils.serialise(itemIngredientsNeed).." to ingredientsNeed.") return {success = false} end

        -- fuelNeed ingredients
        local ingredientsItemsLocator = ingredientsSupplierLocator:copy()
        ingredientsItemsLocator:setQuery(coreutils.DeepCopy(itemIngredientsNeed))
        local localInputLocator = URL:new(siteProduceItemData.localInputLocator)
        local serviceData = {
            itemsLocator                = ingredientsItemsLocator,
            storageLocator              = localInputLocator,
            ingredientsSupplierLocator  = ingredientsSupplierLocator:copy(),
        }
        serviceResults = enterprise_isp.NeedsTo_ProvideItemsTo_SSrv(serviceData)
        if not serviceResults.success then corelog.Error("enterprise_factory.NeedsTo_ProvideItemsTo_SSrv: Failed obtaining needs for "..ingredientsItemsLocator:getURI().." ingredients") return {success = false} end
        local fuelNeed_IngredientsSupply = serviceResults.fuelNeed

        -- fuelNeed production
        local localInputItemsLocator = localInputLocator:copy()
        localInputItemsLocator:setQuery(coreutils.DeepCopy(itemIngredientsNeed))
        serviceData = {
            localInputItemsLocator  = localInputItemsLocator,
            localOutputLocator      = siteProduceItemData.localOutputLocator:copy(),
            productionMethod        = siteProduceItemData.productionMethod,
            productionSpot          = coreutils.DeepCopy(siteProduceItemData.productionSpot),
        }
        serviceResults = enterprise_factory_site.NeedsTo_ProvideItemsTo_SSrv(serviceData)
        if not serviceResults.success then corelog.Error("enterprise_factory.NeedsTo_ProvideItemsTo_SSrv: Failed obtaining needs for production at site") return {success = false} end
        local fuelNeed_SiteProduction = serviceResults.fuelNeed

        -- fuelNeed output transfer
        local localOutputLocator = URL:new(siteProduceItemData.localOutputLocator)
        local localOutputItemsLocator = localOutputLocator:copy()
        local items = { [itemName] = itemCount }
        localOutputItemsLocator:setQuery(items)
        serviceData = {
            sourceItemsLocator          = localOutputItemsLocator,
            destinationStorageLocator   = storageLocator,
        }
        serviceResults = enterprise_isp.NeedsTo_TransferItems_SSrv(serviceData)
        if not serviceResults.success then corelog.Error("enterprise_factory.NeedsTo_ProvideItemsTo_SSrv: Failed obtaining transfer needs for "..itemCount.." "..itemName.."'s") return {success = false} end
        local fuelNeed_ProductsSupply = serviceResults.fuelNeed

        -- add fuelNeed
--        corelog.WriteToLog("F  fuelNeed_IngredientsSupply="..fuelNeed_IngredientsSupply..", fuelNeed_SiteProduction="..fuelNeed_SiteProduction..", fuelNeed_ProductsSupply="..fuelNeed_ProductsSupply)
        fuelNeed = fuelNeed + fuelNeed_IngredientsSupply + fuelNeed_SiteProduction + fuelNeed_ProductsSupply
    end

    -- end
    return {
        success         = true,
        fuelNeed        = fuelNeed,
        ingredientsNeed = ingredientsNeed,
    }
end

function enterprise_factory.BuildAndStartNewSite_ASrv(...)
    -- get & check input from description
    local checkSuccess, serviceData, upgrade, callback, callbackData = InputChecker.Check([[
        This async public service builds a new factory site and ensures it's ready for use.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the site was succesfully build and is ready for use.

        Parameters:
            serviceData                 + (table) data about this site
                baseLocation            - (table) world location of the base (lower left corner) of this site
                siteVersion             - (string) version string of the site
                upgrade                 + (boolean, false) if site should (only) be updated from a previous version
                materialsHostLocator    - (URL) locating the host of the building materials
            callback                    + (string) name of function to call once service is ready
            callbackData                + (table, {}) data to supply to callback function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_factory.BuildAndStartNewSite_ASrv: Invalid input") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- determine projectSteps
    local projectSteps = { }
    local iStep = 0
    table.insert(projectSteps,
        { stepName = "enterprise_factory.BuildNewSite_ASrv", async = true, stepDataDef = {
            { keyDef = "baseLocation"           , valueSource = 0, keyDefSource = "baseLocation" },
            { keyDef = "siteVersion"            , valueSource = 0, keyDefSource = "siteVersion" },
            { keyDef = "upgrade"                , valueSource = 0, keyDefSource = "upgrade" },
            { keyDef = "materialsHostLocator"   , valueSource = 0, keyDefSource = "materialsHostLocator" },
        }}
    )
    iStep = iStep + 1
    if upgrade then
        table.insert(projectSteps,
            { stepName = "enterprise_factory.StopSite_ASrv", async = true, stepDataDef = {
                { keyDef = "baseLocation"       , valueSource = 0, keyDefSource = "baseLocation" },
            }}
        )
        iStep = iStep + 1
    end
    table.insert(projectSteps,
        { stepName = "enterprise_factory.StartNewSite_SSrv", async = false, stepDataDef = {
            { keyDef = "baseLocation"           , valueSource = 0, keyDefSource = "baseLocation" },
            { keyDef = "siteVersion"            , valueSource = 0, keyDefSource = "siteVersion" },
            { keyDef = "siteAlreadyBuild"       , valueSource = iStep, keyDefSource = "success" }
        }}
    )
    iStep = iStep + 1

    -- create project definition
    local buildAndStartNewSiteProjectDef = {
        steps = projectSteps,
        returnData  = {
            { keyDef = "success"                , valueSource = iStep, keyDefSource = "success" },
        }
    }
    local projectServiceData = {
        projectDef  = buildAndStartNewSiteProjectDef,
        projectData = serviceData,
    }

    -- start project
--    corelog.WriteToLog(">Building and starting factory site version "..siteVersion.." at "..textutils.serialise(baseLocation))
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function enterprise_factory.BuildNewSite_ASrv(...)
    -- get & check input from description
    local checkSuccess, serviceData, baseLocation, siteVersion, upgrade, materialsHostLocator, callback, callbackData = InputChecker.Check([[
        This async public service builds a new factory site.

        Return value:
            nil

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the site was succesfully build

        Parameters:
            serviceData                 + (table) data about this service
                baseLocation            + (table) world location of the base (lower left corner) of this site
                siteVersion             + (string) version string of the site
                upgrade                 + (boolean, false) if site should (only) be updated from a previous version
                materialsHostLocator    + (URL) locating the host of the building materials
            callback                    + (string) name of function to call once service is ready
            callbackData                + (table) data to supply to callback function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_factory.BuildNewSite_ASrv: Invalid input") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- get site build data
    local siteBuildData = nil
    if siteVersion == "v0" then
        siteBuildData = enterprise_factory_site.GetV0SiteBuildData(serviceData)
    elseif siteVersion == "v1" then
        siteBuildData = enterprise_factory_site.GetV1SiteBuildData(serviceData)
    elseif siteVersion == "v2" then
        siteBuildData = enterprise_factory_site.GetV2SiteBuildData(serviceData)
    else
        corelog.Error("enterprise_factory.BuildNewSite_ASrv: Don't know how to build a factory site of version "..siteVersion)
        return MethodExecutor.DoCallback(callback, callbackData, {success = false})
    end
    siteBuildData.materialsHostLocator = materialsHostLocator

    -- let construction enterprise build the site
    if upgrade then
        corelog.WriteToLog(">Upgrading factory site at "..textutils.serialise(baseLocation, { compact = true }).." to version "..siteVersion)
    else
        corelog.WriteToLog(">Building factory site version "..siteVersion.." at "..textutils.serialise(baseLocation, { compact = true }))
    end
    enterprise_construction.BuildBlueprint_ASrv(siteBuildData, callback, callbackData)
end

function enterprise_factory.StartNewSite_SSrv(...)
    -- get & check input from description
    local checkSuccess, serviceData, siteVersion, siteAlreadyBuild = InputChecker.Check([[
        This sync public service ensures a new site is ready for use.

        Return value:
                                    - (table)
                success             - (boolean) whether the site is ready for business

        Parameters:
            serviceData             + (table) data about this service
                baseLocation        - (table) world location of the base (lower left corner) of this site
                siteVersion         + (string) version string of the site
                siteAlreadyBuild    + (boolean) confirmation that the site was already physically build
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_factory.StartNewSite_SSrv: Invalid input") return {success = false} end
    if not siteAlreadyBuild then corelog.Warning("enterprise_factory.StartNewSite_SSrv: Site not (yet) succesfully build => we will not start it") return {success = false} end

    -- get site start data
    local siteStartData = nil
    if siteVersion == "v0" then
        siteStartData = enterprise_factory_site.GetV0SiteStartData(serviceData)
    elseif siteVersion == "v1" then
        siteStartData = enterprise_factory_site.GetV1SiteStartData(serviceData)
    elseif siteVersion == "v2" then
        siteStartData = enterprise_factory_site.GetV2SiteStartData(serviceData)
    else
        corelog.Error("enterprise_factory.BuildNewSite_ASrv: Don't know how to start a factory site of version "..siteVersion)
        return {success = false}
    end

    -- start new site
    local newSiteId = enterprise_factory_site.StartNewSite(siteStartData)
    if type(newSiteId) ~= "string" then corelog.Error('enterprise_factory.StartNewSite_SSrv: Failed starting site from start data '..textutils.serialize(siteStartData)) return {success = false} end

    -- end
    return {success = true}
end

function enterprise_factory.StopAndDismantleSite_ASrv(...)
    -- get & check input from description
    local checkSuccess, serviceData, siteVersion, callback, callbackData = InputChecker.Check([[
        This async public service stops and dismantles a site.

        Return value:
            nil

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the site was succesfully stopped and dismantled.

        Parameters:
            serviceData                 + (table) data about this service
                baseLocation            - (table) world location of the base (lower left corner) of this site
                siteVersion             + (string) version string of the site
                materialsHostLocator    - (URL) locating the host of the building materials
            callback                    + (string) name of function to call once service is ready
            callbackData                + (table, {}) data to supply to callback function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_factory.StopAndDismantleSite_ASrv: Invalid input") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- create project definition
    local stopAndDismantleSiteProjectDef = {
        steps = {
            { stepName = "enterprise_factory.StopSite_ASrv", async = true, stepDataDef = {
                { keyDef = "baseLocation"           , valueSource = 0, keyDefSource = "baseLocation" },
            }},
            { stepName = "enterprise_factory.DismantleSite_ASrv", async = true, stepDataDef = {
                { keyDef = "baseLocation"           , valueSource = 0, keyDefSource = "baseLocation" },
                { keyDef = "siteVersion"            , valueSource = 0, keyDefSource = "siteVersion" },
                { keyDef = "siteStopped"            , valueSource = 1, keyDefSource = "success" },
                { keyDef = "materialsHostLocator"   , valueSource = 0, keyDefSource = "materialsHostLocator" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , valueSource = 2, keyDefSource = "success" },
        }
    }
    local projectServiceData = {
        projectDef  = stopAndDismantleSiteProjectDef,
        projectData = serviceData,
    }

    -- start project
    corelog.WriteToLog(">Stopping and dismantling factory site version "..siteVersion)
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function enterprise_factory.DismantleSite_ASrv(...)
    -- get & check input from description
    local checkSuccess, serviceData, siteVersion, siteStopped, materialsHostLocator, callback, callbackData = InputChecker.Check([[
        This async public service dismantles a factory site. Dismantling means the site is physically removed from minecraft world.
        Possibly part of the world is restored to a neutral (e.g. flat) state.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the site was succesfully dismantled

        Parameters:
            serviceData                 + (table) data about this service
                baseLocation            - (table) world location of the base (lower left corner) of the site
                siteVersion             + (string) version string of the site
                siteStopped             + (boolean) confirmation that the site was already stopped
                materialsHostLocator    + (URL) locating the host of the building materials
            callback                    + (string) name of function to call once service is ready
            callbackData                + (table, {}) data to supply to callback function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_factory.DismantleSite_ASrv: Invalid input") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- check input
    if not siteStopped then corelog.Warning("enterprise_factory.DismantleSite_ASrv: Site not (yet) stopped => we will not dismantle it") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- get site dismantal data
    local siteDismantleBuildData = nil
    if siteVersion == "v0" then
        siteDismantleBuildData = enterprise_factory_site.GetV0SiteDismantleBuildData(serviceData)
-- ToDo implement for v1 and v2
--    elseif siteVersion == "v1" then
--        siteDismantleBuildData = enterprise_factory_site.GetV1SiteDismantleBuildData(serviceData)
--    elseif siteVersion == "v2" then
--        siteDismantleBuildData = enterprise_factory_site.GetV2SiteDismantleBuildData(serviceData)
    else
        corelog.Error("enterprise_factory.DismantleSite_ASrv: Don't know how to dismantle a factory site of version "..siteVersion)
        return MethodExecutor.DoCallback(callback, callbackData, {success = false})
    end
    siteDismantleBuildData.materialsHostLocator = materialsHostLocator

    -- let construction enterprise dismantle the site
    enterprise_construction.BuildBlueprint_ASrv(siteDismantleBuildData, callback, callbackData)
end

function enterprise_factory.StopSite_ASrv(...)
    -- get & check input from description
    local checkSuccess, serviceData, callback, callbackData = InputChecker.Check([[
        This async public service stops a factory site. Stopping implies
          - the site is immediatly no longer available for new business
          - wait for all active work (production) on site to be ended
          - remove the site from the factory

        Return value:
            nil

        Async service return value (to callback):
                                - (table)
                success         - (boolean) when the site was succesfully stopped

        Parameters:
            serviceData         + (table) data about this service
                baseLocation    - (table) world location of the base (lower left corner) of the site
            callback            + (string) name of function to call once service is ready
            callbackData        + (table, {}) data to supply to callback function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_factory.StopSite_ASrv: Invalid input") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- pass on the request to site file
    enterprise_factory_site.StopSite_ASrv(serviceData, callback, callbackData)
end

function enterprise_factory.GetHostLocator_Att()
    --[[
        Attribute locating this enterprise.

        Return value:
            hostLocator             - (URL) locating this enterprise

        Parameters:
            nil
    --]]

    local hostURL = URL:new()
    hostURL:setHost(db.hostName)

    return hostURL
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function IsFactoryURL_QSrv(queryData)
    --[[
        This sync public service answers the question if a URL is that of a Factory.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully

        Parameters:
            queryData               - (table) data about the query
                aURL                - (table) a URL that needs to be queried
    --]]

    -- check input
    if type(queryData) ~= "table" then corelog.Error("enterprise_factory.IsFactoryURL_QSrv: Invalid queryData") return {success = false} end
    local aURL = URL:new(queryData.aURL)
    if type(aURL) ~= "table" then corelog.Error("enterprise_factory.IsFactoryURL_QSrv: Invalid aURL") return {success = false} end

    -- check if of this Supplier
    local host = aURL:getHost()
    if type(host) ~= "string" then corelog.Error("enterprise_factory.IsFactoryURL_QSrv: Invalid host input in URL (="..aURL:getURI()..").") return {success = false} end
    if host == db.hostName then
        return {success = true}
    else
        return {success = false}
    end
end

function enterprise_factory.DeleteSites()
    --[[
        This function deletes all sites from the factory. Currently this is intended for debugging purposes only.

        Return value:
                                - (table)
                success         - (boolean) whether all the sites were removed

        Parameters:
    --]]

    -- get sites
    local sites = GetSites()

    -- remove all assignments
    for siteId, site in pairs(sites) do
        DeleteSite(siteId)
    end

    -- end
    return {success = true}
end

function GetSites()
    -- get sites
    local sites = coredht.GetData(db.hostName, db.psSites)
    if not sites then sites = ResetSites() end

    -- end
    return sites
end

function ResetSites()
    return coredht.SaveData({}, db.hostName, db.psSites)
end

function DeleteSite(siteId)
    --[[
        This function deletes a site from the factory. Currently this is intended for debugging purposes only.

        Return value:
                                - (table)
                success         - (boolean) whether the sites was removed

        Parameters:
            siteId              - (string) id of the site
    --]]

    -- check our input
    if type(siteId) ~= "string" then corelog.Error('enterprise_factory.DeleteSite: Invalid siteId') return {success = false} end

    -- remove site
    corelog.Warning('enterprise_factory.DeleteSite: Removing site '..siteId.." without doing anything with the data, structure and items present")
    coredht.SaveData(nil, db.hostName, db.psSites, siteId)

    -- end
    return {success = true}
end

--          _     _                                              _                        _                 _
--         | |   | |                                            | |                      | |               | |
--     ___ | | __| |  _ __ ___   ___  ___ ___  __ _  __ _  ___  | |__   __ _ ___  ___  __| |   ___ ___   __| | ___
--    / _ \| |/ _` | | '_ ` _ \ / _ \/ __/ __|/ _` |/ _` |/ _ \ | '_ \ / _` / __|/ _ \/ _` |  / __/ _ \ / _` |/ _ \
--   | (_) | | (_| | | | | | | |  __/\__ \__ \ (_| | (_| |  __/ | |_) | (_| \__ \  __/ (_| | | (_| (_) | (_| |  __/
--    \___/|_|\__,_| |_| |_| |_|\___||___/___/\__,_|\__, |\___| |_.__/ \__,_|___/\___|\__,_|  \___\___/ \__,_|\___|
--                                                   __/ |
--                                                  |___/

function NewAlchemieSite(data)
    -- data.location = {x=.., y=.., z=.., dx=.., dy=..}
    -- data.type = "simple" | "regular"
    local enterpriseId   = coreutils.NewId()
    local enterpriseName  = "enterprise_factory"


    -- data verrijken
    data.enterpriseId   = enterpriseId
    data.enterpriseName = enterpriseName
    data.topchests      = {}
    data.furnaces       = {}
    data.taskList       = {}
    data.activeTasks    = {}
    data.craftingTable  = "inventory" -- or {location table} if the site has one

    -- onze gegevens opslaan
    coredht.SaveData(data, "enterprises", enterpriseId)

    -- vacature uitzetten voor een turtle die dit voor ons gaat bouwen
    corejob.NewJob({
        enterpriseId    = enterpriseId,
        location        = coremove.CopyLocation(data.location, 0), -- kopie van locatie van het alchemisten centrum, waar het werk (waarschijnlijk) plaats zal vinden
        startTime       = coreutils.UniversalTime(),
        needTool        = true,
        needTurtle      = true
    })
end

function ProcessNextTask(enterpriseId)
    local taskList          = coredht.GetData("enterprises", enterpriseId, "taskList")
    local taskId, taskTable = next(taskList)

    -- did we get a task?
    if not taskId or type(taskTable) ~= "table" then return end

    -- remove from the task list once completed
    coredht.SaveData(nil, "enterprises", enterpriseId, "taskList", taskId)

    -- execute this command using the task queue
        if taskTable.alchemieType == "craft"    then return coretask.AddWork(role_alchemist.Craft_Task,  taskTable)
    elseif taskTable.alchemieType == "smelt"    then return coretask.AddWork(role_alchemist.Smelt_Task,  taskTable)
    elseif taskTable.alchemieType == "pickup"   then return coretask.AddWork(role_alchemist.Pickup_Task, taskTable)
    end
end

function ProcessNextMessage(enterpriseId)
    -- berichten die we accepteren
    --
    -- {subject="item list", itemName="minecraft:charcoal", itemCount=64} --> returns one or more item lists needed to craft this
    -- {subject="claim chest" } --> return chest loaction and claims chest (or returns nil when no chest is available)
    -- {subject="free chest" }  --> marks the chest as free for new use
    -- {subject="make item", itemName="minecraft:charcoal", itemCount=64, resource="inventory"|{location tabel} } --> will make the items and returns message when complete

    -- retreive next message
    local message       = enterprise.GetNextMessage(enterpriseId)
    if type(message) ~= "table" then return false end

    -- what to do?
    if message.subject == "item list"   then ProcessItemListMessage(message)    end
    if message.subject == "claim chest" then ProcessClaimChestMessage(message)  end
    if message.subject == "free chest"  then ProcessFreeChestMessage(message)   end
    if message.subject == "make item"   then ProcessMakeItemMessage(message)    end

    -- we did something, impressive
    return true
end

function TaskComplete(enterpriseId)
    -- get enterprise data
--    local data          = coredht.GetData("enterprises", enterpriseId)

    -- moeten we nog iets doen nu de task is afgerond? nieuwe job aanmaken
    corejob.NewJob({
        enterpriseId    = enterpriseId,
--        location        = data.location,                -- locatie van het alchemisten centrum, waar het werk (waarschijnlijk) plaats zal vinden
        startTime       = coreutils.UniversalTime(),
        needTool        = false,                        -- geen bijzondere turtle nodig
        needTurtle      = true
    })
end

function ProcessItemListMessage(message)
    -- makes item list needed for crafting / smelting this item
    local messageData   = message.data

    -- valid message?
    if type(messageData.itemName) ~= "string" or type(messageData.itemCount) ~= "number" then corelog.Warning("Received message without required fields") return nil end

    -- do we know this item?
    local recipe = db.recipes[ messageData.itemName ]
    if not recipe then corelog.Warning("No recipe found for "..messageData.itemName) return nil end

    -- to store our reaction
    local responseData  = { possibilities = {} }

    -- via crafting te maken?
    if recipe.crafting then
        local crafting  = recipe.crafting
        local data      = { itemList = {}, output = 0 }

        -- how often do we need to perform this recipe?
        local times = math.ceil( messageData.itemCount / crafting.yield )

        -- calculate all the needed items
        for i=1,16 do

            -- this slot needed for this recipe?
            if crafting[ i ] then

                -- add to list
                data.itemList[ crafting[ i ].itemName ] = (data.itemList[ crafting[ i ].itemName ] or 0) + times * crafting[ i ].itemCount

            end
        end

        -- calculate the output
        data.output = times * crafting.yield

        -- add to responseData
        responseData.possibilities[#responseData.possibilities + 1] = data
    end

    -- via smelting te maken?
    if recipe.smelting then
        local smelting  = recipe.smelting
        local data      = { itemList = {}, output = 0 }

        -- how often do we need to perform this recipe?
        local times = math.ceil( messageData.itemCount / smelting.yield )

        -- add to list
        data.itemList[ smelting.itemName ] = times * smelting.itemCount

        -- calculate the output
        data.output = times * smelting.yield

        -- add to responseData
        responseData.possibilities[#responseData.possibilities + 1] = data
    end

    -- send message back
    enterprise.ReplyToMessage(message, "item list response", responseData)
end

function ProcessClaimChestMessage(message)
    -- get enterprise data
    local enterpriseId  = enterprise.GetMessageRecipient(message)
    local data          = coredht.GetData("enterprises", enterpriseId)
    local topchests     = data.topchests
    local responseData  = {}

    -- look for a free chest
    for chestId, chest in pairs(topchests) do

        -- is this one free?
        if chest.status == "free" then

            -- claim chest
            coredht.SaveData("claimed", "enterprises", enterpriseId, "topchests", chestId, "status")

            -- opslaan
            responseData    = {
                chestId         = chestId,
                chestLocation   = chest.location
            }

            -- rest van de loop niet meer nodig
            break
        end
    end

    -- send message back
    enterprise.ReplyToMessage(message, "claim chest response", responseData)
end

function ProcessFreeChestMessage(message)
    -- voor wie zijn we aan het werk?
    local enterpriseId = enterprise.GetMessageRecipient(message)

    -- check parameters
    if type(message) ~= "table" or type(message.data) ~= table then return nil end

    -- controleren of deze chest wel bestaat
    if coredht.GetData("enterprises", enterpriseId, "topchests", message.data.chestId) then

        -- store new status
        coredht.SaveData("free", "enterprises", enterpriseId, "topchests", message.data.chestId, "status")
    end

    -- geen reactie terug
end

function ProcessMakeItemMessage(message)
    -- message.data.itemName            -- mandatory
    -- message.data.itemCount           -- default: 1
    -- message.data.ingredientsLocation -- "inventory"|{location table}

    -- voor wie zijn we aan het werk?
    local enterpriseId = enterprise.GetMessageRecipient(message)

    -- check parameters
    local messageData               = message.data
    if not type(messageData.itemName) == "string" then return nil end                  -- "minecraft:chest"
    messageData.itemCount           = messageData.itemCount or 1                       -- 8
    messageData.ingredientsLocation = messageData.ingredientsLocation  or "inventory"  -- "inventory"|{location tabel}

    -- check if the item is known in our recipes
    if type(db.recipes[ messageData.itemName ]) ~= "table" then corelog.WriteToLog("No recipe for item "..messageData.itemName) return end

    -- make a copy of the locations
    if type(messageData.ingredientsLocation) == "table" then messageData.ingredientsLocation = coremove.CopyLocation(messageData.ingredientsLocation) end
    local workingLocation   = coremove.CopyLocation(coredht.GetData("enterprises", enterpriseId, "location"))

    -- see if it's crafting (no waiting time) or smelting (waiting time)
    local craftingRecipe    = db.recipes[ messageData.itemName ].crafting
    local smeltingRecipe    = db.recipes[ messageData.itemName ].smelting

    -- get us a nice fresh id
    local taskId            = coreutils.NewId()

    -- for now just one way supported, just crafting
    if craftingRecipe ~= nil then
        coredht.SaveData({
            taskId              = taskId,
            messageId           = enterprise.GetMessageId(message),
            created             = coreutils.UniversalTime(),
            alchemieType        = "craft",
            recipe              = textutils.unserialize(textutils.serialize(craftingRecipe)),
            itemName            = messageData.itemName,
            itemCount           = messageData.itemCount,
            ingredientsLocation = messageData.ingredientsLocation,
            workingLocation     = workingLocation,
        }, "enterprises", enterpriseId, "taskList", taskId)

    -- other way around
    elseif smeltingRecipe then



    else
        -- no recipe known for this item!
    end
end

return enterprise_factory
