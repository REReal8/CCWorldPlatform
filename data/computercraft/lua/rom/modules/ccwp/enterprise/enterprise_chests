local Host = require "obj_host"

local enterprise_chests = Host:new({
    _hostName   = "enterprise_chests",
})

local coreutils = require "coreutils"
local corelog = require "corelog"

local InputChecker = require "input_checker"
local Callback = require "obj_callback"
local Inventory = require "obj_inventory"

local Chest = require "mobj_chest"

--[[
    The chests enterprise provides services to perform operation on chests.

    It provides the following specific enterprise services
        RegisterChest_SSrv      - to register ("add") a chest that can be serviced by this enterprise
        DelistChest_ASrv        - to delist ("remove") a chest from being serviced by this enterprise
        UpdateChestRecord_ASrv  - brings the records of a chest up-to-date by fetching parameters
        GetItemsLocator_SSrv    - provide the URL of items in a chest

    Furthermore, the enterprise functions as both an ItemSupplier and an ItemDepot for chests, hence it provides the mandatory services and functions for the types (like e.g. Can_ProvideItems_QSrv).

    The enterprise does not provide services to build/ dismantle chests. This should be done by other (enterprise) code. In a sense the enterprise_chests is not the
    "owner" of the chests, it just provides services to operate on them.

    The following enterprise design decisions are made
        - Registered chests should never be accessed directly but only via the services of this enterprise.
        - Every chest get's a chestLocator upon registration.
        - To operate on a chest this chestLocator should be supplied to each of the public services.
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function enterprise_chests.RegisterChest_SSrv(...)
    -- get & check input from description
    local checkSuccess, location, accessDirection = InputChecker.Check([[
        This sync public service registers ("adds") a chest to the enterprise.

        Note that the chest should already be present (constructed) in the world. It is however assumed the newly added chest is still empty.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                chestLocator        - (URL) locating the created chest (in this enterprise)

        Parameters:
            chestData               - (table) data to the chest
                location            + (Location) location of the chest
                accessDirection     + (string, "top") whether to access chest from "bottom", "top", "left", "right", "front" or "back" (relative to location)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.RegisterChest_SSrv: Invalid input") return {success = false} end

    -- create new Chest
    local chest = Chest:new({
        _id             = coreutils.NewId(),

        _location       = location:copy(),
        _accessDirection= accessDirection,

        _inventory      = Inventory:new(), -- assumed to be empty
    })

    -- save the Chest
    corelog.WriteToLog(">Registering chest "..chest:getId()..".")
    local chestLocator = enterprise_chests:saveObject(chest)
    if not chestLocator then corelog.Error("enterprise_chests.RegisterChest_SSrv: Failed registering Chest") return {success = false} end

    -- end
    local result = {
        success = true,
        chestLocator = chestLocator
    }
    return result
end

function enterprise_chests.DelistChest_ASrv(...)
    -- get & check input from description
    local checkSuccess, chestLocator, callback = InputChecker.Check([[
        This async public service delists ("removes") a chest from the enterprise. Delisting implies
            - the chest is immediatly no longer available for new business (e.g. adding/ removing items)
            - wait for all active work on chest to be ended
            - remove the chest from the enterprise

        Note that the chest (and it's possibly remaining items) are not removed from the world.

        Return value:
                                - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                - (table)
                success         - (boolean) whether the service executed successfully

        Parameters:
            serviceData         - (table) data about the service
                chestLocator    + (URL) locating the chest
            callback            + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.DelistChest_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- get the chest
    local chest = enterprise_chests:getObject(chestLocator)
    if type(chest) ~="table" then corelog.Error("enterprise_chests.DelistChest_ASrv: Failed retrieving chest = "..chestLocator:getURI()) return Callback.ErrorCall(callback) end

    -- stop doing business for this chest
    -- ToDo: implement

    -- wait for active work done
    -- ToDo: implement

    -- remove site from enteprise
    corelog.WriteToLog(">Delisting Chest "..chest:getId())
    enterprise_chests:deleteResource(chestLocator)

    -- do callback
    return callback:call({success = true})
end

function enterprise_chests.UpdateChestRecord_ASrv(...)
    -- get & check input from description
    local checkSuccess, chestLocator, callback = InputChecker.Check([[
        This async public service brings the records of a chest up-to-date by fetching information and (re)setting the chest records.

        Using this method should normally not be needed as the records should be kept up-to-date by the various enterprise services. It could
        typically be used for development purposes or, if for some reason (e.g. after a turtle crash), the chest records could have been corrupted.

        Return value:
                                - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                - (table)
                success         - (boolean) whether the service executed successfully

        Parameters:
            serviceData         - (table) data about the service
                chestLocator    + (URL) locating the chest
            callback            + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.UpdateChestRecord_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- get chest
    local chest = enterprise_chests:getObject(chestLocator)
    if type(chest) ~= "table" then corelog.Error("enterprise_chests.UpdateChestRecord_ASrv: Chest "..chestLocator:getURI().." not found.") return Callback.ErrorCall(callback) end

    -- have chest update it's records
    return chest:updateChestRecord_AOSrv({}, callback)
end

function enterprise_chests.GetItemsLocator_SSrv(...)
    -- get & check input from description
    local checkSuccess, chestLocator, itemsQuery = InputChecker.Check([[
        This sync public services provides the URL of items in a chest in the enterprise.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                itemsLocator        - (URL) locating the items in a chest

        Parameters:
            serviceData             - (table) data for this service
                chestLocator        + (URL) locating a chest
                itemsQuery          + (table) optional items to locate in chest
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.GetItemsLocator_SSrv: Invalid input") return {success = false} end

    -- construct URL
    local itemsLocator = chestLocator:copy()
    itemsLocator:setQuery(itemsQuery)

    -- end
    local result = {
        success = true,
        itemsLocator = itemsLocator,
    }
    return result
end

function enterprise_chests.ProvideItemsTo_ASrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, itemDepotLocator, assignmentsPriorityKey, callback = InputChecker.Check([[
        This async public ItemSupplier service provides specific items to an ItemDepot.

        Return value:
                                                - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                                - (table)
                success                         - (boolean) whether the service executed correctly
                destinationItemsLocator         - (URL) locating the final ItemDepot and the items that where transferred to it
                                                    (upon service succes the "host" component of this URL should be equal to itemDepotLocator, and
                                                    the "query" should be equal to orderItems)

        Parameters:
            serviceData                         - (table) data for the service
                itemsLocator                    + (URL) locating the items to provide
                                                    (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                                    (the "query" component of the URL specifies the items)
                itemDepotLocator                + (URL) locating the ItemDepot where the items need to be provided to
                ingredientsItemSupplierLocator  - (URL) locating where the production ingredients can be retrieved
                assignmentsPriorityKey          + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                            + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.ProvideItemsTo_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- get Obj
    local obj = enterprise_chests:getObject(itemsLocator)
    if type(obj) ~= "table" then corelog.Error("enterprise_chests.ProvideItemsTo_ASrv: Obj "..itemsLocator:getURI().." not found.") return Callback.ErrorCall(callback) end

    -- have Obj provide items
    local provideItems = itemsLocator:getQuery()
    return obj:provideItemsTo_AOSrv({
        provideItems                    = provideItems,
        itemDepotLocator                = itemDepotLocator,
        assignmentsPriorityKey          = assignmentsPriorityKey,
    }, callback)
end

function enterprise_chests.Can_ProvideItems_QSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator = InputChecker.Check([[
        This sync public query service answers the question whether the ItemSupplier can provide specific items.

        Return value:
                                    - (table)
                success             - (boolean) whether the answer to the question is true

        Parameters:
            serviceData             - (table) data to the query
                itemsLocator        + (URL) locating the items that need to be queried for providability
                                        (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                        (the "query" component of the URL specifies the items to query for)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.Can_ProvideItems_QSrv: Invalid input") return {success = false} end

    -- get Obj
    local obj = enterprise_chests:getObject(itemsLocator)
    if type(obj) ~= "table" then corelog.Error("enterprise_chests.Can_ProvideItems_QSrv: Obj "..itemsLocator:getURI().." not found.") return {success = false} end

    -- check Obj can provide items
    local provideItems = itemsLocator:getQuery()
    local canProvide = obj:can_ProvideItems_QOSrv({
        provideItems    = provideItems,
    })

    -- end
    return canProvide
end

function enterprise_chests.NeedsTo_ProvideItemsTo_SSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, itemDepotLocator = InputChecker.Check([[
        This sync public service returns the needs for the ItemSupplier to provide specific items to an ItemDepot.

        Return value:
                                                - (table)
                success                         - (boolean) whether the service executed correctly
                fuelNeed                        - (number) amount of fuel needed to provide items
                ingredientsNeed                 - (table) ingredients needed to provide items

        Parameters:
            serviceData                         - (table) data to the query
                itemsLocator                    + (URL) locating the items to provide
                                                    (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                                    (the "query" component of the URL specifies the items)
                itemDepotLocator                + (URL) locating the ItemDepot where the items need to be provided to

                ingredientsItemSupplierLocator  - (URL) locating where ingredients can be retrieved
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.NeedsTo_ProvideItemsTo_SSrv: Invalid input") return {success = false} end

    -- get Obj
    local obj = enterprise_chests:getObject(itemsLocator)
    if type(obj) ~= "table" then corelog.Error("enterprise_chests.NeedsTo_ProvideItemsTo_SSrv: Obj "..itemsLocator:getURI().." not found.") return {success = false} end

    -- determine needs
    local provideItems = itemsLocator:getQuery()
    local needs = obj:needsTo_ProvideItemsTo_SOSrv({
        provideItems    = provideItems,
        itemDepotLocator= itemDepotLocator,
    })

    -- end
    return needs
end

function enterprise_chests.StoreItemsFrom_ASrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, itemDepotLocator, assignmentsPriorityKey, callback = InputChecker.Check([[
        This async public ItemDepot service stores items from from an ItemSupplier into an ItemDepot.

        An ItemDepot should take special care the transfer from the turtle inventory gets priority over other assignments to the turtle.

        Return value:
                                        - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                destinationItemsLocator - (URL) stating the final ItemDepot and the items that where where stored
                                            (upon service succes the "base" component of this URL should be equal to itemDepotLocator
                                            and the "query" should be equal to the "query" component of the itemsLocator)

        Parameters:
            serviceData                 - (table) data about the service
                itemsLocator            + (URL) locating the items to store
                                            (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                            (the "query" component of the URL specifies the items)
                itemDepotLocator        + (URL) locating the ItemDepot where the items need to be stored to
                assignmentsPriorityKey  + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                    + (Callback) to call once service is ready
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.StoreItemsFrom_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- get Obj
    local obj = enterprise_chests:getObject(itemDepotLocator)
    if type(obj) ~= "table" then corelog.Error("enterprise_chests.ProvideItemsTo_ASrv: Obj "..itemDepotLocator:getURI().." not found.") return Callback.ErrorCall(callback) end

    -- have Obj store items
    return obj:storeItemsFrom_AOSrv({
        itemsLocator                    = itemsLocator,
        assignmentsPriorityKey          = assignmentsPriorityKey,
    }, callback)
end

function enterprise_chests.Can_StoreItems_QSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator = InputChecker.Check([[
        This sync public query service answers the question whether the ItemDepot can store specific items.

        Return value:
                                    - (table)
                success             - (boolean) whether the answer to the question is true

        Parameters:
            serviceData             - (table) data to the query
                itemsLocator        + (URL) locating the items that need to be stored
                                        (the "base" component of the URL specifies the ItemDepot to store the items in)
                                        (the "query" component of the URL specifies the items to query for)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.Can_StoreItems_QSrv: Invalid input") return {success = false} end

    -- get Obj
    local obj = enterprise_chests:getObject(itemsLocator)
    if type(obj) ~= "table" then corelog.Error("enterprise_chests.Can_StoreItems_QSrv: Obj "..itemsLocator:getURI().." not found.") return {success = false} end

    -- check Obj can store items
    local storeItems = itemsLocator:getQuery()
    local canStore = obj:can_StoreItems_QOSrv({
        storeItems    = storeItems,
    })

    -- end
    return canStore
end

function enterprise_chests.NeedsTo_StoreItemsFrom_SSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, itemDepotLocator = InputChecker.Check([[
        This sync public service returns the needs for the ItemDepot to store specific items from an ItemSupplier.

        Return value:
                                                - (table)
                success                         - (boolean) whether the service executed correctly
                fuelNeed                        - (number) amount of fuel needed to store items

        Parameters:
            serviceData                         - (table) data to the query
                itemsLocator                    + (URL) locating the items to store
                                                    (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                                    (the "query" component of the URL specifies the items)
                itemDepotLocator                + (URL) locating the ItemDepot where the items need to be stored to
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.NeedsTo_StoreItemsFrom_SSrv: Invalid input") return {success = false} end

    -- get Obj
    local obj = enterprise_chests:getObject(itemDepotLocator)
    if type(obj) ~= "table" then corelog.Error("enterprise_chests.NeedsTo_StoreItemsFrom_SSrv: Obj "..itemDepotLocator:getURI().." not found.") return {success = false} end

    -- determine needs
    local needs = obj:needsTo_StoreItemsFrom_SOSrv({
        itemsLocator    = itemsLocator,
    })

    -- end
    return needs
end

-- ToDo: consider getting from/ moving to Chest
function enterprise_chests.GetItemsLocations_SSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator = InputChecker.Check([[
        This sync public service provides the current world locations of different items in an ItemDepot.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                locations           - (table) with Location's of the different items

        Parameters:
            serviceData             - (table) data about this service
                itemsLocator        + (URL) locating the items for which to get the location
                                        (the "base" component of the URL specifies the ItemDepot that provides the items)
                                        (the "query" component of the URL specifies the items)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.GetItemsLocations_SSrv: Invalid input") return {success = false} end

    -- get chest
    local chest = enterprise_chests:getObject(itemsLocator)
    if type(chest) ~= "table" then corelog.Error("enterprise_chests.GetItemsLocations_SSrv: Chest "..itemsLocator:getURI().." not found.") return {success = false} end

    -- get location
    local location = chest:getLocation()

    -- end
    return {
        success     = true,
        locations   = { location:copy() },
    }
end

-- ToDo: consider getting from/ moving to Chest
function enterprise_chests.GetItemDepotLocation_SSrv(...)
    -- get & check input from description
    local checkSuccess, itemDepotLocator = InputChecker.Check([[
        This sync public service provides the world location of an ItemDepot.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                location            - (Location) location of the ItemDepot

        Parameters:
            serviceData             - (table) data about this service
                itemDepotLocator    + (URL) locating the ItemDepot for which to get the location
                                        (the "base" component of the URL should specify this ItemDepot enterprise)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.GetItemDepotLocation_SSrv: Invalid input") return {success = false} end

    -- get chest
    local chest = enterprise_chests:getObject(itemDepotLocator)
    if type(chest) ~= "table" then corelog.Error("enterprise_chests.GetItemDepotLocation_SSrv: Chest "..itemDepotLocator:getURI().." not found.") return {success = false} end

    -- get location
    local location = chest:getLocation()

    -- end
    return {
        success     = true,
        location    = location:copy(),
    }
end

return enterprise_chests
