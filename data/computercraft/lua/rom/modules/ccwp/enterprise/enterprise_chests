local Host = require "obj_host"

local enterprise_chests = Host:new({
    _hostName   = "enterprise_chests",
})

local coreutils = require "coreutils"
local corelog = require "corelog"

local InputChecker = require "input_checker"
local Callback = require "obj_callback"
local Inventory = require "obj_inventory"

local Chest = require "mobj_chest"

--[[
    The enterprise_chests provides services to perform operation on chests.

    It provides the following specific enterprise services
        RegisterChest_SSrv      - to register ("add") a chest that can be serviced by this enterprise
        DelistChest_ASrv        - to delist ("remove") a chest from being serviced by this enterprise
        UpdateChestRecord_ASrv  - brings the records of a chest up-to-date by fetching parameters
        GetItemsLocator_SSrv    - provide the URL of items in a chest

    The enterprise does not provide services to build/ dismantle chests. This should be done by other (enterprise) code. In a sense the enterprise_chests is not the
    "owner" of the chests, it just provides services to operate on them.

    The following enterprise design decisions are made
        - Registered chests should never be accessed directly but only via the services of this enterprise.
        - Every chest get's a chestLocator upon registration.
        - To operate on a chest this chestLocator should be supplied to each of the public services.
--]]

--                        _                           _   _               _
--                       (_)                         | | | |             | |
--    ___  ___ _ ____   ___  ___ ___   _ __ ___   ___| |_| |__   ___   __| |___
--   / __|/ _ \ '__\ \ / / |/ __/ _ \ | '_ ` _ \ / _ \ __| '_ \ / _ \ / _` / __|
--   \__ \  __/ |   \ V /| | (_|  __/ | | | | | |  __/ |_| | | | (_) | (_| \__ \
--   |___/\___|_|    \_/ |_|\___\___| |_| |_| |_|\___|\__|_| |_|\___/ \__,_|___/

function enterprise_chests.RegisterChest_SSrv(...)
    -- get & check input from description
    local checkSuccess, location, accessDirection = InputChecker.Check([[
        This sync public service registers ("adds") a Chest to the enterprise.

        Note that the Chest should already be present (constructed) in the world. It is however assumed the newly added Chest is still empty.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                chestLocator        - (URL) locating the created Chest (in this enterprise)

        Parameters:
            chestData               - (table) data to the Chest
                location            + (Location) location of the Chest
                accessDirection     + (string, "top") whether to access chest from "bottom", "top", "left", "right", "front" or "back" (relative to location)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.RegisterChest_SSrv: Invalid input") return {success = false} end

    -- create new Obj
    local obj = Chest:new({
        _id             = coreutils.NewId(),

        _location       = location:copy(),
        _accessDirection= accessDirection,

        _inventory      = Inventory:new(), -- assumed to be empty
    })

    -- save the Obj
    corelog.WriteToLog(">Registering Chest "..obj:getId()..".")
    local objLocator = enterprise_chests:saveObject(obj)
    if not objLocator then corelog.Error("enterprise_chests.RegisterChest_SSrv: Failed registering Obj") return {success = false} end

    -- end
    local result = {
        success = true,
        chestLocator = objLocator
    }
    return result
end

function enterprise_chests.DelistChest_ASrv(...)
    -- get & check input from description
    local checkSuccess, chestLocator, callback = InputChecker.Check([[
        This async public service delists ("removes") a Chest from the enterprise. Delisting implies
            - the Chest is immediatly no longer available for new business (e.g. adding/ removing items)
            - wait for all active work on Chest to be ended
            - remove the Chest from the enterprise

        Note that the Chest (and it's possibly remaining items) are not removed from the world.

        Return value:
                                - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                - (table)
                success         - (boolean) whether the service executed successfully

        Parameters:
            serviceData         - (table) data about the service
                chestLocator    + (URL) locating the Chest
            callback            + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.DelistChest_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- get the Obj
    local obj = enterprise_chests:getObject(chestLocator)
    if type(obj) ~="table" then corelog.Error("enterprise_chests.DelistChest_ASrv: Obj "..chestLocator:getURI().." not found.") return Callback.ErrorCall(callback) end

    -- stop doing business for this Obj
    -- ToDo: implement

    -- wait for active work done
    -- ToDo: implement

    -- remove Obj from enteprise
    corelog.WriteToLog(">Delisting Chest "..obj:getId())
    enterprise_chests:deleteResource(chestLocator)

    -- do callback
    return callback:call({success = true})
end

function enterprise_chests.UpdateChestRecord_ASrv(...)
    -- get & check input from description
    local checkSuccess, chestLocator, callback = InputChecker.Check([[
        This async public service brings the records of a chest up-to-date by fetching information and (re)setting the chest records.

        Using this method should normally not be needed as the records should be kept up-to-date by the various enterprise services. It could
        typically be used for development purposes or, if for some reason (e.g. after a turtle crash), the chest records could have been corrupted.

        Return value:
                                - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                - (table)
                success         - (boolean) whether the service executed successfully

        Parameters:
            serviceData         - (table) data about the service
                chestLocator    + (URL) locating the chest
            callback            + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.UpdateChestRecord_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- get chest
    local chest = enterprise_chests:getObject(chestLocator)
    if type(chest) ~= "table" then corelog.Error("enterprise_chests.UpdateChestRecord_ASrv: Chest "..chestLocator:getURI().." not found.") return Callback.ErrorCall(callback) end

    -- have chest update it's records
    return chest:updateChestRecord_AOSrv({}, callback)
end

-- ToDo: consider getting from/ moving to Chest
function enterprise_chests.GetItemsLocations_SSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator = InputChecker.Check([[
        This sync public service provides the current world locations of different items in an ItemDepot.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                locations           - (table) with Location's of the different items

        Parameters:
            serviceData             - (table) data about this service
                itemsLocator        + (URL) locating the items for which to get the location
                                        (the "base" component of the URL specifies the ItemDepot that provides the items)
                                        (the "query" component of the URL specifies the items)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.GetItemsLocations_SSrv: Invalid input") return {success = false} end

    -- get chest
    local chest = enterprise_chests:getObject(itemsLocator)
    if type(chest) ~= "table" then corelog.Error("enterprise_chests.GetItemsLocations_SSrv: Chest "..itemsLocator:getURI().." not found.") return {success = false} end

    -- get location
    local location = chest:getLocation()

    -- end
    return {
        success     = true,
        locations   = { location:copy() },
    }
end

-- ToDo: consider getting from/ moving to Chest
function enterprise_chests.GetItemDepotLocation_SSrv(...)
    -- get & check input from description
    local checkSuccess, itemDepotLocator = InputChecker.Check([[
        This sync public service provides the world location of an ItemDepot.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                location            - (Location) location of the ItemDepot

        Parameters:
            serviceData             - (table) data about this service
                itemDepotLocator    + (URL) locating the ItemDepot for which to get the location
                                        (the "base" component of the URL should specify this ItemDepot enterprise)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_chests.GetItemDepotLocation_SSrv: Invalid input") return {success = false} end

    -- get chest
    local chest = enterprise_chests:getObject(itemDepotLocator)
    if type(chest) ~= "table" then corelog.Error("enterprise_chests.GetItemDepotLocation_SSrv: Chest "..itemDepotLocator:getURI().." not found.") return {success = false} end

    -- get location
    local location = chest:getLocation()

    -- end
    return {
        success     = true,
        location    = location:copy(),
    }
end

return enterprise_chests
