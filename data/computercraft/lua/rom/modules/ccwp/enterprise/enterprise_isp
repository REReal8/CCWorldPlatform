local enterprise_isp = {}
local corelog = require "corelog"

local InputChecker = require "input_checker"
local Callback = require "obj_callback"
local MethodExecutor = require "method_executor"
local URL = require "obj_url"

local role_fuel_worker = require "role_fuel_worker"

local enterprise_projects = require "enterprise_projects"

--[[
    The Item Service Provider (ISP) is an enterprise that provides services to handle items. From the perspective of an enterprise that needs
    items to be handled across (possibly) multiple enterprises the ISP can be seen as a generic entrypoint (or hub or router) for handling
    those items.

    For an enterprise to be a Supplier it needs to implement the following services:
        ProvideItemsTo_ASrv         - providing multiple instances of a specific item to a Storage destination.
        Can_ProvideItems_QSrv       - answers the question whether the Supplier can provide specific items.
        NeedsTo_ProvideItemsTo_SSrv - return the needs for the Supplier to provide specific items to a Storage.

    For an enterprise to be a Storage it needs to implement the following services:
        GetItemsLocations_SSrv      - provides the current world locations of different items in a Storage.
        GetStorageLocation_SSrv     - provides the world location of a Storage.
        GetItemsIntoTurtle_ASrv     - ensuring items are gathered in the Storage and transferred to the inventory of a turtle.
        PutItemsFromTurtle_ASrv     - ensuring items are transferred from the inventory of a turtle to the Storage.

    Furthermore most Suppliers and Storages should implement the additional attribute
        GetHostLocator_Att          - locating this enterprise

    The ISP offers generic Supplier and Storage services by relaying them to the underlying Supplier or Storage based on the "base" component of URL's. The interface
    of the corresponding ISP services is the same. Hence, one could see the ISP as a Supplier and Storage itself.

    The ISP provides the following additional public services
        TransferItemsFromTo_ASrv    - transferring items from one Storage to another.
        NeedsTo_TransferItems_SSrv  - returns the (fuel) needs for the transfer of items from one Storage to another.
        AddItemsLocators_SSrv       - adds the items of multiple itemsLocators into one itemsLocator. The itemsLocators should have the same host/ base component.
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function enterprise_isp.ProvideItemsTo_ASrv(...)
    -- get & check input from description
    local checkSuccess, serviceData, itemsLocator, callback = InputChecker.Check([[
        This async public Supplier service provides multiple instances of a specific to the requested Storage.

        Return value:
            nil

        Async service return value (to Callback):
                                            - (table)
                success                     - (boolean) whether the service executed correctly
                destinationItemsLocator     - (URL) locating the final Storage and the items that where transferred to it
                                                (upon service succes the "host" component of this URL should be equal to storageLocator, and
                                                the "query" should be equal to orderItems)

        Parameters:
            serviceData                     + (table) data for the service
                itemsLocator                + (URL) locating the items to provide
                                                (the "base" component of the URL specifies the Supplier that provides the items)
                                                (the "query" component of the URL specifies the items)
                storageLocator              - (URL) locating the Storage where the items need to be provided to
                ingredientsSupplierLocator  - (URL) locating where the production ingredients can be retrieved
                assignmentsPriorityKey      - (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                        + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_isp.ProvideItemsTo_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- get Supplier
    local serviceResults = GetSupplierName_SSrv( { supplierLocator = itemsLocator })
    if not serviceResults.success then corelog.Error("enterprise_isp.ProvideItemsTo_ASrv: failed obtaining supplierName for "..itemsLocator:getURI()..".") return Callback.ErrorCall(callback) end
    local supplierName = serviceResults.enterpriseName

    -- call method on Supplier
    local serviceName = "ProvideItemsTo_ASrv"
    return MethodExecutor.DoASyncService(supplierName, serviceName, serviceData, callback)
end

function enterprise_isp.Can_ProvideItems_QSrv(...)
    -- get & check input from description
    local checkSuccess, serviceData, itemsLocator = InputChecker.Check([[
        This sync public query service answers the question whether the Supplier can provide specific items.

        Return value:
                                    - (table)
                success             - (boolean) whether the answer to the question is true

        Parameters:
            serviceData             + (table) data to the query
                itemsLocator        + (URL) locating the items that need to be queried for providability
                                        (the "base" component of the URL specifies the Supplier that provides the items)
                                        (the "query" component of the URL specifies the items to query for)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_isp.Can_ProvideItems_QSrv: Invalid input") return {success = false} end

    -- get Supplier
    local serviceResults = GetSupplierName_SSrv( { supplierLocator = itemsLocator })
    if not serviceResults.success then corelog.Error("enterprise_isp.Can_ProvideItems_QSrv: failed obtaining supplierName for "..itemsLocator:getURI()..".") return {success = false} end
    local supplierName = serviceResults.enterpriseName

    -- call method on Supplier
    local serviceName = "Can_ProvideItems_QSrv"
    serviceResults = MethodExecutor.DoSyncService(supplierName, serviceName, serviceData)

    -- end
    return serviceResults
end

function enterprise_isp.NeedsTo_ProvideItemsTo_SSrv(...)
    -- get & check input from description
    local checkSuccess, serviceData, itemsLocator = InputChecker.Check([[
        This sync public service returns the needs for a Supplier to provide specific items to a Storage.

        Return value:
                                            - (table)
                success                     - (boolean) whether the service executed correctly
                fuelNeed                    - (number) amount of fuel needed to provide items
                ingredientsNeed             - (table) ingredients needed to provide items

        Parameters:
            serviceData                     + (table) data to the query
                itemsLocator                + (URL) locating the items to provide
                                                (the "base" component of the URL specifies the Supplier that provides the items)
                                                (the "query" component of the URL specifies the items)
                storageLocator              - (URL) locating the Storage where the items need to be delivered to

                ingredientsSupplierLocator  - (URL) optionally locating another Supplier where needed ingredient items for the Supplier could be retrieved
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_isp.NeedsTo_ProvideItemsTo_SSrv: Invalid input") return {success = false} end

    -- get Supplier
    local serviceResults = GetSupplierName_SSrv( { supplierLocator = itemsLocator })
    if not serviceResults.success then corelog.Error("enterprise_isp.NeedsTo_ProvideItemsTo_SSrv: failed obtaining supplierName for "..itemsLocator:getURI()..".") return {success = false} end
    local supplierName = serviceResults.enterpriseName

    -- call method on Supplier
    local serviceName = "NeedsTo_ProvideItemsTo_SSrv"
    serviceResults = MethodExecutor.DoSyncService(supplierName, serviceName, serviceData)

    -- end
    return serviceResults
end

function enterprise_isp.TransferItemsFromTo_ASrv(...)
    -- get & check input from description
    local checkSuccess, sourceItemsLocator, destinationStorageLocator, assignmentsPriorityKey, callback = InputChecker.Check([[
        This async public service relays the transfer of items from one Storage to another.

        This service is implemented using the following underlying Storage services
            GetItemsIntoTurtle_ASrv
            PutItemsFromTurtle_ASrv

        Return value:
            nil

        Async service return value (to Callback):
                                            - (table)
                success                     - (boolean) whether the service executed successfully
                destinationItemsLocator     - (URL) stating the final Storage and the items that where transferred to it
                                                (upon service succes the "host" component of this URL should be equal to destinationStorageLocator, and
                                                the "query" should be equal to the "query" component of the sourceItemsLocator)

        Parameters:
            transferData                    - (table) data about the transfer
                sourceItemsLocator          + (URL) locating the items that need transfer
                                                (the "query" component of the URL specifies the items to be transferred)
                                                (the "host" component of the URL specifies the Storage where the items are located)
                destinationStorageLocator   + (URL) locating the Storage that needs to be transferred to
                assignmentsPriorityKey      + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                        + (Callback) to call once service is ready
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_isp.TransferItemsFromTo_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- get source Storage
    local serviceResults = GetStorageName_SSrv( { storageLocator = sourceItemsLocator })
    if not serviceResults.success then corelog.Error("enterprise_isp.TransferItemsFromTo_ASrv: failed obtaining storageName for "..sourceItemsLocator:getURI()..".") return Callback.ErrorCall(callback) end
    local sourceStorageName = serviceResults.enterpriseName

    -- get target Storage
    serviceResults = GetStorageName_SSrv( { storageLocator = destinationStorageLocator })
    if not serviceResults.success then corelog.Error("enterprise_isp.TransferItemsFromTo_ASrv: failed obtaining storageName for "..destinationStorageLocator:getURI()..".") return Callback.ErrorCall(callback) end
    local destinationStorageName = serviceResults.enterpriseName

    -- check there are actual items to transfer
    local transferItems = sourceItemsLocator:getQuery()
    if next(transferItems) == nil then
        corelog.Warning("enterprise_isp.TransferItemsFromTo_ASrv: There are 0 items to transfer (from "..sourceItemsLocator:getURI().." to "..destinationStorageLocator:getURI()..").")
        return callback:call({
            success                 = true,
            destinationItemsLocator = destinationStorageLocator:copy()
        })
    end

    -- create project definition
    local transferItemsProjectDef = {
        steps   = {
            { stepType = "ASrv", stepTypeDef = { moduleName = sourceStorageName, serviceName = "GetItemsIntoTurtle_ASrv" }, stepDataDef = {
                { keyDef = "sourceItemsLocator"         , sourceStep = 0, sourceKeyDef = "sourceItemsLocator" },
                { keyDef = "assignmentsPriorityKey"     , sourceStep = 0, sourceKeyDef = "assignmentsPriorityKey" },
            }},
            { stepType = "ASrv", stepTypeDef = { moduleName = destinationStorageName, serviceName = "PutItemsFromTurtle_ASrv" }, stepDataDef = {
                { keyDef = "turtleItemsLocator"         , sourceStep = 1, sourceKeyDef = "turtleItemsLocator" },
                { keyDef = "destinationHostLocator"     , sourceStep = 0, sourceKeyDef = "destinationStorageLocator" },
                { keyDef = "assignmentsPriorityKey"     , sourceStep = 0, sourceKeyDef = "assignmentsPriorityKey" },
            }},
            { stepType = "SSrv", stepTypeDef = { moduleName = "enterprise_projects", serviceName = "AreAllTrue_QSrv" }, stepDataDef = {
                { keyDef = "success1"                   , sourceStep = 1, sourceKeyDef = "success" },
                { keyDef = "success2"                   , sourceStep = 2, sourceKeyDef = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                        , sourceStep = 3, sourceKeyDef = "success" },
            { keyDef = "destinationItemsLocator"        , sourceStep = 2, sourceKeyDef = "destinationItemsLocator" },
        }
    }
    local projectData = {
        sourceItemsLocator          = sourceItemsLocator,
        destinationStorageLocator   = destinationStorageLocator,

        assignmentsPriorityKey      = assignmentsPriorityKey,
    }
    local projectServiceData = {
        projectDef  = transferItemsProjectDef,
        projectData = projectData,
    }

    -- start project
    enterprise_projects.StartProject_ASrv(projectServiceData, callback)

    -- end
    return nil
end

function enterprise_isp.NeedsTo_TransferItems_SSrv(...)
    -- get & check input from description
    local checkSuccess, sourceItemsLocator, destinationStorageLocator = InputChecker.Check([[
        This sync public service returns the (fuel) needs for the transfer of items from one Storage to another.

        This service is implemented using the following underlying Storage services
            GetItemsLocations_SSrv
            GetStorageLocation_SSrv

        Return value:
                                            - (table)
                success                     - (boolean) whether the service executed successfully
                fuelNeed                    - (number) amount of fuel needed to transfer the items

        Parameters:
            transferData                    - (table) data about the transfer
                sourceItemsLocator          + (URL) locating the items that need transfer
                                                (the "query" component of the URL specifies the items to be transferred)
                                                (the "host" component of the URL specifies the Storage where the items are located)
                destinationStorageLocator   + (URL) locating the Storage that needs to be transferred to
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_isp.NeedsTo_TransferItems_SSrv: Invalid input") return {success = false} end

    -- check there are actual items to transfer
    local transferItems = sourceItemsLocator:getQuery()
    if next(transferItems) == nil then
        corelog.Warning("enterprise_isp.NeedsTo_TransferItems_SSrv: There are 0 items to transfer (from "..sourceItemsLocator:getURI().." to "..destinationStorageLocator:getURI()..").")
        return {
            success     = true,
            fuelNeed    = 0,
        }
    end

    -- determine sourceItemsLocations
    local serviceResults = enterprise_isp.GetItemsLocations_SSrv({ itemsLocator = sourceItemsLocator })
    if not serviceResults.success then corelog.Error("enterprise_isp.NeedsTo_TransferItems_SSrv: failed obtaining locations for items "..sourceItemsLocator:getURI()..".") return {success = false} end
    local itemsLocations = serviceResults.locations

    -- determine destinationLocation
    serviceResults = enterprise_isp.GetStorageLocation_SSrv({ storageLocator = destinationStorageLocator })
    if not serviceResults.success then corelog.Error("enterprise_isp.NeedsTo_TransferItems_SSrv: failed obtaining location for Storage "..destinationStorageLocator:getURI()..".") return {success = false} end
    local storageLocation = serviceResults.location

    -- determine fuelNeed
    local fuelNeed = 0
    for i, itemlocation in ipairs(itemsLocations) do
        -- ToDo: consider how to handle if path isn't the shortest route, should we maybe modify things to do something like GetTravelDistanceBetween
        fuelNeed = fuelNeed + role_fuel_worker.NeededFuelToFrom(storageLocation, itemlocation)
    end

    -- end
    return {
        success     = true,
        fuelNeed    = fuelNeed,
    }
end

function enterprise_isp.GetItemsLocations_SSrv(...)
    -- get & check input from description
    local checkSuccess, serviceData, itemsLocator = InputChecker.Check([[
        This sync public service provides the current world locations of different items in a Storage.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                locations           - (table) with locations of the different items

        Parameters:
            serviceData             + (table) data about this service
                itemsLocator        + (URL) locating the items for which to get the location
                                        (the "base" component of the URL specifies the Storage that provides the items)
                                        (the "query" component of the URL specifies the items)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_isp.GetItemsLocations_SSrv: Invalid input") return {success = false} end

    -- get Storage
    local serviceResults = GetStorageName_SSrv( { storageLocator = itemsLocator })
    if not serviceResults.success then corelog.Error("enterprise_isp.GetItemsLocations_SSrv: failed obtaining storageName for "..itemsLocator:getURI()..".") return {success = false} end
    local storageName = serviceResults.enterpriseName

    -- call method on Storage
    local serviceName = "GetItemsLocations_SSrv"
    serviceResults = MethodExecutor.DoSyncService(storageName, serviceName, serviceData)

    -- end
    return serviceResults
end

function enterprise_isp.GetStorageLocation_SSrv(...)
    -- get & check input from description
    local checkSuccess, serviceData, storageLocator = InputChecker.Check([[
        This sync public service provides the world location of a Storage.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                location            - (table) location of the Storage

        Parameters:
            serviceData             + (table) data about this service
                storageLocator      + (URL) locating the Storage for which to get the location
                                        (the "base" component of the URL should specify a Storage enterprise)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_isp.GetStorageLocation_SSrv: Invalid input") return {success = false} end

    -- get Storage
    local serviceResults = GetStorageName_SSrv( { storageLocator = storageLocator })
    if not serviceResults.success then corelog.Error("enterprise_isp.GetStorageLocation_SSrv: failed obtaining storageName for "..storageLocator:getURI()..".") return {success = false} end
    local storageName = serviceResults.enterpriseName

    -- call method on Storage
    local serviceName = "GetStorageLocation_SSrv"
    serviceResults = MethodExecutor.DoSyncService(storageName, serviceName, serviceData)

    -- end
    return serviceResults
end

function enterprise_isp.AddItemsLocators_SSrv(serviceData)
    --[[
        This sync public service adds the items of multiple itemsLocators into one itemsLocator. The itemsLocators should have the same host/ base component.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                itemsLocator        - (URL) locating all items

        Parameters:
            serviceData             - (table) data about the query
                itemsLocator1       - (URL) a itemsLocator locating items
                                        (the "base" component of the URL specifies the host to query)
                                        (the "query" component of the URL specifies the items to query for)
                [itemsLocator2]     - (URL) another itemsLocator locating items
                [itemsLocatorN]     - (URL) and the final itemsLocator locating items
    --]]

    -- check input
    if type(serviceData) ~= "table" then corelog.Error("enterprise_isp.AddItemsLocators_SSrv: Invalid queryData") return {success = false} end

--    local itemsLocator = queryData.itemsLocator
--    if type(itemsLocator) ~= "table" then corelog.Error("enterprise_isp.AddItemsLocators_SSrv: Invalid itemsLocator") return {success = false} end

    -- use remaining input
    local allTrue = true
    local resultItemsLocator = nil
    for fieldKey, fieldvalue in pairs(serviceData) do
        -- check if it's a URL
        if type(fieldvalue) == "table" then
            -- wrap into URL
            local fieldItemsLocator = URL:new(fieldvalue)

            -- check if first
            if resultItemsLocator == nil then
                -- copy first
                resultItemsLocator = fieldItemsLocator:copy()
            else
                -- check if same host/ base as resultItemsLocator so far
                if not fieldItemsLocator:sameBase(resultItemsLocator) then
                    corelog.Error("enterprise_isp.AddItemsLocators_SSrv: Adding itemsLocator's (resultItemsLocator="..resultItemsLocator:getURI()..", fieldItemsLocator="..fieldItemsLocator:getURI()..") with different base not supported")
                    return {success = false}
                end

                -- add query component's
                local resultItemQuery = resultItemsLocator:getQuery()
                enterprise_isp.AddItemsTo(resultItemQuery, fieldItemsLocator:getQuery())
            end
        else
            corelog.Warning("enterprise_isp.AddItemsLocators_SSrv: Invalid fieldvalue (type="..type(fieldvalue)..")")
        end
    end
    if resultItemsLocator == nil then corelog.Error("enterprise_isp.AddItemsLocators_SSrv: Couldn't construct combined itemsLocator") return {success = false} end

    -- end
    local result = {
        success = allTrue,
        itemsLocator = resultItemsLocator
    }
    return result
end

function enterprise_isp.AddItemsTo(items, itemsToAdd)
    --[[
        This sync public function adds the items of itemsToAdd to items.

        Return value:
                                - (table)
                success         - (boolean) whether the function executed successfully

        Parameters:
            items               - (table) with one or more items (formatted as an array of [itemName] = itemCount key-value pairs)
            itemsToAdd          - (table) with one or more items (formatted as an array of [itemName] = itemCount key-value pairs) to add
    --]]

    -- check input
    if type(items) ~= "table" then corelog.Error("enterprise_isp.AddItemsTo: Invalid items") return {success = false} end
    if type(itemsToAdd) ~= "table" then corelog.Error("enterprise_isp.AddItemsTo: Invalid itemsToAdd") return {success = false} end

    -- add items
    for itemName, itemCount in pairs(itemsToAdd) do
        -- check
        if type(itemName) ~= "string" then corelog.Error("enterprise_isp.AddItemsTo: Invalid itemName (type="..type(itemName)..")") return {success = false} end
        if type(itemCount) ~= "number" then corelog.Error("enterprise_isp.AddItemsTo: Invalid itemCount (type="..type(itemCount)..")") return {success = false} end

        -- add
        items[itemName] = (items[itemName] or 0) + itemCount
    end

    -- end
    return {success = true}
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function GetSupplierName_SSrv(...)
    -- get & check input from description
    local checkSuccess, supplierLocator = InputChecker.Check([[
        This sync private service provides the (enterprise) name of a Supplier.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                enterpriseName      - (string) with (enterprise) name of the Supplier

        Parameters:
            serviceData             - (table) data about this service
                supplierLocator     + (URL) locating the Supplier
                                        (the "base" component of the URL should specify a Supplier enterprise)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_isp.GetSupplierName_SSrv: Invalid input") return {success = false} end

    -- determine enterpriseName
    local host = supplierLocator:getHost()
    if type(host) ~= "string" then corelog.Error("enterprise_isp.GetSupplierName_SSrv: host of wrong type = "..type(host)..".") return {success = false} end
    local enterpriseName = nil
        if host == "enterprise_chests"  then enterpriseName = "enterprise_chests"
    elseif host == "enterprise_forestry"then enterpriseName = "enterprise_forestry"
    elseif host == "enterprise_factory" then enterpriseName = "enterprise_factory"
    elseif host == "enterprise_shop"    then enterpriseName = "enterprise_shop"
    elseif host == "enterprise_turtle"  then enterpriseName = "enterprise_turtle"
    else corelog.Error("enterprise_isp.GetSupplierName_SSrv: Not implemented for "..host .." host.") return {success = false} end

    -- end
    return {
        success         = true,
        enterpriseName  = enterpriseName,
    }
end

function GetStorageName_SSrv(...)
    -- get & check input from description
    local checkSuccess, storageLocator = InputChecker.Check([[
        This sync private service provides the (enterprise) name of a Storage.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                enterpriseName      - (string) with (enterprise) name of the Storage

        Parameters:
            serviceData             - (table) data about this service
                storageLocator      + (URL) locating the Storage
                                        (the "base" component of the URL should specify a Storage enterprise)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_isp.GetStorageName_SSrv: Invalid input") return {success = false} end

    -- determine Storage name
    local host = storageLocator:getHost()
    if type(host) ~= "string" then corelog.Error("enterprise_isp.GetStorageName_SSrv: storageHost of wrong type = "..type(host)..".") return {success = false} end
    local enterpriseName = nil
        if host == "enterprise_chests"  then enterpriseName = "enterprise_chests"
    elseif host == "enterprise_turtle"  then enterpriseName = "enterprise_turtle"
    else corelog.Error("enterprise_isp.GetStorageName_SSrv: Not implemented for "..host .." host.") return {success = false} end

    -- end
    return {
        success         = true,
        enterpriseName  = enterpriseName,
    }
end

return enterprise_isp
