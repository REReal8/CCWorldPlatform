local t_shop = {}

local corelog = require "corelog"

local Callback = require "obj_callback"

local Location = require "obj_location"
local URL = require "obj_url"

local T_Chest = require "test.t_mobj_chest"

local enterprise_chests = require "enterprise_chests"
local enterprise_shop = require "enterprise_shop"

local t_turtle = require "test.t_turtle"

function t_shop.T_All()
    -- base methods

    -- specific methods
    t_shop.T_RegisterItemSupplier()
    t_shop.T_DelistItemSupplier()
    t_shop.T_DelistItemSuppliers()
    t_shop.T_BestItemSupplier()

    -- service methods
end

local compact = { compact = true }

local function ProvideItemsTo_ASrv_Test(provideItems)
    -- prepare test (cont)
    corelog.WriteToLog("* enterprise_shop:ProvideItemsTo_ASrv() test (of "..textutils.serialize(provideItems, compact)..")")
--    local obj = T_Chest.CreateChest(location1:getRelativeLocation(2, 5, 0)) if not obj then corelog.Error("failed obtaining Chest") return end
    local itemsLocator = enterprise_shop.GetShopLocator()
    itemsLocator:setQuery(provideItems)
    local itemDepotLocator = t_turtle.GetCurrentTurtleLocator()
    local ingredientsItemSupplierLocator = enterprise_shop.GetShopLocator()
--    local chestLocator = enterprise_chests:getObjectLocator(obj)

    local expectedDestinationItemsLocator = itemDepotLocator:copy()
    expectedDestinationItemsLocator:setQuery(provideItems)
    local callback2 = Callback:new({
        _moduleName     = "t_shop",
        _methodName     = "provideItemsTo_ASrv_Callback",
        _data           = {
            ["expectedDestinationItemsLocator"] = expectedDestinationItemsLocator,
--            ["chestLocator"]                    = chestLocator,
        },
    })

    -- test
    local scheduleResult = enterprise_shop.ProvideItemsTo_ASrv({
        itemsLocator                    = itemsLocator,
        itemDepotLocator                = itemDepotLocator,
        ingredientsItemSupplierLocator  = ingredientsItemSupplierLocator,
    }, callback2)
    assert(scheduleResult == true, "failed to schedule async service")
end

function t_shop.provideItemsTo_ASrv_Callback(callbackData, serviceResults)
    -- test (cont)
    assert(serviceResults.success, "failed executing async service")

    local destinationItemsLocator = URL:new(serviceResults.destinationItemsLocator)
    local expectedDestinationItemsLocator = URL:new(callbackData["expectedDestinationItemsLocator"])
    assert(destinationItemsLocator:isSame(expectedDestinationItemsLocator), "gotten destinationItemsLocator(="..textutils.serialize(destinationItemsLocator, compact)..") not the same as expected(="..textutils.serialize(expectedDestinationItemsLocator, compact)..")")

    -- cleanup test
--    local chestLocator = callbackData["chestLocator"]
--    enterprise_chests:deleteResource(chestLocator)

    -- end
    return true
end

function t_shop.T_ProvideMultipleItems()
    -- prepare test
    local provideItems = {
        ["minecraft:furnace"]   = 1,
        ["minecraft:charcoal"]  = 1, -- ToDo: test if furnace get produced once charcoal is being smelted (as soon as projects support parallel steps)
    }

    -- test
    ProvideItemsTo_ASrv_Test(provideItems)
end

function t_shop.T_ProvideCharcoal()
    -- prepare test
    local provideItems = {
        ["minecraft:charcoal"]  = 3,
    }

    -- test
    ProvideItemsTo_ASrv_Test(provideItems)
end

function t_shop.T_ProvideTorch()
    -- prepare test
    local provideItems = {
        ["minecraft:torch"]  = 4,
    }

    -- test
    ProvideItemsTo_ASrv_Test(provideItems)
end

function t_shop.T_RegisterItemSupplier()
    -- prepare test
    corelog.WriteToLog("* enterprise_shop.RegisterItemSupplier_SSrv() tests")
    local originalNItemSuppliers = #enterprise_shop.GetItemSuppliers()
    local itemSupplierLocator = t_turtle.GetCurrentTurtleLocator()

    -- test
    local result = enterprise_shop.RegisterItemSupplier_SSrv({ itemSupplierLocator = itemSupplierLocator})
    assert(result.success == true, "RegisterItemSupplier_SSrv services failed")
    local nItemSuppliers = #enterprise_shop.GetItemSuppliers()
    local expectedNItemSuppliers = originalNItemSuppliers + 1
    assert(nItemSuppliers == expectedNItemSuppliers, "gotten nItemSuppliers(="..nItemSuppliers..") not the same as expected(="..expectedNItemSuppliers..")")

    -- cleanup test
end

function t_shop.T_DelistItemSupplier()
    -- prepare test
    corelog.WriteToLog("* enterprise_shop.DelistItemSupplier_SSrv tests")
    local originalNItemSuppliers = #enterprise_shop.GetItemSuppliers()
    local itemSupplierLocator = t_turtle.GetCurrentTurtleLocator()

    -- test
    local result = enterprise_shop.DelistItemSupplier_SSrv({ itemSupplierLocator = itemSupplierLocator})
    assert(result.success == true, "DelistItemSupplier_SSrv services failed")
    local nItemSuppliers = #enterprise_shop.GetItemSuppliers()
    local expectedNItemSuppliers = originalNItemSuppliers - 1
    assert(nItemSuppliers == expectedNItemSuppliers, "gotten nItemSuppliers(="..nItemSuppliers..") not the same as expected(="..expectedNItemSuppliers..")")

    -- cleanup test
end

function t_shop.T_DelistItemSuppliers()
    -- prepare test
    corelog.WriteToLog("* enterprise_shop.DelistItemSuppliers tests")

    -- test
    enterprise_shop.DelistItemSuppliers()
    local nItemSuppliers = #enterprise_shop.GetItemSuppliers()
    local expectedNItemSuppliers = 0
    assert(nItemSuppliers == expectedNItemSuppliers, "gotten nItemSuppliers(="..nItemSuppliers..") not the same as expected(="..expectedNItemSuppliers..")")
end

function t_shop.T_BestItemSupplier()
    -- prepare test
    corelog.WriteToLog("* enterprise_shop.BestItemSupplier() tests")
    local item = {
        ["minecraft:birch_log"]  = 5,
    }
    local ingredientsItemSupplierLocator = enterprise_shop.GetShopLocator()
    local location1 = Location:new({_x= 10, _y= 0, _z= 1, _dx=0, _dy=1})
    local chest = T_Chest.CreateChest(location1) if not chest then corelog.Error("failed obtaining Chest") return end
    local itemDepotLocator = enterprise_chests:saveObject(chest)

    -- test lowest fuelNeed
    local closeLocation = location1:getRelativeLocation(1, 1, 0)
    chest = T_Chest.CreateChest(closeLocation) if not chest then corelog.Error("failed obtaining Chest") return end
    local closeItemSupplierLocator = enterprise_chests:saveObject(chest)
    local result = enterprise_shop.RegisterItemSupplier_SSrv({ itemSupplierLocator = closeItemSupplierLocator}) assert(result.success == true, "RegisterItemSupplier_SSrv services failed")

    local farLocation = location1:getRelativeLocation(99999, 1, 0)
    chest = T_Chest.CreateChest(farLocation) if not chest then corelog.Error("failed obtaining Chest") return end
    local farItemSupplierLocator = enterprise_chests:saveObject(chest)
    result = enterprise_shop.RegisterItemSupplier_SSrv({ itemSupplierLocator = farItemSupplierLocator}) assert(result.success == true, "RegisterItemSupplier_SSrv services failed")

    local bestItemSupplierLocator = enterprise_shop.BestItemSupplier(item, itemDepotLocator, ingredientsItemSupplierLocator, farItemSupplierLocator, closeItemSupplierLocator)
    local expectedItemSupplierLocator = closeItemSupplierLocator
    assert(bestItemSupplierLocator:isSame(expectedItemSupplierLocator), "gotten BestItemSupplier(="..textutils.serialize(bestItemSupplierLocator, compact)..") not the same as expected(="..textutils.serialize(expectedItemSupplierLocator, compact)..")")

    -- cleanup test
    enterprise_chests:deleteResource(itemDepotLocator)
    enterprise_shop.DelistItemSupplier_SSrv({ itemSupplierLocator = closeItemSupplierLocator})
    enterprise_chests:deleteResource(closeItemSupplierLocator)
    enterprise_shop.DelistItemSupplier_SSrv({ itemSupplierLocator = farItemSupplierLocator})
    enterprise_chests:deleteResource(farItemSupplierLocator)
end

return t_shop
