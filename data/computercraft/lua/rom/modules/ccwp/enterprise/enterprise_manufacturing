local Host = require "obj_host"

local enterprise_manufacturing = Host:new({
    _hostName   = "enterprise_manufacturing",
})

local coreutils = require "coreutils"
local corelog = require "corelog"

local InputChecker = require "input_checker"
local Callback = require "obj_callback"
local URL = require "obj_url"

local ProductionSpot = require "mobj_production_spot"
local Factory = require "mobj_factory"

local enterprise_projects = require "enterprise_projects"
local enterprise_isp = require "enterprise_isp"
local enterprise_turtle
local enterprise_energy = require "enterprise_energy"
local enterprise_construction = require "enterprise_construction"

local db = {
    -- turtle slots
    -- [ 1] [ 2] [ 3] [ 4]
    -- [ 5] [ 6] [ 7] [ 8]
    -- [ 9] [10] [11] [12]
    -- [13] [14] [15] [16]
    recipes        = {
        ["minecraft:stick"] = {
            crafting  = {
                  [6]    = { itemName = "minecraft:birch_planks",   itemCount = 1 },
                 [10]    = { itemName = "minecraft:birch_planks",   itemCount = 1 },
                yield   = 4
            },
        },
        ["minecraft:charcoal"] = { -- ToDo consider similar format to crafting to simpify code
            smelting  = {
                itemName    = "minecraft:birch_log",
--                itemCount   = 1,
                yield       = 1,
            },
        },
        ["minecraft:torch"] = {
            crafting  = {
                 [6]    = { itemName = "minecraft:charcoal",        itemCount = 1 },
                [10]    = { itemName = "minecraft:stick",           itemCount = 1 },
               yield   = 4
           },
        },
        ["minecraft:birch_planks"] = {
            crafting  = {
                 [6]    = { itemName = "minecraft:birch_log",       itemCount = 1 },
                yield   = 4
            },
        },
        ["minecraft:chest"] = {
            crafting  = {
                 [6]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                 [7]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                 [8]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [10]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [12]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [14]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [15]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                [16]    = { itemName = "minecraft:birch_planks",    itemCount = 1 },
                yield   = 1
            },
        },
        ["minecraft:furnace"] = {
            crafting  = {
                 [6]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                 [7]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                 [8]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [10]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [12]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [14]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [15]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                [16]    = { itemName = "minecraft:cobblestone",    itemCount = 1 },
                yield   = 1
            },
        },
    }
}

--[[
    The manufacturing enterprise offers services to produce items based on recipes.

    This enterprise is an ItemSupplier, hence it provides the mandatory services and functions for an ItemSupplier (like e.g. ProvideItemsTo_ASrv).

    There are (currently) two recipe types for producing items.
        The crafting recipe uses the crafting production technique to produce an output item from a set of input items (ingredients).
        The smelting recipe uses the smelting production technique to produce an output item from an input item (ingredient).

    The enterprise is a Host. It hosts one or more Factory's. It uses the production services of the Factory's to produce the items.
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function enterprise_manufacturing.ProvideItemsTo_ASrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, itemDepotLocator, ingredientsItemSupplierLocator, assignmentsPriorityKey, callback = InputChecker.Check([[
        This async public ItemSupplier service provides specific items to an ItemDepot.

        It does so by first determining recipes that can produce the items. Subsequently it retrieves the needed production ingredients.
        After that it produces the requested amount of items with the production method (i.e. crafting or smelting) corresponding to the recipes.
        Finally it delivers the created items to the requested ItemDepot.

        Return value:
                                                - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                                - (table)
                success                         - (boolean) whether the service executed correctly
                destinationItemsLocator         - (URL) locating the final ItemDepot and the items that where transferred to it
                                                    (upon service succes the "host" component of this URL should be equal to itemDepotLocator, and
                                                    the "query" should be equal to orderItems)

        Parameters:
            serviceData                         - (table) data for the service
                itemsLocator                    + (URL) locating the items to provide
                                                    (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                                    (the "query" component of the URL specifies the items)
                itemDepotLocator                + (URL) locating the ItemDepot where the items need to be provided to
                ingredientsItemSupplierLocator  + (URL) locating where the production ingredients can be retrieved
                assignmentsPriorityKey          + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                            + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_manufacturing.ProvideItemsTo_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- check itemsLocator is for this enterprise
    if not enterprise_manufacturing:isLocatorFromHost(itemsLocator) then corelog.Error("enterprise_manufacturing.ProvideItemsTo_ASrv: Invalid itemsLocator (="..itemsLocator:getURI()..").") return Callback.ErrorCall(callback) end

    -- loop on items
    local scheduleResult = true
    local provideItems = itemsLocator:getQuery()
    for itemName, itemCount in pairs(provideItems) do
        -- check
        if type(itemName) ~= "string" then corelog.Error("enterprise_manufacturing.ProvideItemsTo_ASrv: Invalid itemName (type="..type(itemName)..")") return Callback.ErrorCall(callback) end
        if type(itemCount) ~= "number" then corelog.Error("enterprise_manufacturing.ProvideItemsTo_ASrv: Invalid itemCount (type="..type(itemCount)..")") return Callback.ErrorCall(callback) end

        -- select recipe to produce item
        local recipe = db.recipes[ itemName ]
        if type(recipe) ~= "table" then corelog.Error("enterprise_manufacturing.ProvideItemsTo_ASrv: No recipe for item "..itemName) return Callback.ErrorCall(callback) end

        -- select a suitable site
        local siteProduceItemData = Factory.GetAvailableSiteData(recipe, itemCount)
        if type(siteProduceItemData) ~= "table" then corelog.Error("enterprise_manufacturing.ProvideItemsTo_ASrv: No site available to produce "..itemCount.." "..itemName.."'s") return Callback.ErrorCall(callback) end

        -- determine ingredientsItemsLocator (by updating ingredientsItemSupplierLocator with itemsNeeded)
        local ingredientsItemsLocator = ingredientsItemSupplierLocator:copy()
        ingredientsItemsLocator:setQuery(coreutils.DeepCopy(siteProduceItemData.itemsNeeded))

        -- retrieve site input & output locator's
        local localInputLocator = URL:new(siteProduceItemData.localInputLocator)
        local localOutputLocator = URL:new(siteProduceItemData.localOutputLocator)

        -- create project service data
        local projectDef = {
            steps = {
                { stepType = "ASrv", stepTypeDef = { moduleName = "enterprise_isp", serviceName = "ProvideItemsTo_ASrv" }, stepDataDef = {
                    { keyDef = "itemsLocator"                   , sourceStep = 0, sourceKeyDef = "ingredientsItemsLocator" },
                    { keyDef = "itemDepotLocator"               , sourceStep = 0, sourceKeyDef = "localInputLocator" },
                    { keyDef = "ingredientsItemSupplierLocator" , sourceStep = 0, sourceKeyDef = "ingredientsItemSupplierLocator" },
                    { keyDef = "assignmentsPriorityKey"         , sourceStep = 0, sourceKeyDef = "assignmentsPriorityKey" },
                }},
                { stepType = "ASrv", stepTypeDef = { moduleName = "Factory", serviceName = "ProduceItem_ASrv" }, stepDataDef = {
                    { keyDef = "localInputItemsLocator"         , sourceStep = 1, sourceKeyDef = "destinationItemsLocator" },
                    { keyDef = "localOutputLocator"             , sourceStep = 0, sourceKeyDef = "localOutputLocator" },
                    { keyDef = "productionMethod"               , sourceStep = 0, sourceKeyDef = "productionMethod" },
                    { keyDef = "productionSpot"                 , sourceStep = 0, sourceKeyDef = "productionSpot" },
                    { keyDef = "productItemName"                , sourceStep = 0, sourceKeyDef = "itemName" },
                    { keyDef = "productItemCount"               , sourceStep = 0, sourceKeyDef = "itemCount" },
                    { keyDef = "productionRecipe"               , sourceStep = 0, sourceKeyDef = "productionRecipe" },
                    { keyDef = "assignmentsPriorityKey"         , sourceStep = 0, sourceKeyDef = "assignmentsPriorityKey" },
                }},
                { stepType = "ASrv", stepTypeDef = { moduleName = "enterprise_isp", serviceName = "StoreItemsFrom_ASrv" }, stepDataDef = {
                    { keyDef = "itemsLocator"                   , sourceStep = 2, sourceKeyDef = "localOutputItemsLocator" },
                    { keyDef = "itemDepotLocator"               , sourceStep = 0, sourceKeyDef = "itemDepotLocator" },
                    { keyDef = "assignmentsPriorityKey"         , sourceStep = 0, sourceKeyDef = "assignmentsPriorityKey" },
                }},
                -- ToDo: consider storing rest/ waste materials (e.g. those caused by ceil (rounding up) of ingredient items)
                { stepType = "SSrv", stepTypeDef = { moduleName = "enterprise_projects", serviceName = "AreAllTrue_QSrv" }, stepDataDef = {
                    { keyDef = "success1"                       , sourceStep = 1, sourceKeyDef = "success" },
                    { keyDef = "success2"                       , sourceStep = 2, sourceKeyDef = "success" },
                    { keyDef = "success3"                       , sourceStep = 3, sourceKeyDef = "success" },
                }},
            },
            returnData  = {
                { keyDef = "success"                            , sourceStep = 4, sourceKeyDef = "success" },
                { keyDef = "destinationItemsLocator"            , sourceStep = 3, sourceKeyDef = "destinationItemsLocator" },
            }
        }
        local projectData = {
            ingredientsItemSupplierLocator  = ingredientsItemSupplierLocator:copy(),

            ingredientsItemsLocator         = ingredientsItemsLocator,
            itemDepotLocator                = itemDepotLocator,

            localInputLocator               = localInputLocator,
            localOutputLocator              = localOutputLocator,

            productionMethod                = siteProduceItemData.productionMethod,
            productionSpot                  = siteProduceItemData.productionSpot,
            itemName                        = itemName,
            itemCount                       = itemCount,
            productionRecipe                = siteProduceItemData.productionRecipe,

            assignmentsPriorityKey          = assignmentsPriorityKey,
        }
        local projectServiceData = {
            projectDef  = projectDef,
            projectData = projectData,
        }

        -- start project
--        corelog.WriteToLog(">Producing "..itemCount.." "..itemName.."'s in Factory")
        scheduleResult = scheduleResult and enterprise_projects.StartProject_ASrv(projectServiceData, callback)
    end

    -- end
    return scheduleResult
end

function enterprise_manufacturing.Can_ProvideItems_QSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator = InputChecker.Check([[
        This sync public query service answers the question whether the ItemSupplier can provide specific items.

        Return value:
                                    - (table)
                success             - (boolean) whether the answer to the question is true

        Parameters:
            serviceData             - (table) data to the query
                itemsLocator        + (URL) locating the items that need to be queried for providability
                                        (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                        (the "query" component of the URL specifies the items to query for)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_manufacturing.Can_ProvideItems_QSrv: Invalid input") return {success = false} end

    -- check itemsLocator is for this enterprise
    if not enterprise_manufacturing:isLocatorFromHost(itemsLocator) then corelog.Error("enterprise_manufacturing.Can_ProvideItems_QSrv: Invalid itemsLocator (="..itemsLocator:getURI()..").") return {success = false} end

    -- loop on items
    local items = itemsLocator:getQuery()
    for itemName, itemCount in pairs(items) do
        -- check
        if type(itemName) ~= "string" then corelog.Error("enterprise_manufacturing.Can_ProvideItems_QSrv: itemName of wrong type = "..type(itemName)..".") return {success = false} end

        -- check for recipe to produce itemName
        local recipe = db.recipes[ itemName ]
        if type(recipe) ~= "table" then
            return {success = false}
        end
    end

    -- end
    return {
        success = true,
    }
end

function enterprise_manufacturing.GetFuelNeed_Production_Att(...)
    -- get & check input from description
    local checkSuccess, items = InputChecker.Check([[
        Factory attribute for the current fuelNeed for producing items. (i.e. it returns the fuelNeed for producing the items
        assuming the ingredients are available in a turtle and the results are to be delivered to the turtle)

        Parameters:
            items   + (table) items to produce
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_manufacturing.GetFuelNeed_Production_Att: Invalid input") return enterprise_energy.GetLargeFuelAmount_Att() end

    -- check there are sites
    if enterprise_manufacturing:getNumberOfObjects("Factory") < 1 then corelog.Warning("enterprise_manufacturing.GetFuelNeed_Production_Att: Not sites administered by enterprise") return 0 end

    -- create locators
    local itemsLocator = enterprise_manufacturing:getHostLocator()
    itemsLocator:setQuery(items)
    enterprise_turtle = enterprise_turtle or require "enterprise_turtle"
    local turtleLocator = enterprise_turtle.GetHostLocator_Att()

    -- determine fuelNeed
    local serviceData = {
        itemsLocator                    = itemsLocator,
        itemDepotLocator                = turtleLocator:copy(),
        ingredientsItemSupplierLocator  = turtleLocator:copy(),
    }
    local serviceResults = enterprise_manufacturing.NeedsTo_ProvideItemsTo_SSrv(serviceData)
    if not serviceResults.success then corelog.Error("enterprise_manufacturing.GetFuelNeed_Production_Att: failed obtaining fuel need for production.") return enterprise_energy.GetLargeFuelAmount_Att() end
    local fuelNeed = serviceResults.fuelNeed

    -- end
    return fuelNeed
end

function enterprise_manufacturing.GetSiteLocation_Att(...)
    -- get & check input from description
    local checkSuccess, items = InputChecker.Check([[
        Factory attribute for the location of the current available site for producing items.

        Parameters:
            items   + (table) items to produce
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_manufacturing.GetSiteLocation_Att: Invalid input") return {_x=9999, _y=9999, _z= 9999, _dx=0, _dy=1} end

    -- check there are sites
    if enterprise_manufacturing:getNumberOfObjects("Factory") < 1 then corelog.Warning("enterprise_manufacturing.GetSiteLocation_Att: Not sites administered by enterprise") return {_x=0, _y=0, _z= 0, _dx=0, _dy=1}  end

    -- check for recipe to provide items
    local itemName, itemCount = next(items, nil)
    local recipe = db.recipes[ itemName ]
    if type(recipe) ~= "table" then corelog.Error("enterprise_manufacturing.GetSiteLocation_Att: Provider does not provide "..itemName.."'s") return {_x=9999, _y=9999, _z= 9999, _dx=0, _dy=1} end

    -- select a suitable site
    local siteProduceItemData = Factory.GetAvailableSiteData(recipe, itemCount)
    if type(siteProduceItemData) ~= "table" then corelog.Error("enterprise_manufacturing.GetSiteLocation_Att: No site available to produce "..itemCount.." "..itemName.."'s") return {_x=9999, _y=9999, _z= 9999, _dx=0, _dy=1} end
    local location = siteProduceItemData.productionSpot:getLocation()

    return location
end

function enterprise_manufacturing.NeedsTo_ProvideItemsTo_SSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, itemDepotLocator, ingredientsItemSupplierLocator = InputChecker.Check([[
        This sync public service returns the needs for the ItemSupplier to provide specific items to an ItemDepot.

        Return value:
                                                - (table)
                success                         - (boolean) whether the service executed correctly
                fuelNeed                        - (number) amount of fuel needed to provide items
                ingredientsNeed                 - (table) ingredients needed to provide items

        Parameters:
            serviceData                         - (table) data to the query
                itemsLocator                    + (URL) locating the items to provide
                                                    (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                                    (the "query" component of the URL specifies the items)
                itemDepotLocator                + (URL) locating the ItemDepot where the items need to be provided to

                ingredientsItemSupplierLocator  + (URL) locating where ingredients can be retrieved
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_manufacturing.NeedsTo_ProvideItemsTo_SSrv: Invalid input") return {success = false} end

    -- check itemsLocator is for this enterprise
    if not enterprise_manufacturing:isLocatorFromHost(itemsLocator) then corelog.Error("enterprise_manufacturing.NeedsTo_ProvideItemsTo_SSrv: Invalid itemsLocator (="..itemsLocator:getURI()..").") return {success = false} end

    -- loop on items
    local fuelNeed = 0
    local ingredientsNeed = {}
    local supplyItems = itemsLocator:getQuery()
    for itemName, itemCount in pairs(supplyItems) do
        -- check
        if type(itemName) ~= "string" then corelog.Error("enterprise_manufacturing.NeedsTo_ProvideItemsTo_SSrv: Invalid itemName (type="..type(itemName)..")") return {success = false} end
        if type(itemCount) ~= "number" then corelog.Error("enterprise_manufacturing.NeedsTo_ProvideItemsTo_SSrv: Invalid itemCount (type="..type(itemCount)..")") return {success = false} end

        -- check for recipe to provide itemName
        local recipe = db.recipes[ itemName ]
        if type(recipe) ~= "table" then corelog.Error("enterprise_manufacturing.NeedsTo_ProvideItemsTo_SSrv: Provider does not provide "..itemName.."'s") return {success = false} end

        -- select a suitable site
        local siteProduceItemData = Factory.GetAvailableSiteData(recipe, itemCount)
        if type(siteProduceItemData) ~= "table" then corelog.Error("enterprise_manufacturing.NeedsTo_ProvideItemsTo_SSrv: No site available to produce "..itemCount.." "..itemName.."'s") return {success = false} end

        -- add ingredientsNeed
        local itemIngredientsNeed = siteProduceItemData.itemsNeeded
        if not enterprise_isp.AddItemsTo(ingredientsNeed, itemIngredientsNeed).success then corelog.Error("enterprise_manufacturing.NeedsTo_ProvideItemsTo_SSrv: Failed adding items "..textutils.serialise(itemIngredientsNeed).." to ingredientsNeed.") return {success = false} end

        -- fuelNeed ingredients
        local ingredientsItemsLocator = ingredientsItemSupplierLocator:copy()
        ingredientsItemsLocator:setQuery(coreutils.DeepCopy(itemIngredientsNeed))
        local localInputLocator = URL:new(siteProduceItemData.localInputLocator)
        local serviceData = {
            itemsLocator                    = ingredientsItemsLocator,
            itemDepotLocator                = localInputLocator,
            ingredientsItemSupplierLocator  = ingredientsItemSupplierLocator:copy(),
        }
        local serviceResults = enterprise_isp.NeedsTo_ProvideItemsTo_SSrv(serviceData)
        if not serviceResults.success then corelog.Error("enterprise_manufacturing.NeedsTo_ProvideItemsTo_SSrv: Failed obtaining needs for "..ingredientsItemsLocator:getURI().." ingredients") return {success = false} end
        local fuelNeed_IngredientsSupply = serviceResults.fuelNeed

        -- fuelNeed production
        local localInputItemsLocator = localInputLocator:copy()
        localInputItemsLocator:setQuery(coreutils.DeepCopy(itemIngredientsNeed))
        serviceData = {
            localInputItemsLocator  = localInputItemsLocator,
            localOutputLocator      = siteProduceItemData.localOutputLocator:copy(),
            productionMethod        = siteProduceItemData.productionMethod,
            productionSpot          = ProductionSpot:new(siteProduceItemData.productionSpot),
        }
        serviceResults = Factory.NeedsTo_ProvideItemsTo_SSrv(serviceData)
        if not serviceResults.success then corelog.Error("enterprise_manufacturing.NeedsTo_ProvideItemsTo_SSrv: Failed obtaining needs for production at site") return {success = false} end
        local fuelNeed_SiteProduction = serviceResults.fuelNeed

        -- fuelNeed output transfer
        local localOutputLocator = URL:new(siteProduceItemData.localOutputLocator)
        local localOutputItemsLocator = localOutputLocator:copy()
        local items = { [itemName] = itemCount }
        localOutputItemsLocator:setQuery(items)
        serviceData = {
            sourceItemsLocator          = localOutputItemsLocator,
            destinationItemDepotLocator = itemDepotLocator,
        }
        serviceResults = enterprise_isp.NeedsTo_TransferItems_SSrv(serviceData)
        if not serviceResults.success then corelog.Error("enterprise_manufacturing.NeedsTo_ProvideItemsTo_SSrv: Failed obtaining transfer needs for "..itemCount.." "..itemName.."'s") return {success = false} end
        local fuelNeed_ProductsSupply = serviceResults.fuelNeed

        -- add fuelNeed
--        corelog.WriteToLog("F  fuelNeed_IngredientsSupply="..fuelNeed_IngredientsSupply..", fuelNeed_SiteProduction="..fuelNeed_SiteProduction..", fuelNeed_ProductsSupply="..fuelNeed_ProductsSupply)
        fuelNeed = fuelNeed + fuelNeed_IngredientsSupply + fuelNeed_SiteProduction + fuelNeed_ProductsSupply
    end

    -- end
    return {
        success         = true,
        fuelNeed        = fuelNeed,
        ingredientsNeed = ingredientsNeed,
    }
end

function enterprise_manufacturing.BuildAndStartNewSite_ASrv(...)
    -- get & check input from description
    local checkSuccess, serviceData, upgrade, callback = InputChecker.Check([[
        This async public service builds a new factory site and ensures it's ready for use.

        Return value:
                                        - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                        - (table)
                success                 - (boolean) whether the site was successfully build and is ready for use.
                siteLocator             - (URL) locating the created site (in this enterprise)

        Parameters:
            serviceData                 + (table) data about this site
                baseLocation            - (Location) world location of the base (lower left corner) of this site
                siteVersion             - (string) version string of the site
                upgrade                 + (boolean, false) if site should (only) be updated from a previous version
                materialsHostLocator    - (URL) locating the host of the building materials
            callback                    + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_manufacturing.BuildAndStartNewSite_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- determine projectSteps
    local projectSteps = { }
    local iStep = 0
    table.insert(projectSteps,
        { stepType = "ASrv", stepTypeDef = { moduleName = "enterprise_manufacturing", serviceName = "BuildNewSite_ASrv" }, stepDataDef = {
            { keyDef = "baseLocation"           , sourceStep = 0, sourceKeyDef = "baseLocation" },
            { keyDef = "siteVersion"            , sourceStep = 0, sourceKeyDef = "siteVersion" },
            { keyDef = "upgrade"                , sourceStep = 0, sourceKeyDef = "upgrade" },
            { keyDef = "materialsHostLocator"   , sourceStep = 0, sourceKeyDef = "materialsHostLocator" },
        }}
    )
    iStep = iStep + 1
    if upgrade then
        table.insert(projectSteps,
            { stepType = "ASrv", stepTypeDef = { moduleName = "enterprise_manufacturing", serviceName = "StopSite_ASrv" }, stepDataDef = {
                { keyDef = "baseLocation"       , sourceStep = 0, sourceKeyDef = "baseLocation" },
            }}
        )
        iStep = iStep + 1
    end
    table.insert(projectSteps,
        { stepType = "SSrv", stepTypeDef = { moduleName = "enterprise_manufacturing", serviceName = "StartNewSite_SSrv" }, stepDataDef = {
            { keyDef = "baseLocation"           , sourceStep = 0, sourceKeyDef = "baseLocation" },
            { keyDef = "siteVersion"            , sourceStep = 0, sourceKeyDef = "siteVersion" },
            { keyDef = "siteAlreadyBuild"       , sourceStep = iStep, sourceKeyDef = "success" }
        }}
    )
    iStep = iStep + 1

    -- create project definition
    local buildAndStartNewSiteProjectDef = {
        steps = projectSteps,
        returnData  = {
            { keyDef = "success"                , sourceStep = iStep, sourceKeyDef = "success" },
            { keyDef = "siteLocator"            , sourceStep = iStep, sourceKeyDef = "siteLocator" },
        }
    }
    local projectServiceData = {
        projectDef  = buildAndStartNewSiteProjectDef,
        projectData = serviceData,
    }

    -- start project
--    corelog.WriteToLog(">Building and starting factory site version "..siteVersion.." at "..textutils.serialise(baseLocation))
    return enterprise_projects.StartProject_ASrv(projectServiceData, callback)
end

function enterprise_manufacturing.BuildNewSite_ASrv(...)
    -- get & check input from description
    local checkSuccess, serviceData, baseLocation, siteVersion, upgrade, materialsHostLocator, callback = InputChecker.Check([[
        This async public service builds a new factory site.

        Return value:
                                        - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                        - (table)
                success                 - (boolean) whether the site was successfully build

        Parameters:
            serviceData                 + (table) data about this service
                baseLocation            + (Location) world location of the base (lower left corner) of this site
                siteVersion             + (string) version string of the site
                upgrade                 + (boolean, false) if site should (only) be updated from a previous version
                materialsHostLocator    + (URL) locating the host of the building materials
            callback                    + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_manufacturing.BuildNewSite_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- get site build data
    local siteBuildData = nil
    if siteVersion == "v0" then
        siteBuildData = Factory.GetV0SiteBuildData(serviceData)
    elseif siteVersion == "v1" then
        siteBuildData = Factory.GetV1SiteBuildData(serviceData)
    elseif siteVersion == "v2" then
        siteBuildData = Factory.GetV2SiteBuildData(serviceData)
    else
        corelog.Error("enterprise_manufacturing.BuildNewSite_ASrv: Don't know how to build a factory site of version "..siteVersion)
        return Callback.ErrorCall(callback)
    end
    siteBuildData.materialsHostLocator = materialsHostLocator

    -- let construction enterprise build the site
    if upgrade then
        corelog.WriteToLog(">Upgrading factory site at "..textutils.serialise(baseLocation, { compact = true }).." to version "..siteVersion)
    else
        corelog.WriteToLog(">Building factory site version "..siteVersion.." at "..textutils.serialise(baseLocation, { compact = true }))
    end
    return enterprise_construction.BuildBlueprint_ASrv(siteBuildData, callback)
end

function enterprise_manufacturing.StartNewSite_SSrv(...)
    -- get & check input from description
    local checkSuccess, serviceData, siteVersion, siteAlreadyBuild = InputChecker.Check([[
        This sync public service ensures a new site is ready for use.

        Return value:
                                    - (table)
                success             - (boolean) whether the site is ready for business
                siteLocator         - (URL) locating the created site (in this enterprise)

        Parameters:
            serviceData             + (table) data about this service
                baseLocation        - (Location) world location of the base (lower left corner) of this site
                siteVersion         + (string) version string of the site
                siteAlreadyBuild    + (boolean) confirmation that the site was already physically build
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_manufacturing.StartNewSite_SSrv: Invalid input") return {success = false} end
    if not siteAlreadyBuild then corelog.Warning("enterprise_manufacturing.StartNewSite_SSrv: Site not (yet) successfully build => we will not start it") return {success = false} end

    -- get site start data
    local siteStartData = nil
    if siteVersion == "v0" then
        siteStartData = Factory.GetV0SiteStartData(serviceData)
    elseif siteVersion == "v1" then
        siteStartData = Factory.GetV1SiteStartData(serviceData)
    elseif siteVersion == "v2" then
        siteStartData = Factory.GetV2SiteStartData(serviceData)
    else
        corelog.Error("enterprise_manufacturing.BuildNewSite_ASrv: Don't know how to start a factory site of version "..siteVersion)
        return {success = false}
    end

    -- create new Factory
    local factory = Factory:new({
--        _version        = siteStartData.version,
        _id             = coreutils.NewId(),

        _baseLocation   = siteStartData.baseLocation,
--        _entryLocation   = siteStartData.location:getRelativeLocation(3, 3, 1), -- ToDo: consider adding and using (before moving to workingLocation)

        _inputLocators  = siteStartData.inputLocators,
        _outputLocators = siteStartData.outputLocators,

        _craftingSpots  = siteStartData.craftingSpots,
        _smeltingSpots  = siteStartData.smeltingSpots,
    })

    -- ToDo: initialise possible other data (like e.g. open for business, availability of spots)

    -- save the Factory
    corelog.WriteToLog(">Adding Factory "..factory:getId()..".")
    local siteLocator = enterprise_manufacturing:saveObject(factory)
    if not siteLocator then corelog.Error("enterprise_manufacturing.StartNewSite_SSrv: Failed starting site from start data "..textutils.serialize(siteStartData)) return {success = false} end

    -- end
    return {
        success     = true,
        siteLocator = siteLocator,
    }
end

function enterprise_manufacturing.StopAndDismantleSite_ASrv(...)
    -- get & check input from description
    local checkSuccess, serviceData, siteVersion, callback = InputChecker.Check([[
        This async public service stops and dismantles a site.

        Return value:
                                        - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                - (table)
                success         - (boolean) whether the site was successfully stopped and dismantled.

        Parameters:
            serviceData                 + (table) data about this service
                baseLocation            - (Location) world location of the base (lower left corner) of this site
                siteVersion             + (string) version string of the site
                materialsHostLocator    - (URL) locating the host of the building materials
            callback                    + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_manufacturing.StopAndDismantleSite_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- create project definition
    local stopAndDismantleSiteProjectDef = {
        steps = {
            { stepType = "ASrv", stepTypeDef = { moduleName = "enterprise_manufacturing", serviceName = "StopSite_ASrv" }, stepDataDef = {
                { keyDef = "baseLocation"           , sourceStep = 0, sourceKeyDef = "baseLocation" },
            }},
            { stepType = "ASrv", stepTypeDef = { moduleName = "enterprise_manufacturing", serviceName = "DismantleSite_ASrv" }, stepDataDef = {
                { keyDef = "baseLocation"           , sourceStep = 0, sourceKeyDef = "baseLocation" },
                { keyDef = "siteVersion"            , sourceStep = 0, sourceKeyDef = "siteVersion" },
                { keyDef = "siteStopped"            , sourceStep = 1, sourceKeyDef = "success" },
                { keyDef = "materialsHostLocator"   , sourceStep = 0, sourceKeyDef = "materialsHostLocator" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , sourceStep = 2, sourceKeyDef = "success" },
        }
    }
    local projectServiceData = {
        projectDef  = stopAndDismantleSiteProjectDef,
        projectData = serviceData,
    }

    -- start project
    corelog.WriteToLog(">Stopping and dismantling factory site version "..siteVersion)
    return enterprise_projects.StartProject_ASrv(projectServiceData, callback)
end

function enterprise_manufacturing.DismantleSite_ASrv(...)
    -- get & check input from description
    local checkSuccess, serviceData, siteVersion, siteStopped, materialsHostLocator, callback = InputChecker.Check([[
        This async public service dismantles a factory site. Dismantling means the site is physically removed from minecraft world.
        Possibly part of the world is restored to a neutral (e.g. flat) state.

        Return value:
                                        - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                        - (table)
                success                 - (boolean) whether the site was successfully dismantled

        Parameters:
            serviceData                 + (table) data about this service
                baseLocation            - (Location) world location of the base (lower left corner) of the site
                siteVersion             + (string) version string of the site
                siteStopped             + (boolean) confirmation that the site was already stopped
                materialsHostLocator    + (URL) locating the host of the building materials
            callback                    + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_manufacturing.DismantleSite_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- check input
    if not siteStopped then corelog.Warning("enterprise_manufacturing.DismantleSite_ASrv: Site not (yet) stopped => we will not dismantle it") return Callback.ErrorCall(callback) end

    -- get site dismantal data
    local siteDismantleBuildData = nil
    if siteVersion == "v0" then
        siteDismantleBuildData = Factory.GetV0SiteDismantleBuildData(serviceData)
-- ToDo implement for v1 and v2
--    elseif siteVersion == "v1" then
--        siteDismantleBuildData = Factory.GetV1SiteDismantleBuildData(serviceData)
--    elseif siteVersion == "v2" then
--        siteDismantleBuildData = Factory.GetV2SiteDismantleBuildData(serviceData)
    else
        corelog.Error("enterprise_manufacturing.DismantleSite_ASrv: Don't know how to dismantle a factory site of version "..siteVersion)
        return Callback.ErrorCall(callback)
    end
    siteDismantleBuildData.materialsHostLocator = materialsHostLocator

    -- let construction enterprise dismantle the site
    return enterprise_construction.BuildBlueprint_ASrv(siteDismantleBuildData, callback)
end

local function FindSiteByLocation(baseLocation)
    -- sites ophalen
    local sites = enterprise_manufacturing:getObjects("Factory")

    -- check if we have any site
    if type(sites) ~= "table" then corelog.Warning("enterprise_manufacturing.FindSiteByLocation: no sites present") return nil end

    -- loop on sites
    for k, site in pairs(sites) do
        -- convert to object
        site = Factory:new(site)
        if not Factory.IsOfType(site) then corelog.Error("enterprise_manufacturing.FindSiteByLocation: Invalid site") return nil end

        -- is this the one?
        local siteBaseLocation = site:getBaseLocation()
        if siteBaseLocation:isSame(baseLocation) then
            return site
        end
    end

    return nil
end

--ToDo: consider providing siteLocator (obtained from StartSite_ASrv) instead of baseLocation => FindSiteByLocation obsolete
function enterprise_manufacturing.StopSite_ASrv(...)
    -- get & check input from description
    local checkSuccess, baseLocation, callback = InputChecker.Check([[
        This async public service stops a factory site. Stopping implies
          - the site is immediatly no longer available for new business
          - wait for all active work (production) on site to be ended
          - remove the site from the factory

        Return value:
                                - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                - (table)
                success         - (boolean) when the site was successfully stopped

        Parameters:
            serviceData         - (table) data about this service
                baseLocation    + (Location) world location of the base (lower left corner) of the site
            callback            + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_manufacturing.StopSite_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- get the site
    local site = FindSiteByLocation(baseLocation)
    if type(site) ~="table" then corelog.Error("enterprise_manufacturing.StopSite_ASrv: Failed retrieving factory site at location "..textutils.serialise(baseLocation)..".") return Callback.ErrorCall(callback) end

    -- stop doing business for this site
    -- ToDo: implement

    -- wait for active work done
    -- ToDo: implement

    -- get locator
    local objectLocator = enterprise_manufacturing:getObjectLocator(site)

    -- remove site from enterprise
    corelog.WriteToLog(">Removing site "..site:getId())
    enterprise_manufacturing:deleteResource(objectLocator)

    -- do callback
    return callback:call({success = true})
end

return enterprise_manufacturing
