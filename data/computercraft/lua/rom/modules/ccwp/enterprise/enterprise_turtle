local Host = require "obj_host"

local enterprise_turtle = Host:new({
    _hostName   = "enterprise_turtle",
})

local coreutils = require "coreutils"
local corelog = require "corelog"
local coremove = require "coremove"
local coreinventory = require "coreinventory"

local Callback = require "obj_callback"
local InputChecker = require "input_checker"
local Location = require "obj_location"

local Turtle = require "mobj_turtle"

local enterprise_assignmentboard = require "enterprise_assignmentboard"
local enterprise_shop = require "enterprise_shop"
local enterprise_energy = require "enterprise_energy"

local db = {
    fuelTurtlePriorityKey   = nil,
}

--[[
    The Turtle enterprise provides services related to turtles.

    This enterprise is both an ItemSupplier and an ItemDepot, hence it provides the mandatory services and functions for the types (like e.g. Can_ProvideItems_QSrv).

    Furthermore it provides the following additional services
        GetItemsLocator_SSrv   - provide the URL of items in a turtle
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function enterprise_turtle.RegisterTurtle_SSrv(...)
    -- get & check input from description
    local checkSuccess, turtleId = InputChecker.Check([[
        This sync public service registers ("adds") a Turtle to the enterprise.

        Note that the Turtle should already be present (constructed) in the world.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                turtleLocator       - (URL) locating the created Turtle (in this enterprise)

        Parameters:
            turtleData              - (table) data to the Turtle
                turtleId            + (number) id of the turtle
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.RegisterTurtle_SSrv: Invalid input") return {success = false} end

    -- create new Obj
    local obj = Turtle:new({
        _id = tostring(turtleId),
    })

    -- save the Obj
    corelog.WriteToLog(">Registering Turtle "..obj:getId().." in enterprise_turtle.")
    local objLocator = enterprise_turtle:saveObject(obj)
    if not objLocator then corelog.Error("enterprise_turtle.RegisterTurtle_SSrv: Failed registering Obj") return {success = false} end

    -- end
    local result = {
        success         = true,
        turtleLocator   = objLocator
    }
    return result
end

function enterprise_turtle.DelistTurtle_ASrv(...)
    -- get & check input from description
    local checkSuccess, turtleLocator, callback = InputChecker.Check([[
        This async public service delists ("removes") a Turtle from the enterprise. Delisting implies
            - the Turtle is immediatly no longer available for new business (e.g. adding/ removing items)
            - wait for all active work on Turtle to be ended
            - remove the Turtle from the enterprise

        Note that the Turtle (and it's possibly remaining items) are not removed from the world.

        Return value:
                                - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                - (table)
                success         - (boolean) whether the service executed successfully

        Parameters:
            serviceData         - (table) data about the service
                turtleLocator   + (URL) locating the Turtle
            callback            + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.DelistTurtle_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- get the Obj
    local obj = enterprise_turtle:getObject(turtleLocator)
    if type(obj) ~="table" then corelog.Error("enterprise_turtle.DelistTurtle_ASrv: Obj "..turtleLocator:getURI().." not found.") return Callback.ErrorCall(callback) end

    -- stop doing business for this Obj
    -- ToDo: implement

    -- wait for active work done
    -- ToDo: implement

    -- remove Obj from enteprise
    corelog.WriteToLog(">Delisting Turtle "..obj:getId())
    enterprise_turtle:deleteResource(turtleLocator)

    -- do callback
    return callback:call({success = true})
end

function enterprise_turtle.GetAssignmentForTurtle_SSrv(...)
    -- get & check input from description
    local checkSuccess, turtleLocator = InputChecker.Check([[
        This sync public service gets a new assignment for a turtle.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                assignment          - (table) with the Assignment (nil of currently non available)

        Parameters:
            serviceData             - (table) data for this service
                turtleLocator       + (URL) locator of the turtle
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.GetAssignmentForTurtle_SSrv: Invalid input") return {success = false} end

    -- get current Turtle
    local turtleObj = enterprise_turtle:getObject(turtleLocator) if not turtleObj then corelog.Error("enterprise_turtle.GetAssignmentForTurtle_SSrv: Failed obtaining Turtle from turtleLocator="..turtleLocator:getURI()) return {success = false} end

    -- (re)fuel turtle if needed
    local turtleId = turtleObj:getTurtleId()
    local fuelLevel = turtle.getFuelLevel()
    enterprise_turtle.TriggerRefuelIfNeeded(turtleId, fuelLevel)

    -- look for best next assignment
    local assignmentFilter = {
        priorityKeyNeeded   = db.fuelTurtlePriorityKey,
    }
    local turtleResume = nil
    if turtle then
        turtleResume = {
            turtleId        = turtleId,
            location        = Location:new(coremove.GetLocation()),
            fuelLevel       = fuelLevel,
            axePresent      = coreinventory.CanEquip("minecraft:diamond_pickaxe"),
            inventoryItems  = coreinventory.GetInventoryDetail().items,
        }
    end
    local serviceResults = enterprise_assignmentboard.FindBestAssignment_SSrv({ assignmentFilter = assignmentFilter, turtleResume = turtleResume })
    -- ToDo: consider if an assignment board should determine what is best...
    if not serviceResults.success then corelog.Error("enterprise_turtle.GetAssignmentForTurtle_SSrv: FindBestAssignment_SSrv failed.") end
    local assignmentIdApplication = serviceResults.assignmentId

    -- did we find one?
    local nextAssignment = nil
    if assignmentIdApplication then
        -- apply
        enterprise_assignmentboard.ApplyToAssignment(turtleId, assignmentIdApplication)

        -- wait, maybe more turtles have applied
        os.sleep(1.25)

        -- check who gets the assignment
        nextAssignment = enterprise_assignmentboard.AssignmentSelectionProcedure(turtleId, assignmentIdApplication)
    end

    -- end
    local result = {
        success = true,
        assignment = nextAssignment,
    }
    return result
end

function enterprise_turtle.Reset()
    -- reset local db
    db.fuelTurtlePriorityKey                    = nil
end

function enterprise_turtle:getObject(...)
    -- get & check input from description
    local checkSuccess, objectLocator = InputChecker.Check([[
        This method retrieves an object from the Host using a URL (that was once provided by the Host).

        Return value:
            object                  - (?) object obtained from the Host

        Parameters:
            objectLocator           + (URL) locator of the object within the Host
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle:getObject: Invalid input") return nil end

    -- check for "any turtle"
    if objectLocator:sameBase(enterprise_turtle.GetAnyTurtleLocator()) then
        -- convert to "current turtle"
--        corelog.WriteToLog("convert to current Turtle")
        local currentTurtleId = os.getComputerID()
        local objectPath = objectLocator:getPath():gsub("any", tostring(currentTurtleId))
        objectLocator:setPath(objectPath)
    end

    -- have base class Host provide the object
    return Host.getObject(self, objectLocator)
end

function enterprise_turtle:getTurtleLocator(turtleIdStr)
    --[[
        This method provides the locator of a turtle in the enterprise based on a 'turtleIdStr'.

        Return value:
            turtleLocator           - (URL) locating the turtle

        Parameters:
            turtleIdStr             + (string) id of the turtle
    --]]

    -- get resourcePath
    local objectPath = Host.GetObjectPath("Turtle", turtleIdStr)
    if not objectPath then corelog.Error("enterprise_turtle:getTurtleLocator: Failed obtaining objectPath") return nil end

    -- get objectLocator
    local turtleLocator = self:getResourceLocator(objectPath)
    if not turtleLocator then corelog.Error("enterprise_turtle:getTurtleLocator: Failed obtaining turtleLocator") return nil end

    -- end
    return turtleLocator
end

function enterprise_turtle.GetTurtleId_SSrv(...)
    -- get & check input from description
    local checkSuccess, turtleLocator = InputChecker.Check([[
        This sync public services provides the turtleId from a turtleLocator.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                turtleId            - (number) id of the turtle

        Parameters:
            serviceData             - (table) data for this service
                turtleLocator       + (URL) locating the turtle
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.GetTurtleId_SSrv: Invalid input") return {success = false} end

    -- get turtleId
    local turtleObj = enterprise_turtle:getObject(turtleLocator) if not turtleObj then corelog.Error("enterprise_turtle.GetTurtleId_SSrv: Failed obtaining turtleObj from turtleLocator="..turtleLocator:getURI()) return {success = false} end
    local turtleId = turtleObj:getTurtleId()

    -- end
    local result = {
        success     = true,
        turtleId    = turtleId,
    }
    return result
end

function enterprise_turtle.GetAnyTurtleLocator()
    --[[
        This method provides a locator for any turtle (in the enterprise). The locator provided will be subsituted to the current
        turtle once it is to be used.

        Return value:
            turtleLocator       - (URL) locating any turtle

        Parameters:
    --]]

    -- end
    return enterprise_turtle:getTurtleLocator("any")
end

function enterprise_turtle.GetItemsLocator_SSrv(...)
    -- get & check input from description
    local checkSuccess, turtleId, itemsQuery = InputChecker.Check([[
        This sync public services provides the URL of the items in a turtle in the enterprise.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                itemsLocator        - (URL) locating the items in the inventory of a turtle

        Parameters:
            serviceData             - (table) data for this service
                turtleId            + (number) id of the turtle
                itemsQuery          + (table) optional items to locate in turtle
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.GetItemsLocator_SSrv: Invalid input") return {success = false} end

    -- construct URL
    local itemsLocator = enterprise_turtle:getTurtleLocator(tostring(turtleId)) if not itemsLocator then corelog.Error("enterprise_turtle.GetItemsLocator_SSrv: failed obtaining turtleLocator") return {success = false} end
    itemsLocator:setQuery(itemsQuery)

    -- end
    local result = {
        success = true,
        itemsLocator = itemsLocator,
    }
    return result
end

function enterprise_turtle.ProvideItemsTo_ASrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, itemDepotLocator, assignmentsPriorityKey, callback = InputChecker.Check([[
        This async public ItemSupplier service provides specific items to an ItemDepot.

        Return value:
                                                - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                                - (table)
                success                         - (boolean) whether the service executed correctly
                destinationItemsLocator         - (URL) locating the final ItemDepot and the items that where transferred to it
                                                    (upon service succes the "host" component of this URL should be equal to itemDepotLocator, and
                                                    the "query" should be equal to orderItems)

        Parameters:
            serviceData                         - (table) data for the service
                itemsLocator                    + (URL) locating the items to provide
                                                    (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                                    (the "query" component of the URL specifies the items)
                itemDepotLocator                + (URL) locating the ItemDepot where the items need to be provided to
                ingredientsItemSupplierLocator  - (URL) locating where the production ingredients can be retrieved
                assignmentsPriorityKey          + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                            + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.ProvideItemsTo_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- get Obj
    local obj = enterprise_turtle:getObject(itemsLocator)
    if type(obj) ~= "table" then corelog.Error("enterprise_turtle.ProvideItemsTo_ASrv: Obj "..itemsLocator:getURI().." not found.") return Callback.ErrorCall(callback) end

    -- have Obj provide items
    local provideItems = itemsLocator:getQuery()
    return obj:provideItemsTo_AOSrv({
        provideItems                    = provideItems,
        itemDepotLocator                = itemDepotLocator,
        assignmentsPriorityKey          = assignmentsPriorityKey,
    }, callback)
end

function enterprise_turtle.Can_ProvideItems_QSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator = InputChecker.Check([[
        This sync public query service answers the question whether the ItemSupplier can provide specific items.

        Return value:
                                    - (table)
                success             - (boolean) whether the answer to the question is true

        Parameters:
            serviceData             - (table) data to the query
                itemsLocator        + (URL) locating the items that need to be queried for providability
                                        (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                        (the "query" component of the URL specifies the items to query for)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.Can_ProvideItems_QSrv: Invalid input") return {success = false} end

    -- get Obj
    local obj = enterprise_turtle:getObject(itemsLocator)
    if type(obj) ~= "table" then corelog.Error("enterprise_turtle.Can_ProvideItems_QSrv: Obj "..itemsLocator:getURI().." not found.") return {success = false} end

    -- check Obj can provide items
    local provideItems = itemsLocator:getQuery()
    local canProvide = obj:can_ProvideItems_QOSrv({
        provideItems    = provideItems,
    })

    -- end
    return canProvide
end

function enterprise_turtle.NeedsTo_ProvideItemsTo_SSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, itemDepotLocator = InputChecker.Check([[
        This sync public service returns the needs for an ItemSupplier to provide specific items to an ItemDepot.

        Return value:
                                                - (table)
                success                         - (boolean) whether the service executed correctly
                fuelNeed                        - (number) amount of fuel needed to provide items
                ingredientsNeed                 - (table) ingredients needed to provide items

        Parameters:
            serviceData                         - (table) data to the query
                itemsLocator                    + (URL) locating the items to provide
                                                    (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                                    (the "query" component of the URL specifies the items)
                itemDepotLocator                + (URL) locating the ItemDepot where the items need to be delivered to

                ingredientsItemSupplierLocator  - (URL) optionally locating another ItemSupplier where needed ingredient items for the ItemSupplier could be retrieved
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.NeedsTo_ProvideItemsTo_SSrv: Invalid input") return {success = false} end

    -- get Obj
    local obj = enterprise_turtle:getObject(itemsLocator)
    if type(obj) ~= "table" then corelog.Error("enterprise_turtle.NeedsTo_ProvideItemsTo_SSrv: Obj "..itemsLocator:getURI().." not found.") return {success = false} end

    -- determine needs
    local provideItems = itemsLocator:getQuery()
    local needs = obj:needsTo_ProvideItemsTo_SOSrv({
        provideItems    = provideItems,
        itemDepotLocator= itemDepotLocator,
    })

    -- end
    return needs
end

function enterprise_turtle.StoreItemsFrom_ASrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, itemDepotLocator, assignmentsPriorityKey, callback = InputChecker.Check([[
        This async public ItemDepot service stores items from from an ItemSupplier into an ItemDepot.

        An ItemDepot should take special care the transfer from the turtle inventory gets priority over other assignments to the turtle.

        Return value:
                                        - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                destinationItemsLocator - (URL) stating the final ItemDepot and the items that where where stored
                                            (upon service succes the "base" component of this URL should be equal to itemDepotLocator
                                            and the "query" should be equal to the "query" component of the itemsLocator)

        Parameters:
            serviceData                 - (table) data about the service
                itemsLocator            + (URL) locating the items to store
                                            (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                            (the "query" component of the URL specifies the items)
                itemDepotLocator        + (URL) locating the ItemDepot where the items need to be stored to
                assignmentsPriorityKey  + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                    + (Callback) to call once service is ready
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.StoreItemsFrom_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- get Obj
    local obj = enterprise_turtle:getObject(itemsLocator)
    if type(obj) ~= "table" then corelog.Error("enterprise_turtle.StoreItemsFrom_ASrv: Obj "..itemDepotLocator:getURI().." not found.") return Callback.ErrorCall(callback) end

    -- have Obj store items
    return obj:storeItemsFrom_AOSrv({
        itemsLocator                    = itemsLocator,
        assignmentsPriorityKey          = assignmentsPriorityKey,
    }, callback)
end

function enterprise_turtle.GetItemsLocations_SSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator = InputChecker.Check([[
        This sync public service provides the current world locations of different items in an ItemDepot.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                locations           - (table) with Location's of the different items

        Parameters:
            serviceData             - (table) data about this service
                itemsLocator        + (URL) locating the items for which to get the location
                                        (the "base" component of the URL specifies the ItemDepot that provides the items)
                                        (the "query" component of the URL specifies the items)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.GetItemsLocations_SSrv: Invalid input") return {success = false} end

    -- get location
    local serviceResults = enterprise_turtle.GetItemDepotLocation_SSrv({ itemDepotLocator = itemsLocator})
    if not serviceResults.success then corelog.Error("enterprise_turtle.GetItemsLocations_SSrv: failed obtaining location for ItemDepot "..itemsLocator:getURI()..".") return {success = false} end
    local location = serviceResults.location

    -- end
    return {
        success     = true,
        locations   = { location:copy() },
    }
end

function enterprise_turtle.GetItemDepotLocation_SSrv(...)
    -- get & check input from description
    local checkSuccess, itemDepotLocator = InputChecker.Check([[
        This sync public service provides the world location of an ItemDepot.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                location            - (Location) location of the ItemDepot

        Parameters:
            serviceData             - (table) data about this service
                itemDepotLocator    + (URL) locating the ItemDepot for which to get the location
                                        (the "base" component of the URL should specify this ItemDepot enterprise)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.GetItemDepotLocation_SSrv: Invalid input") return {success = false} end

    -- check itemDepotLocator is for this enterprise
    if not enterprise_turtle:isLocatorFromHost(itemDepotLocator)  then corelog.Error("enterprise_turtle.GetItemDepotLocation_SSrv: Invalid itemDepotLocator (="..itemDepotLocator:getURI()..").") return {success = false} end

    -- get turtle
    local currentTurtleId = os.getComputerID()
    local itemDepotLocatorTurtleId = enterprise_turtle.GetTurtleId_SSrv({ turtleLocator = itemDepotLocator }).turtleId if not itemDepotLocatorTurtleId then corelog.Error("enterprise_turtle.GetItemDepotLocation_SSrv: Failed obtaining turtleId from itemDepotLocator="..itemDepotLocator:getURI()) return {success = false} end
    if itemDepotLocatorTurtleId and currentTurtleId ~= itemDepotLocatorTurtleId then corelog.Error("enterprise_turtle.GetItemDepotLocation_SSrv: Getting ItemDepot location in one (id="..itemDepotLocatorTurtleId..") turtle from another (id="..currentTurtleId..") not implemented (?yet).") return {success = false} end

    -- get location
    local location = Location:new(coremove.GetLocation())

    -- end
    return {
        success     = true,
        location    = location:copy(),
    }
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function enterprise_turtle.TriggerRefuelIfNeeded(turtleId, fuelLevel)
    -- get fuelLevels
    local fuelLevels = enterprise_turtle.GetFuelLevels_Att()

    -- check fuelLevels
    local fuelLevel_Assignment = fuelLevels.fuelLevel_Assignment
    if fuelLevel < fuelLevel_Assignment and not db.fuelTurtlePriorityKey then
        -- ensure this turtle now only starts taking new assignments with the priority key
        local priorityKey = coreutils.NewId()
        db.fuelTurtlePriorityKey = priorityKey

        -- prepare service call
        local refuelAmount = enterprise_energy.GetRefuelAmount_Att()
        local ingredientsItemSupplierLocator = enterprise_shop.GetHostLocator_Att()
        local serviceData = {
            turtleId                        = turtleId,
            fuelAmount                      = refuelAmount,
            ingredientsItemSupplierLocator  = ingredientsItemSupplierLocator,

            assignmentsPriorityKey          = priorityKey,
        }
        local callback = Callback:new({
            _moduleName     = "enterprise_turtle",
            _methodName     = "Fuel_Callback",
            _data           = {
                turtleId = turtleId,
            },
        })

        -- call service
        enterprise_energy.ProvideFuelTo_ASrv(serviceData, callback)
    end
end

function enterprise_turtle.GetFuelLevels_Att()
    -- determine fuelLevel_Priority
    local fuelNeed_Refuel = enterprise_energy.GetFuelNeed_Refuel_Att()
    local assignmentStatistics = enterprise_assignmentboard.GetStatistics_Att()
    local maxFuelNeed_Travel = assignmentStatistics.maxFuelNeed_Travel
    local fuelLevel_Priority = fuelNeed_Refuel + maxFuelNeed_Travel

    -- determine fuelLevel_Assignment
    local maxFuelNeed_Assignment = assignmentStatistics.maxFuelNeed_Assignment
    local fuelLevel_Assignment = fuelLevel_Priority + maxFuelNeed_Assignment

    -- end
    local fuelLevels = {
        fuelLevel_Priority      = fuelLevel_Priority,
        fuelLevel_Assignment    = fuelLevel_Assignment,
    }
    return fuelLevels
end

function enterprise_turtle.Fuel_Callback(turtleData, serviceResults)
    -- check input
    if type(turtleData) ~= "table" then corelog.Error("enterprise_turtle.Fuel_Callback: Invalid turtleData") return {success = false} end
    local turtleId = turtleData.turtleId
    if type(turtleId) ~= "number" then corelog.Error("enterprise_turtle.Fuel_Callback: Invalid turtleId") return {success = false} end

    -- check correct turtle
    local currentTurtleId = os.getComputerID()
    if currentTurtleId ~= turtleId then corelog.Error("enterprise_turtle.Fuel_Callback: Current turtle(id="..currentTurtleId..") not equal to callback turtle(id="..turtleId..")") return {success = false} end

    -- release priority key condition
    db.fuelTurtlePriorityKey = nil

    -- end
    return {success = true}
end

return enterprise_turtle
