local enterprise_turtle = {}
local coreutils = require "coreutils"
local corelog = require "corelog"
local coremove = require "coremove"
local coreinventory = require "coreinventory"

local Callback = require "obj_callback"
local InputChecker = require "input_checker"
local URL = require "obj_url"
local Location = require "obj_location"

local Turtle = require "mobj_turtle"

local enterprise_assignmentboard = require "enterprise_assignmentboard"
local enterprise_shop = require "enterprise_shop"
local enterprise_energy = require "enterprise_energy"

local db = {
    hostName    = "enterprise_turtle",

    fuelTurtlePriorityKey   = nil,
    fuelTurtleCallsSkippedBecausePriorityKey = 0,
}

--[[
    The Turtle enterprise provides services related to turtles.

    This enterprise is both an ItemSupplier and an ItemDepot, hence it provides the mandatory services and functions for the types (like e.g. Can_ProvideItems_QSrv).

    Furthermore it provides the following additional services
        IsTurtleURL_QSrv       - provide if URL is of a turtle
        GetTurtleLocator_SSrv  - provide the URL of a turtle
        GetItemsLocator_SSrv   - provide the URL of items in a turtle

    It also provides the following attributes
        GetHostLocator_Att     - locating this enterprise
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function enterprise_turtle.GetAssignmentForTurtle_SSrv(...)
    -- get & check input from description
    local checkSuccess, turtleId = InputChecker.Check([[
        This sync public service gets a new assignment for a turtle.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                assignment          - (table) with the Assignment (nil of currently non available)

        Parameters:
            serviceData             - (table) data for this service
                turtleId            + (number) id of the turtle
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.GetAssignmentForTurtle_SSrv: Invalid input") return {success = false} end

    -- (re)fuel turtle if needed
    local fuelLevel = turtle.getFuelLevel()
    enterprise_turtle.TriggerRefuelIfNeeded(turtleId, fuelLevel)

    -- look for best next assignment
    local assignmentFilter = {
        priorityKeyNeeded   = db.fuelTurtlePriorityKey,
    }
    local turtleResume = nil
    if turtle then
        turtleResume = {
            turtleId        = turtleId,
            location        = Location:new(coremove.GetLocation()),
            fuelLevel       = fuelLevel,
            axePresent      = coreinventory.CanEquip("minecraft:diamond_pickaxe"),
            inventoryItems  = coreinventory.GetInventoryDetail().items,
        }
    end
    local serviceResults = enterprise_assignmentboard.FindBestAssignment_SSrv({ assignmentFilter = assignmentFilter, turtleResume = turtleResume })
    -- ToDo: consider if an assignment board should determine what is best...
    if not serviceResults.success then corelog.Error("enterprise_turtle.GetAssignmentForTurtle_SSrv: FindBestAssignment_SSrv failed.") end
    local assignmentIdApplication = serviceResults.assignmentId

    -- did we find one?
    local nextAssignment = nil
    if assignmentIdApplication then
        -- apply
        enterprise_assignmentboard.ApplyToAssignment(assignmentIdApplication)

        -- wait, maybe more turtles have applied
        os.sleep(1.25)

        -- check who gets the assignment
        nextAssignment = enterprise_assignmentboard.AssignmentSelectionProcedure(assignmentIdApplication)
    end

    -- end
    local result = {
        success = true,
        assignment = nextAssignment,
    }
    return result
end

function enterprise_turtle.Reset()
    -- reset local db
    db.fuelTurtlePriorityKey                    = nil
    db.fuelTurtleCallsSkippedBecausePriorityKey = 0
end

function enterprise_turtle.GetHostLocator_Att()
    --[[
        Attribute locating this enterprise.

        Return value:
            hostLocator             - (URL) locating this enterprise

        Parameters:
            nil
    --]]

    local hostURL = URL:new()
    hostURL:setHost(db.hostName)

    return hostURL
end

function enterprise_turtle.GetTurtleLocator_SSrv(...)
    -- get & check input from description
    local checkSuccess, turtleId = InputChecker.Check([[
        This sync public services provides the URL of a turtle in the enterprise.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                turtleLocator       - (URL) locating the turtle

        Parameters:
            serviceData             - (table) data for this service
                turtleId            + (number) id of the turtle
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.GetTurtleLocator_SSrv: Invalid input") return {success = false} end

    -- construct URL
    local turtleLocator = enterprise_turtle.GetHostLocator_Att()
    turtleLocator:setPort(turtleId)

    -- end
    local result = {
        success = true,
        turtleLocator = turtleLocator,
    }
    return result
end

function enterprise_turtle.GetItemsLocator_SSrv(...)
    -- get & check input from description
    local checkSuccess, serviceData, itemsQuery = InputChecker.Check([[
        This sync public services provides the URL of the items in a turtle in the enterprise.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                itemsLocator        - (URL) locating the items in the inventory of a turtle

        Parameters:
            serviceData             + (table) data for this service
                turtleId            - (number) id of the turtle
                itemsQuery          + (table) optional items to locate in turtle
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.GetItemsLocator_SSrv: Invalid input") return {success = false} end

    -- construct URL
    local itemsLocator = enterprise_turtle.GetTurtleLocator_SSrv(serviceData).turtleLocator
    itemsLocator:setQuery(itemsQuery)

    -- end
    local result = {
        success = true,
        itemsLocator = itemsLocator,
    }
    return result
end

function enterprise_turtle.IsTurtleURL_QSrv(...)
    -- get & check input from description
    local checkSuccess, aURL = InputChecker.Check([[
        This sync public service answers the question if a URL is that of a turtle.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully

        Parameters:
            queryData               - (table) data about the query
                aURL                + (table) a URL that needs to be queried
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.IsTurtleURL_QSrv: Invalid input") return {success = false} end

    -- check if of a turtle
    local host = aURL:getHost()
    if type(host) ~= "string" then corelog.Error("enterprise_turtle.IsTurtleURL_QSrv: Invalid host input in URL (="..aURL:getURI()..").") return {success = false} end
    if host == db.hostName then
        return {success = true}
    else
        return {success = false}
    end
end

function enterprise_turtle.ProvideItemsTo_ASrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, itemDepotLocator, assignmentsPriorityKey, callback = InputChecker.Check([[
        This async public ItemSupplier service provides specific items to an ItemDepot.

        Return value:
                                                - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                                - (table)
                success                         - (boolean) whether the service executed correctly
                destinationItemsLocator         - (URL) locating the final ItemDepot and the items that where transferred to it
                                                    (upon service succes the "host" component of this URL should be equal to itemDepotLocator, and
                                                    the "query" should be equal to orderItems)

        Parameters:
            serviceData                         - (table) data for the service
                itemsLocator                    + (URL) locating the items to provide
                                                    (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                                    (the "query" component of the URL specifies the items)
                itemDepotLocator                + (URL) locating the ItemDepot where the items need to be provided to
                ingredientsItemSupplierLocator  - (URL) locating where the production ingredients can be retrieved
                assignmentsPriorityKey          + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                            + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.ProvideItemsTo_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- get Obj
    local obj = enterprise_turtle.GetTurtle(itemsLocator)
    if type(obj) ~= "table" then corelog.Error("enterprise_turtle.ProvideItemsTo_ASrv: Obj "..itemsLocator:getURI().." not found.") return Callback.ErrorCall(callback) end

    -- have Obj provide items
    local provideItems = itemsLocator:getQuery()
    return obj:provideItemsTo_AOSrv({
        provideItems                    = provideItems,
        itemDepotLocator                = itemDepotLocator,
        assignmentsPriorityKey          = assignmentsPriorityKey,
    }, callback)
end

function enterprise_turtle.Can_ProvideItems_QSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator = InputChecker.Check([[
        This sync public query service answers the question whether the ItemSupplier can provide specific items.

        Return value:
                                    - (table)
                success             - (boolean) whether the answer to the question is true

        Parameters:
            serviceData             - (table) data to the query
                itemsLocator        + (URL) locating the items that need to be queried for providability
                                        (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                        (the "query" component of the URL specifies the items to query for)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.Can_ProvideItems_QSrv: Invalid input") return {success = false} end

    -- get Obj
    local obj = enterprise_turtle.GetTurtle(itemsLocator)
    if type(obj) ~= "table" then corelog.Error("enterprise_turtle.Can_ProvideItems_QSrv: Obj "..itemsLocator:getURI().." not found.") return {success = false} end

    -- check Obj can provide items
    local provideItems = itemsLocator:getQuery()
    local canProvide = obj:can_ProvideItems_QOSrv({
        provideItems    = provideItems,
    })

    -- end
    return canProvide
end

function enterprise_turtle.NeedsTo_ProvideItemsTo_SSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, itemDepotLocator = InputChecker.Check([[
        This sync public service returns the needs for an ItemSupplier to provide specific items to an ItemDepot.

        Return value:
                                                - (table)
                success                         - (boolean) whether the service executed correctly
                fuelNeed                        - (number) amount of fuel needed to provide items
                ingredientsNeed                 - (table) ingredients needed to provide items

        Parameters:
            serviceData                         - (table) data to the query
                itemsLocator                    + (URL) locating the items to provide
                                                    (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                                    (the "query" component of the URL specifies the items)
                itemDepotLocator                + (URL) locating the ItemDepot where the items need to be delivered to

                ingredientsItemSupplierLocator  - (URL) optionally locating another ItemSupplier where needed ingredient items for the ItemSupplier could be retrieved
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.NeedsTo_ProvideItemsTo_SSrv: Invalid input") return {success = false} end

    -- get Obj
    local obj = enterprise_turtle.GetTurtle(itemsLocator)
    if type(obj) ~= "table" then corelog.Error("enterprise_turtle.NeedsTo_ProvideItemsTo_SSrv: Obj "..itemsLocator:getURI().." not found.") return {success = false} end

    -- determine needs
    local provideItems = itemsLocator:getQuery()
    local needs = obj:needsTo_ProvideItemsTo_SOSrv({
        provideItems    = provideItems,
        itemDepotLocator= itemDepotLocator,
    })

    -- end
    return needs
end

function enterprise_turtle.StoreItemsFrom_ASrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, itemDepotLocator, assignmentsPriorityKey, callback = InputChecker.Check([[
        This async public ItemDepot service stores items from from an ItemSupplier into an ItemDepot.

        An ItemDepot should take special care the transfer from the turtle inventory gets priority over other assignments to the turtle.

        Return value:
                                        - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                destinationItemsLocator - (URL) stating the final ItemDepot and the items that where where stored
                                            (upon service succes the "base" component of this URL should be equal to itemDepotLocator
                                            and the "query" should be equal to the "query" component of the itemsLocator)

        Parameters:
            serviceData                 - (table) data about the service
                itemsLocator            + (URL) locating the items to store
                                            (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                            (the "query" component of the URL specifies the items)
                itemDepotLocator        + (URL) locating the ItemDepot where the items need to be stored to
                assignmentsPriorityKey  + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                    + (Callback) to call once service is ready
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.StoreItemsFrom_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- get Obj
    local obj = enterprise_turtle.GetTurtle(itemDepotLocator)
    if type(obj) ~= "table" then corelog.Error("enterprise_turtle.StoreItemsFrom_ASrv: Obj "..itemDepotLocator:getURI().." not found.") return Callback.ErrorCall(callback) end

    -- have Obj store items
    return obj:storeItemsFrom_ASrv({
        itemsLocator                    = itemsLocator,
        assignmentsPriorityKey          = assignmentsPriorityKey,
    }, callback)
end

function enterprise_turtle.GetItemsLocations_SSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator = InputChecker.Check([[
        This sync public service provides the current world locations of different items in an ItemDepot.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                locations           - (table) with Location's of the different items

        Parameters:
            serviceData             - (table) data about this service
                itemsLocator        + (URL) locating the items for which to get the location
                                        (the "base" component of the URL specifies the ItemDepot that provides the items)
                                        (the "query" component of the URL specifies the items)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.GetItemsLocations_SSrv: Invalid input") return {success = false} end

    -- get location
    local serviceResults = enterprise_turtle.GetItemDepotLocation_SSrv({ itemDepotLocator = itemsLocator})
    if not serviceResults.success then corelog.Error("enterprise_turtle.GetItemsLocations_SSrv: failed obtaining location for ItemDepot "..itemsLocator:getURI()..".") return {success = false} end
    local location = serviceResults.location

    -- end
    return {
        success     = true,
        locations   = { location:copy() },
    }
end

function enterprise_turtle.GetItemDepotLocation_SSrv(...)
    -- get & check input from description
    local checkSuccess, itemDepotLocator = InputChecker.Check([[
        This sync public service provides the world location of an ItemDepot.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                location            - (Location) location of the ItemDepot

        Parameters:
            serviceData             - (table) data about this service
                itemDepotLocator    + (URL) locating the ItemDepot for which to get the location
                                        (the "base" component of the URL should specify this ItemDepot enterprise)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.GetItemDepotLocation_SSrv: Invalid input") return {success = false} end

    -- check itemDepotLocator is for this enterprise
    local serviceResults = enterprise_turtle.IsTurtleURL_QSrv({ aURL = itemDepotLocator})
    if not serviceResults.success then corelog.Error("enterprise_turtle.GetItemDepotLocation_SSrv: Invalid itemDepotLocator (="..itemDepotLocator:getURI()..").") return {success = false} end

    -- get turtle
    local currentTurtleId = os.getComputerID()
    local itemDepotLocatorTurtleId = itemDepotLocator:getPort()
    if itemDepotLocatorTurtleId and currentTurtleId ~= itemDepotLocatorTurtleId then corelog.Error("enterprise_turtle.GetItemDepotLocation_SSrv: Getting ItemDepot location in one (id="..itemDepotLocatorTurtleId..") turtle from another (id="..currentTurtleId..") not implemented (?yet).") return {success = false} end

    -- get location
    local location = Location:new(coremove.GetLocation())

    -- end
    return {
        success     = true,
        location    = location:copy(),
    }
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

function enterprise_turtle.GetTurtle(...)
    -- get & check input from description
    local checkSuccess, turtleLocator = InputChecker.Check([[
        This function gets a Turtle based on a itemsLocator.

        Return value:
            turtle              - (Turtle) the Turtle object

        Parameters:
            turtleLocator       + (URL) locating the turtle
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_turtle.GetTurtle: Invalid input") return nil end

    -- check itemsLocator is for this enterprise
    local serviceResults = enterprise_turtle.IsTurtleURL_QSrv({ aURL = turtleLocator})
    if not serviceResults.success then corelog.Error("enterprise_turtle.GetTurtle: Invalid turtleLocator (="..turtleLocator:getURI()..").") return nil end

    -- ToDo: consider getting Turtle from host (similair to Chest and BirchForest)

    -- check turtleId
    local currentTurtleId = os.getComputerID()
    local locatorTurtleId = turtleLocator:getPort()
    if locatorTurtleId and currentTurtleId ~= locatorTurtleId then corelog.Error("enterprise_turtle.GetTurtle: Getting Turtle in one (id="..locatorTurtleId..") turtle from another (id="..currentTurtleId..") not implemented (?yet).") return nil end

    -- create turtle on the fly (for now)
    local turtle = {
        _id     = currentTurtleId,
    }
    turtle = Turtle:new(turtle)

    -- end
    return turtle
end

function enterprise_turtle.TriggerRefuelIfNeeded(turtleId, fuelLevel)
    -- get fuelLevels
    local fuelLevels = enterprise_turtle.GetFuelLevels_Att()

    -- check fuelLevels
    local fuelLevel_Assignment = fuelLevels.fuelLevel_Assignment
    if fuelLevel < fuelLevel_Assignment and not db.fuelTurtlePriorityKey then
        -- ensure this turtle now only starts taking new assignments with the priority key
        local priorityKey = coreutils.NewId()
        db.fuelTurtlePriorityKey = priorityKey

        -- prepare service call
        local refuelAmount = enterprise_energy.GetRefuelAmount_Att()
        local ingredientsItemSupplierLocator = enterprise_shop.GetHostLocator_Att()
        local serviceData = {
            turtleId                        = turtleId,
            fuelAmount                      = refuelAmount,
            ingredientsItemSupplierLocator  = ingredientsItemSupplierLocator,

            assignmentsPriorityKey          = priorityKey,
        }
        local callback = Callback:new({
            _moduleName     = "enterprise_turtle",
            _methodName     = "Fuel_Callback",
            _data           = {
                turtleId = turtleId,
            },
        })

        -- call service
        enterprise_energy.ProvideFuelTo_ASrv(serviceData, callback)
    end
end

function enterprise_turtle.GetFuelLevels_Att()
    -- determine fuelLevel_Priority
    local fuelNeed_Refuel = enterprise_energy.GetFuelNeed_Refuel_Att()
    local assignmentStatistics = enterprise_assignmentboard.GetStatistics_Att()
    local maxFuelNeed_Travel = assignmentStatistics.maxFuelNeed_Travel
    local fuelLevel_Priority = fuelNeed_Refuel + maxFuelNeed_Travel

    -- determine fuelLevel_Assignment
    local maxFuelNeed_Assignment = assignmentStatistics.maxFuelNeed_Assignment
    local fuelLevel_Assignment = fuelLevel_Priority + maxFuelNeed_Assignment

    -- end
    local fuelLevels = {
        fuelLevel_Priority      = fuelLevel_Priority,
        fuelLevel_Assignment    = fuelLevel_Assignment,
    }
    return fuelLevels
end

function enterprise_turtle.Fuel_Callback(turtleData, serviceResults)
    -- check input
    if type(turtleData) ~= "table" then corelog.Error("enterprise_turtle.Fuel_Callback: Invalid turtleData") return {success = false} end
    local turtleId = turtleData.turtleId
    if type(turtleId) ~= "number" then corelog.Error("enterprise_turtle.Fuel_Callback: Invalid turtleId") return {success = false} end

    -- check correct turtle
    local currentTurtleId = os.getComputerID()
    if currentTurtleId ~= turtleId then corelog.Error("enterprise_turtle.Fuel_Callback: Current turtle(id="..currentTurtleId..") not equal to callback turtle(id="..turtleId..")") return {success = false} end

    -- release priority key condition
    db.fuelTurtlePriorityKey = nil

    -- end
    return {success = true}
end

return enterprise_turtle
