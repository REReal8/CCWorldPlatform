local Host = require "obj_host"

local enterprise_storage = Host:new({
    _hostName   = "enterprise_storage",
})

local corelog = require "corelog"

local InputChecker = require "input_checker"
local Callback = require "obj_callback"

local Silo = require "mobj_silo"

local enterprise_projects = require "enterprise_projects"
local enterprise_storage_silo = require "enterprise_storage_silo"

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function enterprise_storage.BuildAndStartNewSite_ASrv(...)
    -- get & check input from description
    local checkSuccess, siteData, type, callback = InputChecker.Check([[
        This public function (service) builds a new ItemStorage site and starts it.

        Return value:
                            - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                            - (table)
                success     - (boolean) whether the service was executed successfully
                siteLocator - (URL) locating the created site (in this enterprise)

        Parameters:
            siteData        + (table) data about this site, like type and layout
                type        + (string) ItemStorage type
            callback        + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_storage.BuildAndStartNewSite_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- what kind of ItemStorage is this?
    if type == 'silo' then
        -- create project definition
        local buildAndStartNewSiteProjecDef = {
            steps   = {
                { stepType = "ASrv", stepTypeDef = { moduleName = "enterprise_storage", serviceName = "BuildNewSite_ASrv" }, stepDataDef = {
                    { keyDef = "location"                       , sourceStep = 0, sourceKeyDef = "location" },
                    { keyDef = "type"                           , sourceStep = 0, sourceKeyDef = "type" },
                    { keyDef = "topChests"                      , sourceStep = 0, sourceKeyDef = "topChests" },
                    { keyDef = "layers"                         , sourceStep = 0, sourceKeyDef = "layers" },
                    { keyDef = "materialsItemSupplierLocator"   , sourceStep = 0, sourceKeyDef = "materialsItemSupplierLocator" },
                }},
                { stepType = "SSrv", stepTypeDef = { moduleName = "enterprise_storage", serviceName = "StartNewSite_SSrv" }, stepDataDef = {
                    { keyDef = "type"                   , sourceStep = 0, sourceKeyDef = "type" },
                    { keyDef = "location"               , sourceStep = 0, sourceKeyDef = "location" },
                    { keyDef = "topChests"              , sourceStep = 0, sourceKeyDef = "topChests" },
                    { keyDef = "layers"                 , sourceStep = 0, sourceKeyDef = "layers" },
                }},
                { stepType = "SSrv", stepTypeDef = { moduleName = "enterprise_projects", serviceName = "AreAllTrue_QSrv" }, stepDataDef = {
                    { keyDef = "success1"               , sourceStep = 1, sourceKeyDef = "success" },
                    { keyDef = "success2"               , sourceStep = 2, sourceKeyDef = "success" },
                }},
            },
            returnData  = {
                { keyDef = "success"                    , sourceStep = 3, sourceKeyDef = "success" },
                { keyDef = "siteLocator"                , sourceStep = 2, sourceKeyDef = "siteLocator" },
            }
        }
        local projectServiceData = {
            projectDef  = buildAndStartNewSiteProjecDef,
            projectData = siteData,
        }

        -- start project
        return enterprise_projects.StartProject_ASrv(projectServiceData, callback)
    else corelog.Error("enterprise_storage.BuildAndStartNewSite_ASrv: Don't know how to build and start a site of type "..type) return Callback.ErrorCall(callback) end
end

function enterprise_storage.BuildNewSite_ASrv(...)
    -- get & check input from description
    local checkSuccess, siteData, type, callback = InputChecker.Check([[
        This public function (service) builds a new site.

        Async service return value (to Callback):
                            - (table)
                success     - (boolean) whether the service was executed successfully

        Parameters:
            siteData        + (table) data about this site, like type and layout
                type        + (string) ItemStorage type
            callback        + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_storage.BuildNewSite_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- what kind of ItemStorage is this?
    if type == 'silo' then
        return enterprise_storage_silo.BuildNewSite_ASrv(siteData, callback)
    else corelog.Error("enterprise_storage.BuildNewSite_ASrv: Don't know how to build a site of type "..type) return Callback.ErrorCall(callback) end
end

function enterprise_storage.StartNewSite_SSrv(...)
    -- get & check input from description
    local checkSuccess, siteData, type, location, topChests, layers = InputChecker.Check([[
        This public function to notify the enterprise_storage that a new site is ready for use and should be started.

        Return value:
                            - (table)
                success     - (boolean) whether the site is ready for business
                siteLocator - (URL) locating the created site (in this enterprise)

        Parameters:
            siteData        + (table) data about this site, like type and layout
                type        + (string) ItemStorage type
                location    + (Location) location of site
                topChests   + (number, 2) # of top chests
                layers      + (number, 2) # of layers
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_storage.StartNewSite_SSrv: Invalid input") return {success = false} end

    -- what kind of ItemStorage is this?
    if siteData.type == 'silo' then
        local obj = Silo:NewSilo({
            location    = location,
            topChests   = topChests,
            layers      = layers,
        })
        if not obj then corelog.Error("failed obtaining Silo") return end
        local siteLocator = enterprise_storage:saveObject(obj)

        -- end
        return {
            success     = true,
            siteLocator = siteLocator,
        }
    else corelog.Error("enterprise_storage.StartNewSite_SSrv: Don't know how to start a site of type "..type) return {success = false} end
end

function enterprise_storage.RegisterStorage_SSrv(...)
    -- get & check input from description
    local checkSuccess, location = InputChecker.Check([[
        This sync public service registers ("adds") a storage to the enterprise.

        Note that the storage should already be present (constructed) in the world. It is however assumed the newly added storages are still empty.

        Return value:
                                    - (table)
                success             - (boolean) whether the service executed successfully
                storageLocator      - (URL) locating the created storage (in this enterprise)

        Parameters:
            storageData             - (table) data to the storage
            type                    + (stromg) type of the storage (e.g. "storage:silo")
            location                + (Location) location of the storage
            --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_storage.RegisterStorage_SSrv: Invalid input") return {success = false} end

    -- ToDo:

    return {success = false}
end

function enterprise_storage.DelistStorage_ASrv(...)
    -- get & check input from description
    local checkSuccess, storageLocator, callback = InputChecker.Check([[
        This async public service delists ("removes") a storage from the enterprise. Delisting implies
            - the storage is immediatly no longer available for new business (e.g. adding/ removing items)
            - wait for all active work on storage to be ended
            - remove the storage from the enterprise

        Note that the storages (and it's possibly remaining items) are not removed from the world.

        Return value:
                                - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                - (table)
                success         - (boolean) whether the service executed successfully

        Parameters:
            serviceData         - (table) data about the service
                storageLocator  + (URL) locating the storage
            callback            + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_storage.DelistStorage_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- ToDo

    return Callback.ErrorCall(callback)
end

function enterprise_storage.Can_ProvideItems_QSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator = InputChecker.Check([[
        This sync public query service answers the question whether the ItemSupplier can provide specific items.

        Return value:
                                    - (table)
                success             - (boolean) whether the answer to the question is true

        Parameters:
            serviceData             - (table) data to the query
                itemsLocator        + (URL) locating the items that need to be queried for providability
                                        (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                        (the "query" component of the URL specifies the items to query for)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_storage.Can_ProvideItems_QSrv: Invalid input") return {success = false} end

    -- get Obj
    local obj = enterprise_storage:getObject(itemsLocator)
    if type(obj) ~= "table" then corelog.Error("enterprise_storage.Can_ProvideItems_QSrv: Obj "..itemsLocator:getURI().." not found.") return {success = false} end

    -- check Obj can provide items
    local provideItems = itemsLocator:getQuery()
    local canProvide = obj:can_ProvideItems_QOSrv({
        provideItems    = provideItems,
    })

    -- end
    return canProvide
end

function enterprise_storage.NeedsTo_ProvideItemsTo_SSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, itemDepotLocator = InputChecker.Check([[
        This sync public service returns the needs for the ItemSupplier to provide specific items to an ItemDepot.

        Return value:
                                                - (table)
                success                         - (boolean) whether the service executed correctly
                fuelNeed                        - (number) amount of fuel needed to provide items
                ingredientsNeed                 - (table) ingredients needed to provide items

        Parameters:
            serviceData                         - (table) data to the query
                itemsLocator                    + (URL) locating the items to provide
                                                    (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                                    (the "query" component of the URL specifies the items)
                itemDepotLocator                + (URL) locating the ItemDepot where the items need to be provided to

                ingredientsItemSupplierLocator  - (URL) locating where ingredients can be retrieved
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_storage.NeedsTo_ProvideItemsTo_SSrv: Invalid input") return {success = false} end

    -- get Obj
    local obj = enterprise_storage:getObject(itemsLocator)
    if type(obj) ~= "table" then corelog.Error("enterprise_storage.NeedsTo_ProvideItemsTo_SSrv: Obj "..itemsLocator:getURI().." not found.") return {success = false} end

    -- determine needs
    local provideItems = itemsLocator:getQuery()
    local needs = obj:needsTo_ProvideItemsTo_SOSrv({
        provideItems    = provideItems,
        itemDepotLocator= itemDepotLocator,
    })

    -- end
    return needs
end

function enterprise_storage.StoreItemsFrom_ASrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, itemDepotLocator, assignmentsPriorityKey, callback = InputChecker.Check([[
        This async public ItemDepot service stores items from from an ItemSupplier into an ItemDepot.

        An ItemDepot should take special care the transfer from the turtle inventory gets priority over other assignments to the turtle.

        Return value:
                                        - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                destinationItemsLocator - (URL) stating the final ItemDepot and the items that where where stored
                                            (upon service succes the "base" component of this URL should be equal to itemDepotLocator
                                            and the "query" should be equal to the "query" component of the itemsLocator)

        Parameters:
            serviceData                 - (table) data about the service
                itemsLocator            + (URL) locating the items to store
                                            (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                            (the "query" component of the URL specifies the items)
                itemDepotLocator        + (URL) locating the ItemDepot where the items need to be stored to
                assignmentsPriorityKey  + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                    + (Callback) to call once service is ready
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_storage.StoreItemsFrom_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- get Obj
    local obj = enterprise_storage:getObject(itemDepotLocator)
    if type(obj) ~= "table" then corelog.Error("enterprise_storage.StoreItemsFrom_ASrv: Obj "..itemDepotLocator:getURI().." not found.") return Callback.ErrorCall(callback) end

    -- have Obj store items
    return obj:storeItemsFrom_AOSrv({
        itemsLocator                    = itemsLocator,
        assignmentsPriorityKey          = assignmentsPriorityKey,
    }, callback)
end

function enterprise_storage.Can_StoreItems_QSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator = InputChecker.Check([[
        This sync public query service answers the question whether the ItemDepot can store specific items.

        Return value:
                                    - (table)
                success             - (boolean) whether the answer to the question is true

        Parameters:
            serviceData             - (table) data to the query
                itemsLocator        + (URL) locating the items that need to be stored
                                        (the "base" component of the URL specifies the ItemDepot to store the items in)
                                        (the "query" component of the URL specifies the items to query for)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_storage.Can_StoreItems_QSrv: Invalid input") return {success = false} end

    -- get Obj
    local obj = enterprise_storage:getObject(itemsLocator)
    if type(obj) ~= "table" then corelog.Error("enterprise_storage.Can_StoreItems_QSrv: Obj "..itemsLocator:getURI().." not found.") return {success = false} end

    -- check Obj can store items
    local storeItems = itemsLocator:getQuery()
    local canStore = obj:can_StoreItems_QOSrv({
        storeItems    = storeItems,
    })

    -- end
    return canStore
end

function enterprise_storage.NeedsTo_StoreItemsFrom_SSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, itemDepotLocator = InputChecker.Check([[
        This sync public service returns the needs for the ItemDepot to store specific items from an ItemSupplier.

        Return value:
                                                - (table)
                success                         - (boolean) whether the service executed correctly
                fuelNeed                        - (number) amount of fuel needed to store items

        Parameters:
            serviceData                         - (table) data to the query
                itemsLocator                    + (URL) locating the items to store
                                                    (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                                    (the "query" component of the URL specifies the items)
                itemDepotLocator                + (URL) locating the ItemDepot where the items need to be stored to
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("enterprise_storage.NeedsTo_StoreItemsFrom_SSrv: Invalid input") return {success = false} end

    -- get Obj
    local obj = enterprise_storage:getObject(itemDepotLocator)
    if type(obj) ~= "table" then corelog.Error("enterprise_storage.NeedsTo_StoreItemsFrom_SSrv: Obj "..itemDepotLocator:getURI().." not found.") return {success = false} end

    -- determine needs
    local needs = obj:needsTo_StoreItemsFrom_SOSrv({
        itemsLocator    = itemsLocator,
    })

    -- end
    return needs
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

return enterprise_storage
