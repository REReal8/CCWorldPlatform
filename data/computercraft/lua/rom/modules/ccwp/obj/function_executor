local FunctionExecutor = {}
local corelog = require "corelog"

local InputChecker = require "input_checker"

local ModuleRegistry = require "module_registry"
local moduleRegistry = ModuleRegistry:getInstance()

function FunctionExecutor.DoCallback(...)
    -- get & check input from description
    local checkSuccess, callback, callbackData, resultData = InputChecker.Check([[
        This function executes a callback function with two arguments.

        Return value:
            nil

        Parameters:
            callback                    + (string) name of callback function to execute
            callbackData                + (table) with first argument to supply to callback function
            resultData                  + (table) with second argument to supply to callback function, typically the return data of the task function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("FunctionExecutor.DoCallback: Invalid input") return nil end

    -- split callback in objName and methodName
    -- ToDo: already provide this split in this method call
    local objName, methodName = callback:match("(.*)%.(.*)")

    -- call method
    return FunctionExecutor.CallMethod(objName, methodName, { callbackData, resultData })
end

function FunctionExecutor.DoSyncService(...)
    -- get & check input from description
    local checkSuccess, service, serviceData = InputChecker.Check([[
        This function executes a sync service function.

        Return value:
            results                     - (?) service function return value

        Parameters:
            service                     + (string) name of service function to execute
            serviceData                 + (table) with argument to supply to service function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("FunctionExecutor.DoSyncService: Invalid input") return nil end

    -- split service in objName and methodName
    -- ToDo: already provide this split in this method call
    local objName, methodName = service:match("(.*)%.(.*)")

    -- call method
    return FunctionExecutor.CallMethod(objName, methodName, { serviceData })
end

function FunctionExecutor.DoASyncService(...)
    -- get & check input from description
    local checkSuccess, service, serviceData, callback, callbackData = InputChecker.Check([[
        This function executes an async service function.

        Return value:
            nil

        Async service return value (to callback):
            callbackData                - (table) with callbackData below
            results                     - (?) service function return value

        Parameters:
            service                     + (string) name of service function to execute
            serviceData                 + (table) with argument to supply to service function
            callback                    + (string) name of callback function to execute
            callbackData                + (table) with first argument to supply to callback function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("FunctionExecutor.DoASyncService: Invalid input") return nil end

    -- split service in objName and methodName
    -- ToDo: already provide this split in this method call
    local objName, methodName = service:match("(.*)%.(.*)")

    -- call method
    return FunctionExecutor.CallMethod(objName, methodName, { serviceData, callback, callbackData})
end

function FunctionExecutor.GetMethod(...)
    -- get & check input from description
    local checkSuccess, moduleName, methodName = InputChecker.Check([[
        This method gets a method based on a methodName and a module with the name moduleName.

        Return value:
            results                     - (?) function return value(s)

        Parameters:
            objName                     + (string) name of object to execute on
            moduleName                  + (string) name of module to get method from
            methodName                  + (string) name of method to execute
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("FunctionExecutor.GetMethod(...): Invalid input") return nil end

    -- get module
    local module = moduleRegistry:getModule(moduleName)
    if not module then corelog.Warning("FunctionExecutor.GetMethod(...): Module "..moduleName.." not found") return nil end

    -- get method
    local method = module[methodName]
    if not method then corelog.Warning("FunctionExecutor.GetMethod(...): Method "..methodName.." not found in module "..moduleName) return nil end

    -- end
    return method
end

function FunctionExecutor.CallMethod(...)
    -- get & check input from description
    local checkSuccess, objName, methodName, methodArguments = InputChecker.Check([[
        This method executes a method based on a methodName and the methodArguments on an object (table) with the name objName.

        Return value:
            results                     - (?) function return value(s)

        Parameters:
            objName                     + (string) name of object to execute on
            methodName                  + (string) name of method to execute
            methodArguments             + (table) with arguments to supply to the method
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("FunctionExecutor.CallFunction(...): Invalid input") return nil end

    -- get method
    local method = FunctionExecutor.GetMethod(objName, methodName)
    if not method then corelog.Warning("FunctionExecutor.CallFunction(...): Method "..methodName.." not found in object "..objName) return nil end

    -- call method
    local results = method(table.unpack(methodArguments))

    -- end
    return results
end

return FunctionExecutor
