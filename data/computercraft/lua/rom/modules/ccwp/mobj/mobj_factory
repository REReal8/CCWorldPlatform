local Factory = {
    _id             = "",

--    _version        = "",

    _baseLocation   = nil,

    _inputLocators  = {},
    _outputLocators = {},

    _craftingSpots  = {},
    _smeltingSpots  = {},
}

local coreutils = require "coreutils"
local corelog = require "corelog"
local coredht = require "coredht"

local Obj = require "obj"
local InputChecker = require "input_checker"
local Callback = require "obj_callback"
local TaskCall = require "obj_task_call"
local URL = require "obj_url"
local Location = require "obj_location"
local Block = require "obj_block"
local LayerRectangle = require "obj_layer_rectangle"

local ProductionSpot = require "mobj_production_spot"

local role_alchemist = require "role_alchemist"
local role_fuel_worker = require "role_fuel_worker"

local enterprise_projects = require "enterprise_projects"
local enterprise_isp = require "enterprise_isp"
local enterprise_turtle = require "enterprise_turtle"
local enterprise_assignmentboard = require "enterprise_assignmentboard"
local enterprise_chests = require "enterprise_chests"

local db = {
    hostName    = "enterprise_manufacturing",
    psSites     = "sites",
}

--[[
    The Factory mobj represents a factory in the minecraft world and provides (production) services to operate on that Factory.

    There are (currently) two production techniques for producing items.
        The crafting technique uses a crafting table to produce an output item from a set of input items (ingredients).
        The smelting technique uses a furnace to produce an output item from an input item (ingredient).

    A Factory is comprised out of one or more crafting and/ or smelting spots. Furthermore a Factory specifies one or more item input and
    one or more item output "spots". These input/ output spots locally locate the input and output of items by the site.
    The most simple version of these input/ output "spots" are the inventory of a turtle. They however could in principle
    also be a full fledged local ItemDepot site.
--]]

--    _                                     _   _               _
--   | |                                   | | | |             | |
--   | |__   __ _ ___  ___   _ __ ___   ___| |_| |__   ___   __| |___
--   | '_ \ / _` / __|/ _ \ | '_ ` _ \ / _ \ __| '_ \ / _ \ / _` / __|
--   | |_) | (_| \__ \  __/ | | | | | |  __/ |_| | | | (_) | (_| \__ \
--   |_.__/ \__,_|___/\___| |_| |_| |_|\___|\__|_| |_|\___/ \__,_|___/

function Factory:new(...)
    -- get & check input from description
    local checkSuccess, o = InputChecker.Check([[
        Construct a Factory.

        Parameters:
            o                           + (table, {}) table with object fields
                _id                     - (string) id of the Factory
                _baseLocation           - (Location) location of the Factory
                _inputLocators          - (table) with input locators
                _outputLocators         - (table) with output locators
                _craftingSpots          - (table) with crafting spots
                _smeltingSpots          - (table) with smelting spots
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Factory:new: Invalid input") return {} end

    -- set class info
    setmetatable(o, self)
    self.__index = self

    -- end
    return o
end

function Factory:getClassName()
    return "Factory"
end

function Factory:getId()
    return self._id
end

function Factory:getBaseLocation()
    return self._baseLocation
end

function Factory:getInputLocators()
    return self._inputLocators
end

function Factory:getOutputLocators()
    return self._outputLocators
end

function Factory:getCraftingSpots()
    return self._craftingSpots
end

function Factory:getSmeltingSpots()
    return self._smeltingSpots
end

function Factory.HasFieldsOfType(obj)
    -- check
    if type(obj) ~= "table" then return false end
    if type(obj._id) ~= "string" then return false end
    if not Location.IsOfType(obj._baseLocation) then return false end
    if not Obj.ObjArray_IsOfType(obj._inputLocators, URL) then return false end
    if not Obj.ObjArray_IsOfType(obj._outputLocators, URL) then return false end
    if not Obj.ObjArray_IsOfType(obj._craftingSpots, ProductionSpot) then return false end
    if not Obj.ObjArray_IsOfType(obj._smeltingSpots, ProductionSpot) then return false end

    -- end
    return true
end

function Factory.HasClassNameOfType(obj)
    -- check
    if not obj.getClassName or obj:getClassName() ~= Factory:getClassName() then return false end

    -- end
    return true
end

function Factory.IsOfType(obj)
    -- check
    local isOfType = Factory.HasFieldsOfType(obj) and Factory.HasClassNameOfType(obj)

    -- end
    return isOfType
end

function Factory:isSame(obj)
    -- check input
    if not Factory.IsOfType(obj) then return false end

    -- check same object
    local isSame =  self._id == obj._id
                and self._baseLocation:isSame(obj._baseLocation)
                and Obj.ObjArray_IsSame(self._inputLocators, obj._inputLocators)
                and Obj.ObjArray_IsSame(self._outputLocators, obj._outputLocators)
                and Obj.ObjArray_IsSame(self._craftingSpots, obj._craftingSpots)
                and Obj.ObjArray_IsSame(self._smeltingSpots, obj._smeltingSpots)

    -- end
    return isSame
end

function Factory:copy()
    -- create copy
    local copy = Factory:new({
        _id             = self._id,

        _baseLocation   = self._baseLocation:copy(),
        _inputLocators  = Obj.ObjArray_Copy(self._inputLocators),
        _outputLocators = Obj.ObjArray_Copy(self._outputLocators),
        _craftingSpots  = Obj.ObjArray_Copy(self._craftingSpots),
        _smeltingSpots  = Obj.ObjArray_Copy(self._smeltingSpots),
    })

    -- end
    return copy
end

--                        _  __ _                       _   _               _
--                       (_)/ _(_)                     | | | |             | |
--    ___ _ __   ___  ___ _| |_ _  ___   _ __ ___   ___| |_| |__   ___   __| |___
--   / __| '_ \ / _ \/ __| |  _| |/ __| | '_ ` _ \ / _ \ __| '_ \ / _ \ / _` / __|
--   \__ \ |_) |  __/ (__| | | | | (__  | | | | | |  __/ |_| | | | (_) | (_| \__ \
--   |___/ .__/ \___|\___|_|_| |_|\___| |_| |_| |_|\___|\__|_| |_|\___/ \__,_|___/
--       | |
--       |_|

local function FindSiteByLocation(baseLocation)
    -- sites ophalen
    local sites = coredht.GetData(db.hostName, db.psSites)

    -- check if we have any site
    if type(sites) ~= "table" then corelog.Warning("Factory.FindSiteByLocation: no sites present") return nil end

    -- loop on sites
    for k, site in pairs(sites) do
        local siteBaseLocation = Location:new(site.baseLocation)
        -- is this the one?
        if siteBaseLocation:isSame(baseLocation) then
            return site
        end
    end

    return nil
end

function Factory.StopSite_ASrv(...)
    -- get & check input from description
    local checkSuccess, baseLocation, callback = InputChecker.Check([[
        This async public function stops a factory site. Stopping implies
          - the site is immediatly no longer available for new business
          - wait for all active work (production) on site to be ended
          - remove the site from the factory

        Return value:
                                - (boolean) whether the service was scheduled successfully

        Async immediatly return value (to callback):
                                - (table)
                success         - (boolean) when the site was successfully stopped

        Parameters:
            serviceData         - (table) data about the site
                baseLocation    + (Location) world location of the base (lower left corner) of the site
            callback            + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Factory.StopSite_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- find the site
    local site = FindSiteByLocation(baseLocation)
    if type(site) ~="table" then corelog.Error("Factory.StopSite_ASrv: Failed retrieving factory site at location "..textutils.serialise(baseLocation)..".") return Callback.ErrorCall(callback) end

    -- stop doing business for this site
    -- ToDo: implement

    -- wait for active work done
    -- ToDo: implement

    -- remove site from factory
    corelog.WriteToLog("  Factory.StopSite_ASrv: Removing site "..site.siteId)
    coredht.SaveData(nil, db.hostName, db.psSites, site.siteId)

    -- do callback
    return callback:call({success = true})
end

local function GetAvailableLocator(locators)
    -- check input
    if type(locators) ~="table" then corelog.Error("Factory.GetAvailableLocator: Invalid locators") return nil end

    -- find first available locator
    for i, locator in ipairs(locators) do
        -- ToDo: consider checking availability

        -- take first
        return locator
    end

    -- end
    return nil
end

local function GetAvailableCraftSpot(site)
    -- check input
    if type(site) ~="table" then corelog.Error("Factory.GetAvailableCraftSpot: Invalid site") return nil end

    -- find first available spot
    for i, spot in ipairs(site.craftingSpots) do
        -- ToDo: consider checking availability

        -- take first
        return ProductionSpot:new(spot)
    end

    -- end
    return nil
end

local function GetAvailableSmeltSpot(site)
    -- check input
    if type(site) ~="table" then corelog.Error("Factory.GetAvailableSmeltSpot: Invalid site") return nil end

    -- find first available spot
    for i, spot in ipairs(site.smeltingSpots) do
        -- ToDo: consider checking availability

        -- take first
        return ProductionSpot:new(spot)
    end

    -- end
    return nil
end

function Factory.GetAvailableSiteData(...)
    -- get & check input from description
    local checkSuccess, recipe, productItemCount = InputChecker.Check([[
        This public method finds and selects a suitable factory site for producing items from a recipe.

        Return value:
                siteProduceItemData     - (table) (partial) productionData to produce item

        Parameters:
            recipe                      + (table) item base recipe (including possibly both a crafting as smelting recipe)
            productItemCount            + (number) amount of items to produce
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Factory.GetAvailableSiteData: Invalid input") return nil end

    -- sites ophalen
    local sites = coredht.GetData(db.hostName, db.psSites)
    if type(sites) ~= "table" then corelog.Warning("Factory.GetAvailableSiteData: no sites present") return nil end

    -- ..
    local craftRecipe = recipe.crafting
    local smeltRecipe = recipe.smelting

    -- find available sites
    local availableSitesInfo = {
    }
    for k, site in pairs(sites) do
        -- check
        if type(site) ~="table" then corelog.Error("Factory.GetAvailableSiteData: Invalid site") return nil end
        local siteId = site.siteId
        if type(siteId) ~="string" then corelog.Error("Factory.GetAvailableSiteData: Invalid siteId") return nil end

        -- get available inputLocator
        local inputLocator = URL:new(GetAvailableLocator(site.inputLocators))
        if inputLocator == nil then
            corelog.Warning("Factory.GetAvailableSiteData: No available inputLocator in site "..siteId)
        else
            -- get available outputLocator
            local outputLocator = URL:new(GetAvailableLocator(site.outputLocators))
            if outputLocator == nil then
                corelog.Warning("Factory.GetAvailableSiteData: No available outputLocator in site "..siteId)
            else
                -- check it can craft recipe
                if craftRecipe ~= nil then
                    -- ToDo: implement production of more items than fitting a single spot
                    local craftSpot = GetAvailableCraftSpot(site)
                    if craftSpot ~= nil then
                        table.insert(availableSitesInfo, {
                            localInputLocator   = inputLocator:copy(),
                            localOutputLocator  = outputLocator:copy(),
                            productionSpot      = craftSpot:copy(),
                            productionMethod    = "craft",
                            productionRecipe    = coreutils.DeepCopy(craftRecipe),
                        })
                    else
                        corelog.Warning("Factory.GetAvailableSiteData: No available crafting spot in site "..siteId)
                    end
                end

                -- check it can smelt recipe
                if smeltRecipe ~= nil then
                    local smeltSpot = GetAvailableSmeltSpot(site)
                    if smeltSpot ~= nil then
                        table.insert(availableSitesInfo, {
                            localInputLocator   = inputLocator:copy(),
                            localOutputLocator  = outputLocator:copy(),
                            productionSpot      = smeltSpot:copy(),
                            productionMethod    = "smelt",
                            productionRecipe    = coreutils.DeepCopy(smeltRecipe),
                        })
                    else
                        corelog.Warning("Factory.GetAvailableSiteData: No available smelting spot in site "..siteId)
                    end
                end
            end
        end
    end

    -- select best site
    local selectedProduceItemData = nil
    for i, siteProduceItemData in ipairs(availableSitesInfo) do
        -- for now take first
        selectedProduceItemData = siteProduceItemData
        break
        -- ToDo: consider finding best site based on some selection criterium
    end
    if selectedProduceItemData == nil then corelog.Warning("Factory.GetAvailableSiteData: no site available") return nil end

    -- mark productionSpot as unavailable
    -- ToDo: implement (not yet needed in current settle scenario where there is only one turtle)
    -- ToDo: consider to what extend this is also needed for localInputLocator and localOutputLocator

    -- enhance with itemsNeeded
    local productionMethod = selectedProduceItemData.productionMethod
    local productionRecipe = selectedProduceItemData.productionRecipe
    if productionMethod == "craft" then
        selectedProduceItemData.itemsNeeded = coreutils.DeepCopy(role_alchemist.Craft_ItemsNeeded(productionRecipe, productItemCount))
    elseif productionMethod == "smelt" then
        -- determine production fuel
        -- ToDo: do this differently
        local fuelItemName  = "minecraft:birch_planks"
        local fuelItemCount = productItemCount

        selectedProduceItemData.itemsNeeded = coreutils.DeepCopy(role_alchemist.Smelt_ItemsNeeded(productionRecipe, productItemCount, fuelItemName, fuelItemCount))
    else corelog.Error("Factory.GetAvailableSiteData: Production with method "..productionMethod.." not implemented.") return nil end

    -- end
    return selectedProduceItemData
end

function Factory.NeedsTo_ProvideItemsTo_SSrv(...)
    -- get & check input from description
    local checkSuccess, localInputItemsLocator, localOutputLocator, productionMethod, productionSpot = InputChecker.Check([[
        This sync public service returns the needs for the site to produce specific items to an ItemDepot.

        Return value:
                                        - (table)
                success                 - (boolean) whether the service executed correctly
                fuelNeed                - (number) amount of fuel needed to supply items

        Parameters:
            serviceData                 - (table) data to the query
                localInputItemsLocator  + (URL) locating where the production ingredients can be retrieved locally "within" the site (e.g. an input chest)
                localOutputLocator      + (URL) locating where the produced items need to be delivered locally "within" the site (e.g. an output chest)
                productionMethod        + (string) production method to use
                productionSpot          + (ProductionSpot) production spot
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Factory.NeedsTo_ProvideItemsTo_SSrv: Invalid input") return {success = false} end

    -- fuelNeed from localInputItemsLocator to productionSpot
    local serviceResults = enterprise_isp.GetItemsLocations_SSrv({ itemsLocator = localInputItemsLocator })
    if not serviceResults.success then corelog.Error("Factory.NeedsTo_ProvideItemsTo_SSrv: failed obtaining locations for items "..localInputItemsLocator:getURI()..".") return {success = false} end
    local fuelNeed_ToProductionlocation = 0
    for i, location in ipairs(serviceResults.locations) do
        fuelNeed_ToProductionlocation = fuelNeed_ToProductionlocation + role_fuel_worker.NeededFuelToFrom(productionSpot:getLocation(), location)
    end

    -- fuelNeed for production
    local fuelNeed_Production = 0
    if productionMethod == "craft" then fuelNeed_Production = 0 -- craft
    elseif productionMethod == "smelt" then fuelNeed_Production = 4 + 4 -- smelt + pickup
    else corelog.Error("Factory.NeedsTo_ProvideItemsTo_SSrv: Production with method "..productionMethod.." not implemented.") return {success = false} end

    -- fuelNeed from productionSpot to localOutputLocator
    serviceResults =  enterprise_isp.GetItemDepotLocation_SSrv({ itemDepotLocator = localOutputLocator })
    if not serviceResults.success then corelog.Error("Factory.NeedsTo_ProvideItemsTo_SSrv: failed obtaining location for ItemDepot "..localOutputLocator:getURI()..".") return {success = false} end
    local fuelNeed_FromProductionLocation = role_fuel_worker.NeededFuelToFrom(serviceResults.location, productionSpot:getLocation())

    -- end
--    corelog.WriteToLog("FS fuelNeed_ToProductionlocation="..fuelNeed_ToProductionlocation..", fuelNeed_Production="..fuelNeed_Production..", fuelNeed_FromProductionLocation="..fuelNeed_FromProductionLocation)
    local fuelNeed = fuelNeed_ToProductionlocation + fuelNeed_Production + fuelNeed_FromProductionLocation
    return {
        success         = true,
        fuelNeed        = fuelNeed,
    }
end

function Factory.ProduceItem_ASrv(...)
    -- get & check input from description
    local checkSuccess, localInputItemsLocator, localOutputLocator, productionMethod, productionSpot, productItemName, productItemCount, productionRecipe, assignmentsPriorityKey, callback = InputChecker.Check([[
        This async public service produces multiple instances of a specific item in a factory site. It does so by producing
        the requested amount of items with the supplied production method (i.e. crafting or smelting).

        Return value:
                                        - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                        - (table)
                success                 - (boolean) whether the service executed correctly
                localOutputItemsLocator - (URL) locating the items that where produced
                                            (upon service succes the "host" component of this URL should be equal to localOutputLocator, and
                                            the "query" should be equal to the "query" component of the localInputItemLocator)

        Parameters:
            serviceData                 - (table) data for the service
                localInputItemsLocator  + (URL) locating where the production ingredients can be retrieved locally "within" the site (e.g. an input chest)
                localOutputLocator      + (URL) locating where the produced items need to be delivered locally "within" the site (e.g. an output chest)
                productionMethod        + (string) production method to use
                productionSpot          + (ProductionSpot) production spot
                productItemName         + (string) name of item to produce
                productItemCount        + (number) amount of items to produce
                productionRecipe        + (table) production recipe
                assignmentsPriorityKey  + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                    + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Factory.ProduceItem_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- determine turtleInputLocator
    local turtleInputLocator = enterprise_turtle.GetHostLocator_Att()

    -- determine production steps
    local projectSteps = {
        { stepType = "ASrv", stepTypeDef = { moduleName = "enterprise_isp", serviceName = "StoreItemsFrom_ASrv" }, stepDataDef = {
            { keyDef = "itemsLocator"               , sourceStep = 0, sourceKeyDef = "localInputItemsLocator" },
            { keyDef = "itemDepotLocator"           , sourceStep = 0, sourceKeyDef = "turtleInputLocator" },
            { keyDef = "assignmentsPriorityKey"     , sourceStep = 0, sourceKeyDef = "assignmentsPriorityKey" },
        }},
    }

    -- add production steps
    local extraStep = 0
    local areAllTrueStep = nil
    if productionMethod == "craft" then
        -- add crafting step
        table.insert(projectSteps,
            { stepType = "ASrv", stepTypeDef = { moduleName = "mobj_factory", serviceName = "CraftItem_ASrv" }, stepDataDef = {
                { keyDef = "turtleInputItemsLocator", sourceStep = 1, sourceKeyDef = "destinationItemsLocator" },
                { keyDef = "productionSpot"         , sourceStep = 0, sourceKeyDef = "productionSpot" },
                { keyDef = "productItemName"        , sourceStep = 0, sourceKeyDef = "productItemName" },
                { keyDef = "productItemCount"       , sourceStep = 0, sourceKeyDef = "productItemCount" },
                { keyDef = "productionRecipe"       , sourceStep = 0, sourceKeyDef = "productionRecipe" },
                { keyDef = "assignmentsPriorityKey" , sourceStep = 0, sourceKeyDef = "assignmentsPriorityKey" },
            }}
        )

        -- are all true step
        areAllTrueStep = { stepType = "SSrv", stepTypeDef = { moduleName = "enterprise_projects", serviceName = "AreAllTrue_QSrv" }, stepDataDef = {
            { keyDef = "success1"                   , sourceStep = 1, sourceKeyDef = "success" },
            { keyDef = "success2"                   , sourceStep = 2, sourceKeyDef = "success" },
            { keyDef = "success3"                   , sourceStep = 3, sourceKeyDef = "success" },
        }}
    elseif productionMethod == "smelt" then
        -- add smelting step
        table.insert(projectSteps,
            { stepType = "ASrv", stepTypeDef = { moduleName = "mobj_factory", serviceName = "SmeltItem_ASrv" }, stepDataDef = {
                { keyDef = "turtleInputItemsLocator", sourceStep = 1, sourceKeyDef = "destinationItemsLocator" },
                { keyDef = "productionSpot"         , sourceStep = 0, sourceKeyDef = "productionSpot" },
                { keyDef = "productItemCount"       , sourceStep = 0, sourceKeyDef = "productItemCount" },
                { keyDef = "productionRecipe"       , sourceStep = 0, sourceKeyDef = "productionRecipe" },
                { keyDef = "assignmentsPriorityKey" , sourceStep = 0, sourceKeyDef = "assignmentsPriorityKey" },
            }}
        )

        -- add pickup step
        table.insert(projectSteps,
            { stepType = "ASrv", stepTypeDef = { moduleName = "mobj_factory", serviceName = "Pickup_ASrv" }, stepDataDef = {
                { keyDef = "pickUpTime"             , sourceStep = 2, sourceKeyDef = "smeltReadyTime" },
                { keyDef = "productionSpot"         , sourceStep = 0, sourceKeyDef = "productionSpot" },
                { keyDef = "productItemName"        , sourceStep = 0, sourceKeyDef = "productItemName" },
                { keyDef = "productItemCount"       , sourceStep = 0, sourceKeyDef = "productItemCount" },
                { keyDef = "assignmentsPriorityKey" , sourceStep = 0, sourceKeyDef = "assignmentsPriorityKey" },
            }}
        )

        -- are all true step
        areAllTrueStep = { stepType = "SSrv", stepTypeDef = { moduleName = "enterprise_projects", serviceName = "AreAllTrue_QSrv" }, stepDataDef = {
            { keyDef = "success1"                   , sourceStep = 1, sourceKeyDef = "success" },
            { keyDef = "success2"                   , sourceStep = 2, sourceKeyDef = "success" },
            { keyDef = "success3"                   , sourceStep = 3, sourceKeyDef = "success" },
            { keyDef = "success4"                   , sourceStep = 4, sourceKeyDef = "success" },
        }}
        extraStep = 1
    else corelog.Error("Factory.ProduceItem_ASrv: Production with method "..productionMethod.." not implemented.") return Callback.ErrorCall(callback) end

    -- add remaining steps
    table.insert(projectSteps,
        { stepType = "ASrv", stepTypeDef = { moduleName = "enterprise_isp", serviceName = "StoreItemsFrom_ASrv" }, stepDataDef = {
            { keyDef = "itemsLocator"               , sourceStep = 2 + extraStep, sourceKeyDef = "turtleOutputItemsLocator" },
            { keyDef = "itemDepotLocator"           , sourceStep = 0, sourceKeyDef = "localOutputLocator" },
            { keyDef = "assignmentsPriorityKey"     , sourceStep = 0, sourceKeyDef = "assignmentsPriorityKey" },
        }}
    )
    table.insert(projectSteps, areAllTrueStep)

    -- create project service data
    local projectDef = {
        steps = projectSteps,
        returnData  = {
            { keyDef = "success"                    , sourceStep = 4 + extraStep, sourceKeyDef = "success" },
            { keyDef = "localOutputItemsLocator"    , sourceStep = 3 + extraStep, sourceKeyDef = "destinationItemsLocator" },
        }
    }
    local projectData = {
        localInputItemsLocator      = localInputItemsLocator,
        localOutputLocator          = localOutputLocator,

        turtleInputLocator          = turtleInputLocator,

        productionSpot              = productionSpot,
        productItemName             = productItemName,
        productItemCount            = productItemCount,
        productionRecipe            = productionRecipe,

        assignmentsPriorityKey      = assignmentsPriorityKey,
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    return enterprise_projects.StartProject_ASrv(projectServiceData, callback)
end

--    _                 _    __                  _   _
--   | |               | |  / _|                | | (_)
--   | | ___   ___ __ _| | | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | |/ _ \ / __/ _` | | |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | | (_) | (_| (_| | | | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   |_|\___/ \___\__,_|_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

--[[
    A v0 site is comprised of
    - one crafting spot. Below the crafting spot is a hole in the ground as a temporary ItemDepot for items not needed
    - no smelting spot
--]]

local function Shaft_layer()
    return LayerRectangle:new({
        _codeArray  = {
            [" "]   = Block:new({ _name = Block.NoneBlockName() }),
        },
        _codeMap    = {
            [1] = " ",
        },
    })
end

local function ShaftRestore_layer()
    return LayerRectangle:new({
        _codeArray  = {
            ["D"]   = Block:new({ _name = "minecraft:dirt" }),
        },
        _codeMap    = {
            [1] = "D",
        },
    })
end

function Factory.GetV0SiteBuildData(serviceData)
    -- construct layer list
    local layerList = {
        { startpoint = Location:new({ _x= 0, _y= 0, _z= -1}), buildFromAbove = true, layer = Shaft_layer()},
    }

    -- construct blueprint
    local blueprint = {
        layerList = layerList,
        escapeSequence = {
        }
    }

    -- construct build data
    local siteBuildData = {
        blueprintStartpoint = serviceData.baseLocation:copy(),
        blueprint = blueprint
    }

    return siteBuildData
end

function Factory.GetV0SiteDismantleBuildData(serviceData)
    -- construct layer list
    local layerList = {
        { startpoint = Location:new({ _x= 0, _y= 0, _z= -1}), buildFromAbove = true, layer = ShaftRestore_layer()},
    }

    -- construct blueprint
    local blueprint = {
        layerList = layerList,
        escapeSequence = {
        }
    }

    -- construct build data
    local siteDismantleBuildData = {
        blueprintStartpoint = serviceData.baseLocation:copy(),
        blueprint = blueprint
    }

    return siteDismantleBuildData
end

function Factory.GetV0SiteStartData(serviceData)
    --
    local baseLocation = serviceData.baseLocation

    -- construct start data
    local startData = {
        version = serviceData.siteVersion,

        baseLocation = baseLocation:copy(),

        inputLocators = {
            enterprise_turtle.GetHostLocator_Att(),
        },
        outputLocators = {
            enterprise_turtle.GetHostLocator_Att(),
        },

        craftingSpots = {
            ProductionSpot:new({ _location = baseLocation:getRelativeLocation(0, 0, 0) }),
        },
        smeltingSpots = {},
    }

    return startData
end

--[[
    A v1 site is comprised of
    - one crafting spot. Below the crafting spot is a hole in the ground as a temporary ItemDepot for items not needed.
    - one smelting spot. In front of the smelting spot is a furnace that can be accessed from the front, the top and below.
--]]

local function AboveOrBelowFurnanceL1_layer()
    return LayerRectangle:new({
        _codeArray  = {
            [" "]   = Block:new({ _name = Block.NoneBlockName() }),
        },
        _codeMap    = {
            [2] = " ",
            [1] = " ",
        },
    })
end

local function FurnanceL1_layer()
    return LayerRectangle:new({
        _codeArray  = {
            ["F"]   = Block:new({ _name = "minecraft:furnace" }),
            [" "]   = Block:new({ _name = Block.NoneBlockName() }),
        },
        _codeMap    = {
            [2] = "F",
            [1] = " ",
        },
    })
end

function Factory.GetV1SiteBuildData(serviceData)
    -- construct layer list
    local layerList = {
        { startpoint = Location:new({ _x= 3, _y= 3, _z= -1}), buildFromAbove = true, layer = Shaft_layer()},
        { startpoint = Location:new({ _x= 3, _y= 3, _z= -2}), buildFromAbove = false, layer = AboveOrBelowFurnanceL1_layer()},
        { startpoint = Location:new({ _x= 3, _y= 3, _z= -3}), buildFromAbove = false, layer = FurnanceL1_layer()},
        { startpoint = Location:new({ _x= 3, _y= 3, _z= -5}), buildFromAbove = true, layer = Shaft_layer()},
    }

    -- construct blueprint
    local blueprint = {
        layerList = layerList,
        escapeSequence = {
            Location:new({ _x= 3, _y= 3, _z=  1}),
        }
    }

    -- construct build data
    local siteBuildData = {
        blueprintStartpoint = serviceData.baseLocation:copy(),
        blueprint = blueprint
    }

    return siteBuildData
end

function Factory.GetV1SiteStartData(serviceData)
    --
    local baseLocation = serviceData.baseLocation

    -- construct start data
    local startData = {
        version = serviceData.siteVersion,

        baseLocation = baseLocation:copy(),

        inputLocators = {
            enterprise_turtle.GetHostLocator_Att(),
        },
        outputLocators = {
            enterprise_turtle.GetHostLocator_Att(),
        },

        craftingSpots = {
            ProductionSpot:new({ _location = baseLocation:getRelativeLocation(3, 3, -4) }),
        },
        smeltingSpots = {
            ProductionSpot:new({ _location = baseLocation:getRelativeLocation(3, 3, -3) }),
        },
    }

    return startData
end

--[[
    A v2 site is comprised of
    - one crafting spot. Below the crafting spot should is a chest as a temporary ItemDepot for items not needed.
    - one smelting spot. In front of the smelting spot is a furnace that can be accessed from the front, the top and below.

    - ToDo and some additional chests of which we need to define what their exact purpose is.
--]]

local function ItemDepotChestL2_layer()
    return LayerRectangle:new({
        _codeArray  = {
            ["C"]   = Block:new({ _name = "minecraft:chest" }),
        },
        _codeMap    = {
            [1] = "C",
        },
    })
end

local function TopLayerL2_layer()
    return LayerRectangle:new({
        _codeArray  = {
            ["T"]   = Block:new({ _name = "minecraft:torch" }),
            ["C"]   = Block:new({ _name = "minecraft:chest" }),
            [" "]   = Block:new({ _name = Block.NoneBlockName() }),
        },
        _codeMap    = {
            [6] = "  C C ",
            [5] = "      ",
            [4] = "T     ",
            [3] = "      ",
            [2] = "      ",
            [1] = "   T  ",
        },
    })
end

function Factory.GetV2SiteBuildData(serviceData)
    local onlyUpgrade = serviceData.upgrade

    -- construct layer list
    local layerList = {
        { startpoint = Location:new({ _x= 0, _y= 0, _z= 0}), buildFromAbove = true, layer = TopLayerL2_layer()},
    }
    if not onlyUpgrade then
        table.insert(layerList, { startpoint = Location:new({ _x= 3, _y= 3, _z= -1}), buildFromAbove = true, layer = Shaft_layer()})
        table.insert(layerList, { startpoint = Location:new({ _x= 3, _y= 3, _z= -2}), buildFromAbove = false, layer = AboveOrBelowFurnanceL1_layer()})
        table.insert(layerList, { startpoint = Location:new({ _x= 3, _y= 3, _z= -3}), buildFromAbove = false, layer = FurnanceL1_layer()})
    end
    table.insert(layerList, { startpoint = Location:new({ _x= 3, _y= 3, _z= -5}), buildFromAbove = true, layer = ItemDepotChestL2_layer()})

    -- construct blueprint
    local blueprint = {
        layerList = layerList,
        escapeSequence = {
            Location:new({ _x= 3, _y= 3, _z= 1}),
        }
    }

    -- construct build data
    local siteBuildData = {
        blueprintStartpoint = serviceData.baseLocation:copy(),
        blueprint = blueprint
    }

    return siteBuildData
end

function Factory.GetV2SiteStartData(serviceData)
    --
    local baseLocation = serviceData.baseLocation

    -- register input chest
    local inputChestLocator = enterprise_chests.RegisterChest_SSrv({
        location        = baseLocation:getRelativeLocation(2, 5, 0),
        accessDirection = "top",
    }).chestLocator

    -- register output chest
    local outputChestLocator = enterprise_chests.RegisterChest_SSrv({
        location        = baseLocation:getRelativeLocation(4, 5, 0),
        accessDirection = "top",
    }).chestLocator

    -- construct start data
    local startData = {
        version = serviceData.siteVersion,

        baseLocation = baseLocation,

        inputLocators = {
            inputChestLocator,
        },
        outputLocators = {
            outputChestLocator,
        },

        craftingSpots = {
            ProductionSpot:new({ _location = baseLocation:getRelativeLocation(3, 3, -4) }),
        },
        smeltingSpots = {
            ProductionSpot:new({ _location = baseLocation:getRelativeLocation(3, 3, -3) }),
        },
    }

    return startData
end

function Factory.CraftItem_ASrv(...)
    -- get & check input from description
    local checkSuccess, turtleInputItemsLocator, productionSpot, productItemName, productItemCount, productionRecipe, assignmentsPriorityKey, callback = InputChecker.Check([[
        This async sewrvice should craft items at the productionSpot.

        Return value:
                                        - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                        - (table)
                success                 - (boolean) whether the service executed correctly
                turtleOutputItemsLocator- (URL) locating the items that where produced (in a turtle)

        Parameters:
            serviceData                 - (table) data for the service
                turtleInputItemsLocator + (URL) locating the production ingredients in the turtle that should do the crafting
                productionSpot          + (ProductionSpot) production spot
                productItemName         + (string) name of item to produce
                productItemCount        + (number) amount of items to produce
                productionRecipe        + (table) crafting recipe
                assignmentsPriorityKey  + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                    + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Factory.CraftItem_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- gather assignment data
    local craftData = {
        productItemName = productItemName,
        productItemCount= productItemCount,

        recipe          = productionRecipe,
        workingLocation = productionSpot:getLocation():copy(),

        priorityKey     = assignmentsPriorityKey,
    }
    local metaData = role_alchemist.Craft_MetaData(craftData)
    metaData.needTurtleId = turtleInputItemsLocator:getPort()
    -- ToDo: consider setting metaData.itemList from turtleInputItemsLocator path (as we already have it)

    -- do assignment
--    corelog.WriteToLog("   >Crafting with recipe "..textutils.serialise(productionRecipe).."'s")
    local assignmentServiceData = {
        metaData    = metaData,
        taskCall    = TaskCall:new({ _moduleName = "role_alchemist", _methodName = "Craft_Task", _data = craftData, }),
    }
    return enterprise_assignmentboard.DoAssignment_ASrv(assignmentServiceData, callback)
end

function Factory.SmeltItem_ASrv(...)
    -- get & check input from description
    local checkSuccess, turtleInputItemsLocator, productionSpot, productItemCount, productionRecipe, assignmentsPriorityKey, callback = InputChecker.Check([[
        This async service should smelt items at the productionSpot.

        Return value:
                                        - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                        - (table)
                success                 - (boolean) whether the service executed correctly
                smeltReadyTime          - (number) the time when the smelting is supposed to be ready

        Parameters:
            serviceData                 - (table) data for the service
                turtleInputItemsLocator + (URL) locating the production ingredients in the turtle that should do the crafting
                productionSpot          + (ProductionSpot) production spot
                productItemCount        + (number) amount of items to produce
                productionRecipe        + (table) smelting recipe
                assignmentsPriorityKey  + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                    + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Factory.SmeltItem_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- gather assignment data
    local smeltData = {
        productItemCount= productItemCount,
        recipe          = productionRecipe,

        workingLocation = productionSpot:getLocation():copy(),

        -- ToDo: do this more efficient/ different (determine beste type, calculate etc)
        fuelItemName    = "minecraft:birch_planks",
        fuelItemCount   = productItemCount,

        priorityKey     = assignmentsPriorityKey,
    }
    local metaData = role_alchemist.Smelt_MetaData(smeltData)
    metaData.needTurtleId = turtleInputItemsLocator:getPort()
    -- ToDo: consider setting metaData.itemList from turtleInputItemsLocator path (as we already have it)

    -- do assignment
--    corelog.WriteToLog("   >Smelting with recipe "..textutils.serialise(productionRecipe).."'s")
    local assignmentServiceData = {
        metaData    = metaData,
        taskCall    = TaskCall:new({ _moduleName = "role_alchemist", _methodName = "Smelt_Task", _data = smeltData, }),
    }
    return enterprise_assignmentboard.DoAssignment_ASrv(assignmentServiceData, callback)
end

function Factory.Pickup_ASrv(...)
    -- get & check input from description
    local checkSuccess, pickUpTime, productionSpot, productItemName, productItemCount, assignmentsPriorityKey, callback = InputChecker.Check([[
        This async service should pickup the results from a previous smelt step.

        Return value:
                                        - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                        - (table)
                success                 - (boolean) whether the service executed correctly
                turtleOutputItemsLocator- (URL) locating the items that where pickedup (in a turtle)

        Parameters:
            serviceData                 - (table) data for the service
                pickUpTime              + (number) the time after which the pickup should be done
                productionSpot          + (ProductionSpot) production spot
                productItemName         + (string) name of item to produce
                productItemCount        + (number) amount of items to produce
                assignmentsPriorityKey  + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                    + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Factory.Pickup_ASrv: Invalid input") return Callback.ErrorCall(callback) end

    -- gather assignment data
    local pickupData = {
        productItemName = productItemName,
        productItemCount= productItemCount,

        workingLocation = productionSpot:getLocation():copy(),

        priorityKey     = assignmentsPriorityKey,
    }
    local metaData = role_alchemist.Pickup_MetaData(pickupData)
    metaData.startTime = pickUpTime

    -- do assignment
--    corelog.WriteToLog("   >Pickup at spot "..textutils.serialise(spotLocation).."")
    local assignmentServiceData = {
        metaData    = metaData,
        taskCall    = TaskCall:new({ _moduleName = "role_alchemist", _methodName = "Pickup_Task", _data = pickupData, }),
    }
    return enterprise_assignmentboard.DoAssignment_ASrv(assignmentServiceData, callback)
end

return Factory
