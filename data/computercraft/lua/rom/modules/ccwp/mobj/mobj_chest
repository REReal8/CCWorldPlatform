local Chest = {
    _id                     = "",

    _location               = nil,
    _accessDirection        = "",
    _inventory              = {},
}

local coreutils = require "coreutils"
local corelog = require "corelog"
local coremove = require "coremove"

local InputChecker = require "input_checker"
local MethodExecutor = require "method_executor"

local Inventory = require "obj_inventory"

local role_fuel_worker = require "role_fuel_worker"
local role_chests_worker = require "role_chests_worker"

local enterprise_isp = require "enterprise_isp"
local enterprise_projects = require "enterprise_projects"
local enterprise_turtle

--[[
    The Chest mobj represents a chest in the minecraft world and provides services to operate on that Chest.

??    This enterprise is both a Supplier and a Storage, hence it provides the mandatory services and functions for the types (like e.g. Can_ProvideItems_QSrv, GetItemsIntoTurtle_ASrv and PutItemsFromTurtle_ASrv).

    The following design decisions are made
        - The actual Chest's should never be accessed directly but only via the services of this mobj.
--]]

--                _     _ _         __                  _   _
--               | |   | (_)       / _|                | | (_)
--    _ __  _   _| |__ | |_  ___  | |_ _   _ _ __   ___| |_ _  ___  _ __  ___
--   | '_ \| | | | '_ \| | |/ __| |  _| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
--   | |_) | |_| | |_) | | | (__  | | | |_| | | | | (__| |_| | (_) | | | \__ \
--   | .__/ \__,_|_.__/|_|_|\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
--   | |
--   |_|

function Chest:new(...)
    -- get & check input from description
    local checkSuccess, o = InputChecker.Check([[
        Construct a Chest.

        Parameters:
            o                           + (table, {}) table with object fields
                _id                     - (string) id of the Chest
                _location               - (table) location of the Chest
                _accessDirection        - (string) whether to access Chest from "bottom", "top", "left", "right", "front" or "back" (relative to location)
                _inventory              - (Inventory) inventory of Chest
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Chest:new: Invalid input") return {} end

    -- set class info
    setmetatable(o, self)
    self.__index = self

    -- end
    return o
end

function Chest:getId()
    return self._id
end

function Chest:getLocation()
    return self._location
end

function Chest:getAccessDirection()
    return self._accessDirection
end

function Chest:getInventory()
    return self._inventory
end

function Chest.HasFieldsOfType(chest)
    -- check
    if type(chest) ~= "table" then return false end
    if type(chest._id) ~= "string" then return false end
    if (type(chest._location) ~= "nil" and type(chest._location) ~= "table") then return false end
    if type(chest._accessDirection) ~= "string" then return false end
    if not Inventory.IsOfType(chest._inventory) then return false end

    -- end
    return true
end

function Chest.HasMethodsOfType(chest)
    -- check
    if not chest.new then return false end

    -- end
    return true
end

function Chest.IsOfType(chest)
    -- check
    local isOfType = Chest.HasFieldsOfType(chest) and Chest.HasMethodsOfType(chest)

    -- end
    return isOfType
end

function Chest:isSame(chest)
    -- check input
    if not Chest.IsOfType(chest) then return false end

    -- check same object
    local isSame =  self._id == chest._id
                and coremove.IsSameLocation(self._location, chest._location)
                and self._accessDirection == chest._accessDirection
                and self._inventory:isSame(chest._inventory)

    -- end
    return isSame
end

function Chest:copy()
    local copy = Chest:new({
        _id             = self._id,

        _location       = coremove.CopyLocation(self._location),
        _accessDirection= self._accessDirection,
        _inventory      = self._inventory:copy()
    })

    return copy
end

--                        _
--                       (_)
--    ___  ___ _ ____   ___  ___ ___  ___
--   / __|/ _ \ '__\ \ / / |/ __/ _ \/ __|
--   \__ \  __/ |   \ V /| | (_|  __/\__ \
--   |___/\___|_|    \_/ |_|\___\___||___/
--
--

function Chest:can_ProvideItems_QSrv(...)
    -- get & check input from description
    local checkSuccess, provideItems = InputChecker.Check([[
        This sync public query service answers the question whether the Supplier can provide specific items.

        Return value:
                                    - (table)
                success             - (boolean) whether the answer to the question is true

        Parameters:
            serviceData             - (table) data to the query
                provideItems        + (table) with one or more items (formatted as an array of [itemName] = itemCount key-value pairs) to provide
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Chest:can_ProvideItems_QSrv: Invalid input") return {success = false} end

    -- query chests inventory
    local itemTable = self:getInventory():getItemTable()
    for itemName, itemCount in pairs(provideItems) do
        if type(itemName) ~= "string" then corelog.Error("Chest:can_ProvideItems_QSrv: itemName of wrong type = "..type(itemName)..".") return {success = false} end
        if type(itemCount) ~= "number" then corelog.Error("Chest:can_ProvideItems_QSrv: itemCount of wrong type = "..type(itemCount)..".") return {success = false} end

        local inventoryCount = itemTable[itemName]
        if inventoryCount == nil or inventoryCount < itemCount then
            return {success = false}
        end
    end

    -- end
    return {
        success = true,
    }
end

function Chest:needsTo_ProvideItemsTo_SSrv(...)
    -- get & check input from description
    local checkSuccess, provideItems, storageLocator = InputChecker.Check([[
        This sync public service returns the needs for the Supplier to provide specific items to a Storage.

        Return value:
                                            - (table)
                success                     - (boolean) whether the service executed correctly
                fuelNeed                    - (number) amount of fuel needed to provide items
                ingredientsNeed             - (table) ingredients needed to provide items

        Parameters:
            serviceData                     - (table) data to the query
                provideItems                + (table) with one or more items (formatted as an array of [itemName] = itemCount key-value pairs) to provide
                storageLocator              + (URL) locating the Storage where the items need to be provided to
                ingredientsSupplierLocator  - (URL, nil) locating where ingredients can be retrieved
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Chest:needsTo_ProvideItemsTo_SSrv: Invalid input") return {success = false} end

    -- get location
    local chestLocation = self:getLocation()

    -- loop on items
    local fuelNeed = 0
    for itemName, itemCount in pairs(provideItems) do
        -- check
        if type(itemName) ~= "string" then corelog.Error("Chest:needsTo_ProvideItemsTo_SSrv: Invalid itemName (type="..type(itemName)..")") return {success = false} end
        if type(itemCount) ~= "number" then corelog.Error("Chest:needsTo_ProvideItemsTo_SSrv: Invalid itemCount (type="..type(itemCount)..")") return {success = false} end

        -- fuelNeed from chest to storageLocator
        local serviceData = {
            storageLocator  = storageLocator,
        }
        local serviceResults =  enterprise_isp.GetStorageLocation_SSrv(serviceData)
        if not serviceResults or not serviceResults.success then corelog.Error("Chest:needsTo_ProvideItemsTo_SSrv: failed obtaining location for Storage "..type(storageLocator)..".") return {success = false} end
        -- ToDo: consider how to handle if path isn't the shortest route, should we maybe modify things to do something like GetTravelDistanceBetween
        local fuelNeed_FromChestToStorage = role_fuel_worker.NeededFuelToFrom(serviceResults.location, chestLocation)

        -- add fuelNeed
--        corelog.WriteToLog("C  fuelNeed_FromChestToStorage="..fuelNeed_FromChestToStorage)
        fuelNeed = fuelNeed + fuelNeed_FromChestToStorage
    end

    -- end
    local ingredientsNeed = {}
    return {
        success         = true,
        fuelNeed        = fuelNeed,
        ingredientsNeed = ingredientsNeed,
    }
end

function Chest:updateChestRecord_AOSrv(...)
    -- get & check input from description
    local checkSuccess, callback, callbackData = InputChecker.Check([[
        This async private service updates (fetches) the inventory from a Chest.

        Return value:
            nil

        Async service return value (to callback):
                                - (table)
                success         - (boolean) whether the service executed successfully
                chest           - (table) the chest

        Parameters:
            serviceData         - (table) data about the service
            callback            + (string) name of function to call once service is ready
            callbackData        + (table, {}) data to supply to callback function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Chest:updateChestRecord_AOSrv: Invalid input") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- ToDo: consider if we can do this without a project

    -- create project definition
    local taskData = {
        location = coremove.CopyLocation(self:getLocation()),
        accessDirection = self:getAccessDirection(),
    }
    local projectData = {
        chest           = self:copy(),

        task            = "role_chests_worker.FetchChestSlotsInventory_Task",
        metaData        = role_chests_worker.FetchChestSlotsInventory_MetaData(taskData),
        taskData        = taskData,
    }
    local projectDef = {
        steps   = {
            { stepType = "ASrv", stepTypeDef = { moduleName = "enterprise_assignmentboard", serviceName = "DoAssignment_ASrv" }, stepDataDef = {
                { keyDef = "task"                   , sourceStep = 0, sourceKeyDef = "task" },
                { keyDef = "metaData"               , sourceStep = 0, sourceKeyDef = "metaData" },
                { keyDef = "taskData"               , sourceStep = 0, sourceKeyDef = "taskData" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , sourceStep = 1, sourceKeyDef = "success" },
            { keyDef = "chest"                      , sourceStep = 0, sourceKeyDef = "chest" },
            { keyDef = "chest._inventory"           , sourceStep = 1, sourceKeyDef = "inventory" },
        }
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function Chest:getItemsIntoTurtle_AOSrv(...)
    -- get & check input from description
    local checkSuccess, items, assignmentsPriorityKey, callback, callbackData = InputChecker.Check([[
        This async private service fetches items from the Chest into the inventory of a turtle.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                chest                   - (Chest) the Chest (after the items have been removed)
                turtleItemsLocator      - (URL) locating a specific turtle and the items it has gotton in it's inventory

        Parameters:
            serviceData                 - (table) data about the service
                items                   + (table) items to be fetched
                assignmentsPriorityKey  + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                    + (string) name of function to call once service is ready
            callbackData                + (table, {}) data to supply to callback function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Chest:getItemsIntoTurtle_AOSrv: Invalid input") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- create project definition
    local taskData = {
        location        = coremove.CopyLocation(self:getLocation()),
        accessDirection = self:getAccessDirection(),
        itemsQuery      = items,

        priorityKey     = assignmentsPriorityKey,
    }
    local projectData = {
        chest           = self:copy(),

        task            = "role_chests_worker.FetchItemsFromChestIntoTurtle_Task",
        metaData        = role_chests_worker.FetchItemsFromChestIntoTurtle_MetaData(taskData),
        taskData        = taskData,
    }
    local projectDef = {
        steps   = {
            { stepType = "ASrv", stepTypeDef = { moduleName = "enterprise_assignmentboard", serviceName = "DoAssignment_ASrv" }, stepDataDef = {
                { keyDef = "task"                   , sourceStep = 0, sourceKeyDef = "task" },
                { keyDef = "metaData"               , sourceStep = 0, sourceKeyDef = "metaData" },
                { keyDef = "taskData"               , sourceStep = 0, sourceKeyDef = "taskData" },
            }},
            { stepType = "SSrv", stepTypeDef = { moduleName = "enterprise_turtle", serviceName = "GetItemsLocator_SSrv" }, stepDataDef = {
                { keyDef = "turtleId"               , sourceStep = 1, sourceKeyDef = "turtleId" },
                { keyDef = "itemsQuery"             , sourceStep = 1, sourceKeyDef = "itemResultQuery" },
            }},
            { stepType = "SSrv", stepTypeDef = { moduleName = "enterprise_projects", serviceName = "AreAllTrue_QSrv" }, stepDataDef = {
                { keyDef = "success1"               , sourceStep = 1, sourceKeyDef = "success" },
                { keyDef = "success2"               , sourceStep = 2, sourceKeyDef = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , sourceStep = 3, sourceKeyDef = "success" },
            { keyDef = "chest"                      , sourceStep = 0, sourceKeyDef = "chest" },
            { keyDef = "chest._inventory"           , sourceStep = 1, sourceKeyDef = "inventory" },
            { keyDef = "turtleItemsLocator"         , sourceStep = 2, sourceKeyDef = "itemsLocator" },
        }
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

function Chest:putItemsFromTurtle_AOSrv(...)
    -- get & check input from description
    local checkSuccess, turtleItemsLocator, assignmentsPriorityKey, callback, callbackData = InputChecker.Check([[
        This async private service puts items from a the inventory of a turtle into the Chest.

        Return value:
            nil

        Async service return value (to callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                chest                   - (table) the chest (after the items have been put)

        Parameters:
            serviceData                 - (table) data about the service
                turtleItemsLocator      + (URL) stating a specific turtle and the items in it's inventory that need to be put
                assignmentsPriorityKey  + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                    + (string) name of function to call once service is ready
            callbackData                + (table, {}) data to supply to callback function
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Chest:putItemsFromTurtle_AOSrv: Invalid input") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- check source is a turtle
    enterprise_turtle = enterprise_turtle or require "enterprise_turtle"
    local serviceResults = enterprise_turtle.IsTurtleURL_QSrv({ aURL = turtleItemsLocator})
    if not serviceResults.success then corelog.Error("Chest:putItemsFromTurtle_AOSrv: Invalid turtle source URL (="..turtleItemsLocator:getURI()..").") return MethodExecutor.DoCallback(callback, callbackData, {success = false}) end

    -- ToDo: consider if we can do this without a project

    -- create project definition
    local taskData = {
        turtleId        = turtleItemsLocator:getPort(),
        itemsQuery      = coreutils.DeepCopy(turtleItemsLocator:getQuery()),
        location        = coremove.CopyLocation(self:getLocation()),
        accessDirection = self:getAccessDirection(),

        priorityKey     = assignmentsPriorityKey,
    }
    local projectData = {
        chest           = self:copy(),

        task            = "role_chests_worker.PutItemsFromTurtleIntoChest_Task",
        metaData        = role_chests_worker.PutItemsFromTurtleIntoChest_MetaData(taskData),
        taskData        = taskData,
    }
    local projectDef = {
        steps   = {
            { stepType = "ASrv", stepTypeDef = { moduleName = "enterprise_assignmentboard", serviceName = "DoAssignment_ASrv" }, stepDataDef = {
                { keyDef = "task"                   , sourceStep = 0, sourceKeyDef = "task" },
                { keyDef = "metaData"               , sourceStep = 0, sourceKeyDef = "metaData" },
                { keyDef = "taskData"               , sourceStep = 0, sourceKeyDef = "taskData" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , sourceStep = 1, sourceKeyDef = "success" },
            { keyDef = "chest"                      , sourceStep = 0, sourceKeyDef = "chest" },
            { keyDef = "chest._inventory"           , sourceStep = 1, sourceKeyDef = "inventory" },
        }
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    enterprise_projects.StartProject_ASrv(projectServiceData, callback, callbackData)
end

return Chest
