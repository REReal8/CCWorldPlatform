local Miner = {
    _id                     = "",
    _version                = 1,

    _location               = nil,

    _topChests              = nil,

    _operational            = false,
}

-- includes / requires
local coreutils = require "coreutils"
local corelog = require "corelog"
local coredht = require "coredht"

local InputChecker = require "input_checker"
local Callback = require "obj_callback"
local ObjArray = require "obj_array"
local Host = require "obj_host"

local Location = require "obj_location"
local Inventory = require "obj_inventory"

local role_fuel_worker = require "role_fuel_worker"
local role_chests_worker = require "role_chests_worker"

local enterprise_isp = require "enterprise_isp"
local enterprise_projects = require "enterprise_projects"
local enterprise_turtle
local enterprise_chests = require "enterprise_chests"
local enterprise_storage

-- usefull
local dthMinerRoot   = "mobj_miner"

--[[
    The following design decisions are made
        - The miner has full control of all area with z coordinate -32 and lower.
--]]

--    _                                     _   _               _
--   | |                                   | | | |             | |
--   | |__   __ _ ___  ___   _ __ ___   ___| |_| |__   ___   __| |___
--   | '_ \ / _` / __|/ _ \ | '_ ` _ \ / _ \ __| '_ \ / _ \ / _` / __|
--   | |_) | (_| \__ \  __/ | | | | | |  __/ |_| | | | (_) | (_| \__ \
--   |_.__/ \__,_|___/\___| |_| |_| |_|\___|\__|_| |_|\___/ \__,_|___/

function Miner:NewMiner(...)
    -- get & check input from description
    local checkSuccess, location, topChests = InputChecker.Check([[
        Construct a miner.

        Parameters:
            siteData                    - (table) data about this silo, like type and layout
                location                + (Location) location of site
                topChests               + (number, 2) # of top chests
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Silo:new: Invalid input") return {} end

    -- better safe then sorry, maybe flexible one day
--    location:setDX(0)
--    location:setDY(1)

    -- main var
    local siteData  = {
        _id             = coreutils.NewId(),

        -- might be userfull later
        _version        = 1,

        -- locations
        _location       = location,

        -- chests
        _topChests      = ObjArray:new({
            _objClassName = "URL",
        }),

        -- is this silo accepting requests?
        _operational    = false,
    }

    -- what kind of new silo is this?
    corelog.WriteToLog(">Starting miner at "..textutils.serialise(location, { compact = true }))

    -- add our top chests, depending how many we have
    if topChests >= 1 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(2, 5, 0), accessDirection="back"}).chestLocator) end
    if topChests >= 2 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(4, 5, 0), accessDirection="back"}).chestLocator) end
    if topChests >= 3 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(5, 4, 0), accessDirection="left"}).chestLocator) end
    if topChests >= 4 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(5, 2, 0), accessDirection="left"}).chestLocator) end
    if topChests >= 5 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(4, 1, 0), accessDirection="front"}).chestLocator) end
    if topChests >= 6 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(2, 1, 0), accessDirection="front"}).chestLocator) end
    if topChests >= 7 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(1, 2, 0), accessDirection="right"}).chestLocator) end
    if topChests >= 8 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(1, 4, 0), accessDirection="right"}).chestLocator) end

    -- set class info
    setmetatable(siteData, self)
    self.__index = self

    -- end
    return siteData
end

function Miner:Activate()
    self._operational = true
    self:update()
end

function Miner:Deactivate()
    self._operational = false
    self:update()
end

function Miner:getId()
    return self._id
end

function Miner:getLocation()
    return self._location
end

--    _____ ____  _     _                  _   _               _
--   |_   _/ __ \| |   (_)                | | | |             | |
--     | || |  | | |__  _   _ __ ___   ___| |_| |__   ___   __| |___
--     | || |  | | '_ \| | | '_ ` _ \ / _ \ __| '_ \ / _ \ / _` / __|
--    _| || |__| | |_) | | | | | | | |  __/ |_| | | | (_) | (_| \__ \
--   |_____\____/|_.__/| | |_| |_| |_|\___|\__|_| |_|\___/ \__,_|___/
--                    _/ |
--                   |__/

function Miner:new(...)
    -- get & check input from description
    local checkSuccess, o = InputChecker.Check([[
        Construct a Silo.

        Parameters:
            o                           + (table) data about this silo, like type and layout
                _id                     - (string) id of the Silo
                _version                - (number) version of the Silo
                _location               - (Location) location of the Silo
                _topChests              - (ObjArray) with top chests
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Silo:new: Invalid input") return {} end

    -- set class info
    setmetatable(o, self)
    self.__index = self

    -- end
    return o
end

function Miner:getClassName()
    return "Miner"
end

function Miner.HasFieldsOfType(obj)
    -- check
    if type(obj) ~= "table" then return false end
    if type(obj._id) ~= "string" then return false end
    if type(obj._version) ~= "number" then return false end

    if not Location.IsOfType(obj._location) then return false end

    if not ObjArray.IsOfType(obj._topChests) then return false end

    -- end
    return true
end

function Miner.HasClassNameOfType(obj)
    -- check
    if not obj.getClassName or obj:getClassName() ~= Miner:getClassName() then return false end

    -- end
    return true
end

function Miner.IsOfType(obj)
    -- check
    return Miner.HasFieldsOfType(obj) and Miner.HasClassNameOfType(obj)
end

function Miner:isSame(obj)
    -- check input
    if not Miner.IsOfType(obj) then return false end

    -- check same object
    local isSame =  self._id == obj._id
                and self._version == obj._version

                and self._location:isSame(obj._location)

                and self._topChests:isSame(obj._topChests)

    -- end
    return isSame
end

function Miner:copy()
    local copy = Miner:new({
        _id             = self._id,
        _version        = self._version,

        _location       = self._location:copy(),

        _topChests      = self._topChests:copy(),
    })

    return copy
end

--    _____ _____ _                  _____                   _ _                            _   _               _
--   |_   _|_   _| |                / ____|                 | (_)                          | | | |             | |
--     | |   | | | |_ ___ _ __ ___ | (___  _   _ _ __  _ __ | |_  ___ _ __   _ __ ___   ___| |_| |__   ___   __| |___
--     | |   | | | __/ _ \ '_ ` _ \ \___ \| | | | '_ \| '_ \| | |/ _ \ '__| | '_ ` _ \ / _ \ __| '_ \ / _ \ / _` / __|
--    _| |_ _| |_| ||  __/ | | | | |____) | |_| | |_) | |_) | | |  __/ |    | | | | | |  __/ |_| | | | (_) | (_| \__ \
--   |_____|_____|\__\___|_| |_| |_|_____/ \__,_| .__/| .__/|_|_|\___|_|    |_| |_| |_|\___|\__|_| |_|\___/ \__,_|___/
--                                              | |   | |
--                                              |_|   |_|

function Miner:provideItemsTo_AOSrv(...)
    -- get & check input from description
    local checkSuccess, provideItems, itemDepotLocator, assignmentsPriorityKey, callback = InputChecker.Check([[
        This async public ItemSupplier service provides specific items to an ItemDepot.

        Return value:
                                                - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                                - (table)
                success                         - (boolean) whether the service executed correctly
                destinationItemsLocator         - (URL) locating the final ItemDepot and the items that where transferred to it
                                                    (upon service succes the "host" component of this URL should be equal to itemDepotLocator, and
                                                    the "query" should be equal to orderItems)

        Parameters:
            serviceData                         - (table) data for the service
                provideItems                    + (table) with one or more items (formatted as an array of [itemName] = itemCount key-value pairs) to provide
                itemDepotLocator                + (URL) locating the ItemDepot where the items need to be provided to
                assignmentsPriorityKey          + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                            + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Miner:provideItemsTo_AOSrv: Invalid input") return Callback.ErrorCall(callback) end

    -- start project
    corelog.WriteToLog(">Retrieve "..textutils.serialise(provideItems).." from Miner (!!NOT IMPLEMENTEND!!)")
    return {success = false}
end

function Miner:can_ProvideItems_QOSrv(...)
    -- get & check input from description
    local checkSuccess, provideItems = InputChecker.Check([[
        This sync public query service answers the question whether the ItemSupplier can provide specific items.

        Return value:
                                    - (table)
                success             - (boolean) whether the answer to the question is true

        Parameters:
            serviceData             - (table) data to the query
                provideItems        + (table) with one or more items (formatted as an array of [itemName] = itemCount key-value pairs) to provide
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Miner:can_ProvideItems_QOSrv: Invalid input") return {success = false} end

    -- no trouble if we are not (or no longer) operational
    if not self._operational then
        -- weird
        corelog.WriteToLog("inactive miner queried (self._operational = "..tostring(self._operational)..")")

        -- ignore this error for now
    --    return {success = false, message = "miner not operational"}
    end

    -- check if all items are underground findable
    local available = {
        ["minecraft:coal"]          = true,
        ["minecraft:cobblestone"]   = true,
        ["minecraft:copper_ore"]    = true,
        ["minecraft:diamond"]       = true,
        ["minecraft:dirt"]          = true,
        ["minecraft:emerald_ore"]   = true,
        ["minecraft:iron_ore"]      = true,
        ["minecraft:redstone"]      = true,
    }

    coreutils.WriteToLog("provideItems:")
    coreutils.WriteToLog(provideItems)

    -- guess we did not find anything
    return {success = false, message = "items not available"}
end

function Miner:needsTo_ProvideItemsTo_SOSrv(...)
    -- get & check input from description
    local checkSuccess, provideItems, itemDepotLocator = InputChecker.Check([[
        This sync public service returns the needs for the ItemSupplier to provide specific items to an ItemDepot.

        Return value:
                                                - (table)
                success                         - (boolean) whether the service executed correctly
                fuelNeed                        - (number) amount of fuel needed to provide items
                ingredientsNeed                 - (table) ingredients needed to provide items

        Parameters:
            serviceData                         - (table) data to the query
                provideItems                    + (table) with one or more items (formatted as an array of [itemName] = itemCount key-value pairs) to provide
                itemDepotLocator                + (URL) locating the ItemDepot where the items need to be provided to
                ingredientsItemSupplierLocator  - (URL, nil) locating where ingredients can be retrieved
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Miner:needsTo_ProvideItemsTo_SOSrv: Invalid input") return {success = false, fuelNeed = 20000} end

    -- ToDo: better estimate, probebly based on earlier experience
    return {success = true, fuelNeed = 1000}
end
