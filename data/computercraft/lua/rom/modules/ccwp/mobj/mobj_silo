local Silo = {
    _id                     = "",
    _version                = 1,

    _location               = nil,
    _entryLocation          = nil,

    _dropLocation           = 0,
    _pickupLocation         = 0,

    _topChests              = nil,
    _storageChests          = nil,
}

local coreutils = require "coreutils"
local corelog = require "corelog"
local coredht = require "coredht"

local InputChecker = require "input_checker"
local Callback = require "obj_callback"
local TaskCall = require "obj_task_call"

local Location = require "obj_location"
local Inventory = require "obj_inventory"

local role_fuel_worker = require "role_fuel_worker"
local role_chests_worker = require "role_chests_worker"

local enterprise_isp = require "enterprise_isp"
local enterprise_projects = require "enterprise_projects"
local enterprise_turtle
local enterprise_chests = require "enterprise_chests"

-- usefull
local dthSiloRoot   = "mobj_silo"



--[[
    The following design decisions are made
        - The actual Silo's should never be accessed directly but only via the services of this mobj.
--]]

--    _                                     _   _               _
--   | |                                   | | | |             | |
--   | |__   __ _ ___  ___   _ __ ___   ___| |_| |__   ___   __| |___
--   | '_ \ / _` / __|/ _ \ | '_ ` _ \ / _ \ __| '_ \ / _ \ / _` / __|
--   | |_) | (_| \__ \  __/ | | | | | |  __/ |_| | | | (_) | (_| \__ \
--   |_.__/ \__,_|___/\___| |_| |_| |_|\___|\__|_| |_|\___/ \__,_|___/

function Silo:new(...)
    -- get & check input from description
    local checkSuccess, location, topChests, layers = InputChecker.Check([[
        Construct a Silo.

        Parameters:
            siteData                    - (table) data about this silo, like type and layout
                location                + (Location) location of site
                topChests               + (number, 2) # of top chests
                layers                  + (number, 2) # of layers
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Silo:new: Invalid input") return {} end

    -- main var
    local siteData  = {
        _id             = coreutils.NewId(),

        -- might be userfull later
        _version        = 1,

        -- locations
        _location       = location,
        _entryLocation  = location:getRelativeLocation(3, 3, 0),

        -- pickup and drop
        _dropLocation   = 0,
        _pickupLocation = 0,

        -- chests
        _topChests      = {},
        _storageChests  = {},
    }

    -- what kind of new silo is this?
    corelog.WriteToLog(">Starting silo at "..textutils.serialise(location, { compact = true }))

    -- add our top chests, depending how many we have
    if topChests >= 1 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(2, 5, 0), accessDirection="top"}).chestLocator) end
    if topChests >= 2 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(4, 5, 0), accessDirection="top"}).chestLocator) end
    if topChests >= 3 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(5, 4, 0), accessDirection="top"}).chestLocator) end
    if topChests >= 4 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(5, 2, 0), accessDirection="top"}).chestLocator) end
    if topChests >= 5 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(4, 1, 0), accessDirection="top"}).chestLocator) end
    if topChests >= 6 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(2, 1, 0), accessDirection="top"}).chestLocator) end
    if topChests >= 7 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(1, 2, 0), accessDirection="top"}).chestLocator) end
    if topChests >= 8 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(1, 4, 0), accessDirection="top"}).chestLocator) end

    -- set the defaults (basic setup)
    if topChests >= 1 then siteData._dropLocation   = 1 end
    if topChests >= 2 then siteData._pickupLocation = 2 end

    -- loop the layers
    for i=1, layers, 1 do

        -- do the floor
        local shaft = siteData._entryLocation:getRelativeLocation(0, 0, -1 - i)
        table.insert(siteData._storageChests, enterprise_chests.RegisterChest_SSrv({location=shaft:getDivergentDirection( 0,  1), accessDirection="side"}).chestLocator)
        table.insert(siteData._storageChests, enterprise_chests.RegisterChest_SSrv({location=shaft:getDivergentDirection( 1,  0), accessDirection="side"}).chestLocator)
        table.insert(siteData._storageChests, enterprise_chests.RegisterChest_SSrv({location=shaft:getDivergentDirection( 0, -1), accessDirection="side"}).chestLocator)
        table.insert(siteData._storageChests, enterprise_chests.RegisterChest_SSrv({location=shaft:getDivergentDirection(-1,  0), accessDirection="side"}).chestLocator)
    end

    -- set class info
    setmetatable(siteData, self)
    self.__index = self

    -- better save this shit
    siteData:Save()

    -- end
    return siteData
end

function Silo:load(id)
    return self
end

function Silo:getId()
    return self._id
end

function Silo:getLocation()
    return self._location
end

function Silo.HasFieldsOfType(chest)
    -- check
    if type(chest) ~= "table" then return false end
    if type(chest._id) ~= "string" then return false end
    if not Location.IsOfType(chest._location) then return false end
    if type(chest._accessDirection) ~= "string" then return false end
    if not Inventory.IsOfType(chest._inventory) then return false end

    -- end
    return true
end

function Silo.HasMethodsOfType(chest)
    -- check
    if not chest.new then return false end

    -- end
    return true
end

function Silo.IsOfType(chest)
    -- check
    return Silo.HasFieldsOfType(chest) and Silo.HasMethodsOfType(chest)
end

function Silo:isSame(chest)
    -- check input
    if not Silo.IsOfType(chest) then return false end

    -- check same object
    local isSame =  self._id == chest._id
                and self._location:isSame(chest._location)
                and self._accessDirection == chest._accessDirection
                and self._inventory:isSame(chest._inventory)

    -- end
    return isSame
end

function Silo:copy()
    local copy = Silo:new({
        _id             = self._id,

        _location       = self._location:copy(),
        _accessDirection= self._accessDirection,
        _inventory      = self._inventory:copy(),
    })

    return copy
end

--                        _                           _   _               _
--                       (_)                         | | | |             | |
--    ___  ___ _ ____   ___  ___ ___   _ __ ___   ___| |_| |__   ___   __| |___
--   / __|/ _ \ '__\ \ / / |/ __/ _ \ | '_ ` _ \ / _ \ __| '_ \ / _ \ / _` / __|
--   \__ \  __/ |   \ V /| | (_|  __/ | | | | | |  __/ |_| | | | (_) | (_| \__ \
--   |___/\___|_|    \_/ |_|\___\___| |_| |_| |_|\___|\__|_| |_|\___/ \__,_|___/

function Silo:getDropLocation()
    -- easy
    return self._topChests[self._dropLocation]
end

function Silo:VerifyReadyToDrop_QSrv(itemList)

    -- would the systeem be ready for the drop of the itemList?
    return true
end

function Silo:RequestPermissionToDrop_QSrv(itemList)

    -- reserve space for the drop
    return true -- true means you are expected to drop the items in the itemList, and call
end

function Silo:MessageItemsDropped_SSrv(itemList)

    -- initiate storing of the dropped items

    -- useless return
    return "Thanks you for your message"
end

function Silo:getPickupLocation()
    -- easy
    return self._topChests[self._pickupLocation]
end

function Silo:ItemsAvailable_QSrv(itemList)

    -- fake we have everything
    return true
end

function Silo:OrderItems_ASrv(itemList, callback)

    -- fake we have delivered
    return true
end

function Silo:MessageItemPickedup_SSrv(itemList)

    -- mark items are picked up

    -- useless return
    return "Thanks you for your message"
end

function Silo:Save()
    -- we need a valid zelf
    if type(self) ~= "table" or type(self._id) ~= "string" then return false end

    -- easy save this shit, just the data
    coredht.SaveData(self, dthSiloRoot, self._id)
end

function Silo:Load(siloId)

    -- reload self as default
    siloId = siloId or self._id

    -- we need a valid zelf
    if type(siloId) ~= "string" then return false end

    -- load this shit
    local siloData = coredht.GetData(dthSiloRoot, siloId)

    -- set class info
    setmetatable(siloData, self)
    self.__index = self

    -- done
    return siloData
end

return Silo

