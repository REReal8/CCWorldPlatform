local Silo = {
    _id                     = "",
    _version                = 1,

    _location               = nil,
    _entryLocation          = nil,

    _dropLocation           = 0,
    _pickupLocation         = 0,

    _topChests              = nil,
    _storageChests          = nil,
}

local coreutils = require "coreutils"
local corelog = require "corelog"
local coredht = require "coredht"

local InputChecker = require "input_checker"
local Callback = require "obj_callback"
local ObjArray = require "obj_array"

local Location = require "obj_location"
local Inventory = require "obj_inventory"

local role_fuel_worker = require "role_fuel_worker"
local role_chests_worker = require "role_chests_worker"

local enterprise_isp = require "enterprise_isp"
local enterprise_projects = require "enterprise_projects"
local enterprise_turtle
local enterprise_chests = require "enterprise_chests"
local enterprise_storage

-- usefull
local dthSiloRoot   = "mobj_silo"



--[[
    The following design decisions are made
        - The actual Silo's should never be accessed directly but only via the services of this mobj.
--]]

--    _                                     _   _               _
--   | |                                   | | | |             | |
--   | |__   __ _ ___  ___   _ __ ___   ___| |_| |__   ___   __| |___
--   | '_ \ / _` / __|/ _ \ | '_ ` _ \ / _ \ __| '_ \ / _ \ / _` / __|
--   | |_) | (_| \__ \  __/ | | | | | |  __/ |_| | | | (_) | (_| \__ \
--   |_.__/ \__,_|___/\___| |_| |_| |_|\___|\__|_| |_|\___/ \__,_|___/

function Silo:NewSilo(...)
    -- get & check input from description
    local checkSuccess, location, topChests, layers = InputChecker.Check([[
        Construct a Silo.

        Parameters:
            siteData                    - (table) data about this silo, like type and layout
                location                + (Location) location of site
                topChests               + (number, 2) # of top chests
                layers                  + (number, 2) # of layers
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Silo:new: Invalid input") return {} end

    -- better safe then sorry, maybe flexible one day
    location:setDX(0)
    location:setDY(1)

    -- main var
    local siteData  = {
        _id             = coreutils.NewId(),

        -- might be userfull later
        _version        = 1,

        -- locations
        _location       = location,
        _entryLocation  = location:getRelativeLocation(3, 3, 0),

        -- pickup and drop
        _dropLocation   = 0,
        _pickupLocation = 0,

        -- chests
        _topChests      = ObjArray:new({
            _objClassName = "URL",
        }),
        _storageChests  = ObjArray:new({
            _objClassName = "URL",
        }),
    }

    -- what kind of new silo is this?
    corelog.WriteToLog(">Starting silo at "..textutils.serialise(location, { compact = true }))

    -- add our top chests, depending how many we have
    if topChests >= 1 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(2, 5, 0), accessDirection="back"}).chestLocator) end
    if topChests >= 2 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(4, 5, 0), accessDirection="back"}).chestLocator) end
    if topChests >= 3 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(5, 4, 0), accessDirection="left"}).chestLocator) end
    if topChests >= 4 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(5, 2, 0), accessDirection="left"}).chestLocator) end
    if topChests >= 5 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(4, 1, 0), accessDirection="front"}).chestLocator) end
    if topChests >= 6 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(2, 1, 0), accessDirection="front"}).chestLocator) end
    if topChests >= 7 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(1, 2, 0), accessDirection="right"}).chestLocator) end
    if topChests >= 8 then table.insert(siteData._topChests, enterprise_chests.RegisterChest_SSrv({location=location:getRelativeLocation(1, 4, 0), accessDirection="right"}).chestLocator) end

    -- set the defaults (basic setup)
    if topChests >= 1 then siteData._dropLocation   = 1 end
    if topChests >= 2 then siteData._pickupLocation = 2 end

    -- loop the layers
    for i=1, layers, 1 do

        -- do the floor
        local shaft = siteData._entryLocation:getRelativeLocation(0, 0, -1 - i)
        table.insert(siteData._storageChests, enterprise_chests.RegisterChest_SSrv({location=shaft:getDivergentDirection( 0,  1):getLocationFront(), accessDirection="back"}).chestLocator)
        table.insert(siteData._storageChests, enterprise_chests.RegisterChest_SSrv({location=shaft:getDivergentDirection( 1,  0):getLocationFront(), accessDirection="back"}).chestLocator)
        table.insert(siteData._storageChests, enterprise_chests.RegisterChest_SSrv({location=shaft:getDivergentDirection( 0, -1):getLocationFront(), accessDirection="back"}).chestLocator)
        table.insert(siteData._storageChests, enterprise_chests.RegisterChest_SSrv({location=shaft:getDivergentDirection(-1,  0):getLocationFront(), accessDirection="back"}).chestLocator)
    end

    -- set class info
    setmetatable(siteData, self)
    self.__index = self

    -- end
    return siteData
end

function Silo:getId()
    return self._id
end

function Silo:getLocation()
    return self._location
end

--    _____ ____  _     _                  _   _               _
--   |_   _/ __ \| |   (_)                | | | |             | |
--     | || |  | | |__  _   _ __ ___   ___| |_| |__   ___   __| |___
--     | || |  | | '_ \| | | '_ ` _ \ / _ \ __| '_ \ / _ \ / _` / __|
--    _| || |__| | |_) | | | | | | | |  __/ |_| | | | (_) | (_| \__ \
--   |_____\____/|_.__/| | |_| |_| |_|\___|\__|_| |_|\___/ \__,_|___/
--                    _/ |
--                   |__/

function Silo:new(...)
    -- get & check input from description
    local checkSuccess, o = InputChecker.Check([[
        Construct a Silo.

        Parameters:
            o                           + (table) data about this silo, like type and layout
                _id                     - (string) id of the Silo
                _version                - (number) version of the Silo
                _location               - (Location) location of the Silo
                _entryLocation          - (Location) entry location of the Silo
                _dropLocation           - (number) top chest index
                _pickupLocation         - (number) top chest index
                _topChests              - (ObjArray) with top chests
                _storageChests          - (ObjArray) with storage chests
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Silo:new: Invalid input") return {} end

    -- set class info
    setmetatable(o, self)
    self.__index = self

    -- end
    return o
end

function Silo:getClassName()
    return "Silo"
end

function Silo.HasFieldsOfType(obj)
    -- check
    if type(obj) ~= "table" then return false end
    if type(obj._id) ~= "string" then return false end
    if type(obj._version) ~= "number" then return false end

    if not Location.IsOfType(obj._location) then return false end
    if not Location.IsOfType(obj._entryLocation) then return false end

    if type(obj._dropLocation) ~= "number" then return false end
    if type(obj._pickupLocation) ~= "number" then return false end

    if not ObjArray.IsOfType(obj._topChests) then return false end
    if not ObjArray.IsOfType(obj._storageChests) then return false end

    -- end
    return true
end

function Silo.HasClassNameOfType(obj)
    -- check
    if not obj.getClassName or obj:getClassName() ~= Silo:getClassName() then return false end

    -- end
    return true
end

function Silo.IsOfType(obj)
    -- check
    return Silo.HasFieldsOfType(obj) and Silo.HasClassNameOfType(obj)
end

function Silo:isSame(obj)
    -- check input
    if not Silo.IsOfType(obj) then return false end

    -- check same object
    local isSame =  self._id == obj._id
                and self._version == obj._version

                and self._location:isSame(obj._location)
                and self._entryLocation:isSame(obj._entryLocation)

                and self._dropLocation == obj._dropLocation
                and self._pickupLocation == obj._pickupLocation

                and self._topChests:isSame(obj._topChests)
                and self._storageChests:isSame(obj._storageChests)

    -- end
    return isSame
end

function Silo:copy()
    local copy = Silo:new({
        _id             = self._id,
        _version        = self._version,

        _location       = self._location:copy(),
        _entryLocation  = self._entryLocation:copy(),

        -- pickup and drop
        _dropLocation   = self._dropLocation,
        _pickupLocation = self._pickupLocation,

        -- chests
        _topChests      = self._topChests:copy(),
        _storageChests  = self._storageChests:copy(),
    })

    return copy
end

--                        _                           _   _               _
--                       (_)                         | | | |             | |
--    ___  ___ _ ____   ___  ___ ___   _ __ ___   ___| |_| |__   ___   __| |___
--   / __|/ _ \ '__\ \ / / |/ __/ _ \ | '_ ` _ \ / _ \ __| '_ \ / _ \ / _` / __|
--   \__ \  __/ |   \ V /| | (_|  __/ | | | | | |  __/ |_| | | | (_) | (_| \__ \
--   |___/\___|_|    \_/ |_|\___\___| |_| |_| |_|\___|\__|_| |_|\___/ \__,_|___/

function Silo:provideItemsTo_AOSrv(...)
    -- get & check input from description
    local checkSuccess, provideItems, itemDepotLocator, assignmentsPriorityKey, callback = InputChecker.Check([[
        This async public ItemSupplier service provides specific items to an ItemDepot.

        Return value:
                                                - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                                - (table)
                success                         - (boolean) whether the service executed correctly
                destinationItemsLocator         - (URL) locating the final ItemDepot and the items that where transferred to it
                                                    (upon service succes the "host" component of this URL should be equal to itemDepotLocator, and
                                                    the "query" should be equal to orderItems)

        Parameters:
            serviceData                         - (table) data for the service
                provideItems                    + (table) with one or more items (formatted as an array of [itemName] = itemCount key-value pairs) to provide
                itemDepotLocator                + (URL) locating the ItemDepot where the items need to be provided to
                assignmentsPriorityKey          + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                            + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Silo:provideItemsTo_AOSrv: Invalid input") return Callback.ErrorCall(callback) end

    -- ToDo: implement
    corelog.Warning("Silo:provideItemsTo_AOSrv: not yet implemented")
    return Callback.ErrorCall(callback)
end

function Silo:can_ProvideItems_QOSrv(...)
    -- get & check input from description
    local checkSuccess, provideItems = InputChecker.Check([[
        This sync public query service answers the question whether the ItemSupplier can provide specific items.

        Return value:
                                    - (table)
                success             - (boolean) whether the answer to the question is true

        Parameters:
            serviceData             - (table) data to the query
                provideItems        + (table) with one or more items (formatted as an array of [itemName] = itemCount key-value pairs) to provide
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Silo:can_ProvideItems_QOSrv: Invalid input") return {success = false} end

    -- ToDo: implement
    corelog.Warning("Silo:can_ProvideItems_QOSrv: not yet implemented")
    return {success = true}
end

function Silo:needsTo_ProvideItemsTo_SOSrv(...)
    -- get & check input from description
    local checkSuccess, provideItems, itemDepotLocator = InputChecker.Check([[
        This sync public service returns the needs for the ItemSupplier to provide specific items to an ItemDepot.

        Return value:
                                                - (table)
                success                         - (boolean) whether the service executed correctly
                fuelNeed                        - (number) amount of fuel needed to provide items
                ingredientsNeed                 - (table) ingredients needed to provide items

        Parameters:
            serviceData                         - (table) data to the query
                provideItems                    + (table) with one or more items (formatted as an array of [itemName] = itemCount key-value pairs) to provide
                itemDepotLocator                + (URL) locating the ItemDepot where the items need to be provided to
                ingredientsItemSupplierLocator  - (URL, nil) locating where ingredients can be retrieved
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Silo:needsTo_ProvideItemsTo_SOSrv: Invalid input") return {success = false} end

    -- ToDo: implement
    corelog.Warning("Silo:needsTo_ProvideItemsTo_SOSrv: not yet implemented")
    return {success = true, fuelNeed = 10 + #self._storageChests}
end

function Silo:storeItemsFrom_AOSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, assignmentsPriorityKey, callback = InputChecker.Check([[
        This async public ItemDepot service stores items from from an ItemSupplier.

        An ItemDepot should take special care the transfer from the turtle inventory gets priority over other assignments to the turtle.

        Return value:
                                        - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully
                destinationItemsLocator - (URL) stating the final ItemDepot and the items that where stored
                                            (upon service succes the "base" component of this URL should be equal to itemDepotLocator
                                            and the "query" should be equal to the "query" component of the itemsLocator)

        Parameters:
            serviceData                 - (table) data about the service
                itemsLocator            + (URL) locating the items to store
                                            (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                            (the "query" component of the URL specifies the items)
                assignmentsPriorityKey  + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                    + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Silo:storeItemsFrom_AOSrv: Invalid input") return Callback.ErrorCall(callback) end

    -- set (expected) destinationItemsLocator
    enterprise_storage = enterprise_storage or require "enterprise_storage"
    local destinationItemsLocator = enterprise_storage:getObjectLocator(self)
    destinationItemsLocator:setQuery(coreutils.DeepCopy(itemsLocator:getQuery()))

    -- create project definition
    enterprise_turtle = enterprise_turtle or require "enterprise_turtle"
    local projectData = {
        itemsLocator            = itemsLocator,
        dropLocator             = self:getDropLocation(),
        assignmentsPriorityKey  = assignmentsPriorityKey,

        destinationItemsLocator = destinationItemsLocator,

        silo                    = self:copy(),
    }
    local projectDef = {
        steps   = {
            -- roept functie aan die goederen van pickup locati enaar silo topchest
            { stepType = "ASrv", stepTypeDef = { moduleName = "enterprise_isp", serviceName = "StoreItemsFrom_ASrv" }, stepDataDef = {
                { keyDef = "itemsLocator"           , sourceStep = 0, sourceKeyDef = "itemsLocator" },
                { keyDef = "itemDepotLocator"       , sourceStep = 0, sourceKeyDef = "dropLocator" },
                { keyDef = "assignmentsPriorityKey" , sourceStep = 0, sourceKeyDef = "assignmentsPriorityKey" },
            }},
            -- roept functie aan die goederen van topchest opslaat in de silo
                -- roept functie aan die bepalen welke items naar welke chjests moeten
                    -- indien geen ruimte, eerst enterprise inschakelen voor uitbreiding
                -- per goederen type opslaan
            { stepType = "AOSrv", stepTypeDef = { className = "Silo", serviceName = "fromTopchestIntoSilo_AOSrv", objStep = 0, objKeyDef = "silo" }, stepDataDef = {
                { keyDef = "itemsLocator"           , sourceStep = 1, sourceKeyDef = "destinationItemsLocator" },
                { keyDef = "assignmentsPriorityKey" , sourceStep = 0, sourceKeyDef = "assignmentsPriorityKey" },
            }},
            -- check for succes
            { stepType = "SSrv", stepTypeDef = { moduleName = "enterprise_projects", serviceName = "AreAllTrue_QSrv" }, stepDataDef = {
                { keyDef = "success1"               , sourceStep = 1, sourceKeyDef = "success" },
                { keyDef = "success2"               , sourceStep = 2, sourceKeyDef = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , sourceStep = 3, sourceKeyDef = "success" },
            { keyDef = "destinationItemsLocator"    , sourceStep = 0, sourceKeyDef = "destinationItemsLocator" },
        }
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    corelog.WriteToLog(">Store "..itemsLocator:getURI().." into Silo")
    return enterprise_projects.StartProject_ASrv(projectServiceData, callback)
end

function Silo:can_StoreItems_QOSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator = InputChecker.Check([[
        This sync public query service answers the question whether the ItemDepot can store specific items.

        Return value:
                                    - (table)
                success             - (boolean) whether the answer to the question is true

        Parameters:
            serviceData             - (table) data to the query
                itemsLocator        + (URL) locating the items that need to be stored
                                        (the "base" component of the URL specifies the ItemDepot to store the items in)
                                        (the "query" component of the URL specifies the items to query for)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Silo:can_StoreItems_QOSrv: Invalid input") return {success = false} end

    -- ToDo: implement
    corelog.Warning("Silo:can_StoreItems_QOSrv: not yet implemented")
    return {success = true} -- we can always store (at least that is what we pretent)
end

function Silo:needsTo_StoreItemsFrom_SOSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator = InputChecker.Check([[
        This sync public service returns the needs to store specific items from an ItemSupplier.

        Return value:
                                                - (table)
                success                         - (boolean) whether the service executed correctly
                fuelNeed                        - (number) amount of fuel needed to store items

        Parameters:
            serviceData                         - (table) data to the query
                itemsLocator                    + (URL) locating the items to store
                                                    (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                                    (the "query" component of the URL specifies the items)
    --]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Silo:needsTo_StoreItemsFrom_SOSrv: Invalid input") return {success = false} end

    -- ToDo: implement
    corelog.Warning("Silo:needsTo_StoreItemsFrom_SOSrv: not yet implemented")
    return {success = true, fuelNeed = 10 + #self._storageChests} -- we can fix anything with that much fuel
end

function Silo:getDropLocation()
    -- easy
    return self._topChests[self._dropLocation]
end

function Silo:getPickupLocation()
    -- easy
    return self._topChests[self._pickupLocation]
end

function Silo:Save()
    -- we need a valid zelf
    if type(self) ~= "table" or type(self._id) ~= "string" then return false end

    -- easy save this shit, just the data
    coredht.SaveData(self, dthSiloRoot, self._id)
end

function Silo:reload()
    -- just load the damn fucker, use our own id
    self:load(self._id)
end

function Silo:load(siloId)
    -- we need a valid id to work
    if type(siloId) ~= "string" then return false end

    -- load this shit
    local siloData = coredht.GetData(dthSiloRoot, siloId)

    -- check our result
    if type(siloData) == "table" then

        -- set class info
        setmetatable(siloData, self)
        self.__index = self

        -- done
        return siloData
    else
        -- found nothing gives nothing
        return nil
    end
end

function Silo:Delete()
    -- for debugging only
    corelog.WriteToLog("Oh no, someone is deleting a silo!!!")

    -- Why would you ever want to delete such a magnificent structure. Only written for testing purposes
    for i, chestLocator in ipairs(self._topChests) do enterprise_chests:deleteResource(chestLocator) end
    for i, chestLocator in ipairs(self._storageChests) do enterprise_chests:deleteResource(chestLocator) end

    -- remove from the data storage
    coredht.SaveData(nil, dthSiloRoot, self._id)

    -- we no longer exist
    self._id = nil
end

-- private methods

function Silo:fromTopchestIntoSilo_AOSrv(...)
    -- get & check input from description
    local checkSuccess, itemsLocator, assignmentsPriorityKey, callback = InputChecker.Check([[
        Todo betere omschrijving
            -- roept functie aan die bepalen welke items naar welke chjests moeten
            -- indien geen ruimte, eerst enterprise inschakelen voor uitbreiding
            -- per goederen type opslaan

        Return value:
                                        - (boolean) whether the service was scheduled successfully

        Async service return value (to Callback):
                                        - (table)
                success                 - (boolean) whether the service executed successfully

        Parameters:
            serviceData                 - (table) data about the service
                itemsLocator            + (URL) locating the items to store
                                            (the "base" component of the URL specifies the ItemSupplier that provides the items)
                                            (the "query" component of the URL specifies the items)
                assignmentsPriorityKey  + (string, "") priorityKey that should be set for all assignments triggered by this service
            callback                    + (Callback) to call once service is ready
    ]], table.unpack(arg))
    if not checkSuccess then corelog.Error("Silo:fromTopchestIntoSilo_AOSrv: Invalid input") return Callback.ErrorCall(callback) end

    corelog.WriteToLog("fromTopchestIntoSilo_AOSrv begin")

    local projectData = {
        itemsLocator            = itemsLocator,
        chestOneLocator         = self._storageChests[ math.random( #self._storageChests ) ],
        assignmentsPriorityKey  = assignmentsPriorityKey,
    }
    local projectDef = {
        steps   = {
            -- roept functie aan die goederen van pickup locati enaar silo topchest
            { stepType = "ASrv", stepTypeDef = { moduleName = "enterprise_isp", serviceName = "StoreItemsFrom_ASrv" }, stepDataDef = {
                { keyDef = "itemsLocator"           , sourceStep = 0, sourceKeyDef = "itemsLocator" },
                { keyDef = "itemDepotLocator"       , sourceStep = 0, sourceKeyDef = "chestOneLocator" },
                { keyDef = "assignmentsPriorityKey" , sourceStep = 0, sourceKeyDef = "assignmentsPriorityKey" },
            }},
            -- check for succes
            { stepType = "SSrv", stepTypeDef = { moduleName = "enterprise_projects", serviceName = "AreAllTrue_QSrv" }, stepDataDef = {
                { keyDef = "success1"               , sourceStep = 1, sourceKeyDef = "success" },
            }},
        },
        returnData  = {
            { keyDef = "success"                    , sourceStep = 2, sourceKeyDef = "success" },
        }
    }
    local projectServiceData = {
        projectDef  = projectDef,
        projectData = projectData,
    }

    -- start project
    corelog.WriteToLog(">fromTopchestIntoSilo_AOSrv(...)")
    return enterprise_projects.StartProject_ASrv(projectServiceData, callback)
end

return Silo

